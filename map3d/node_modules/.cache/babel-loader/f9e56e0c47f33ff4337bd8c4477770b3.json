{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _MODULE_INJECTORS;\n\nimport { MODULE_INJECTORS_VS, MODULE_INJECTORS_FS } from '../modules/module-injectors';\nimport { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport assert from 'assert'; // TODO - experimental\n\nvar MODULE_INJECTORS = (_MODULE_INJECTORS = {}, _defineProperty(_MODULE_INJECTORS, VERTEX_SHADER, MODULE_INJECTORS_VS), _defineProperty(_MODULE_INJECTORS, FRAGMENT_SHADER, MODULE_INJECTORS_FS), _MODULE_INJECTORS);\nvar REGEX_DECLARATIONS = /^(#version[^\\n]*\\n)?/; // Beginning of file\n\nvar REGEX_START_OF_MAIN = /main\\s*\\([^\\)]*\\)\\s*\\{\\n?/; // Beginning of main\n\nvar REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\n// A minimal shader injection/templating system.\n// RFC: https://github.com/uber/luma.gl/blob/master/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n\n/* eslint-disable complexity */\n\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  var isVertex = type === VERTEX_SHADER;\n\n  var _loop = function _loop(key) {\n    var fragment = inject[key];\n\n    switch (key) {\n      // declarations are injected at beginning of shader\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(REGEX_DECLARATIONS, function (match) {\n            return match + fragment;\n          });\n        }\n\n        break;\n      // main code is injected at the end of main function\n\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, function (match) {\n            return match + fragment;\n          });\n        }\n\n        break;\n\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, function (match) {\n            return fragment + match;\n          });\n        }\n\n        break;\n\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(REGEX_DECLARATIONS, function (match) {\n            return match + fragment;\n          });\n        }\n\n        break;\n\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, function (match) {\n            return match + fragment;\n          });\n        }\n\n        break;\n\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, function (match) {\n            return fragment + match;\n          });\n        }\n\n        break;\n\n      default:\n        // inject code after key, leaving key in place\n        source = source.replace(key, function (match) {\n          return match + fragment;\n        });\n    }\n  };\n\n  for (var key in inject) {\n    _loop(key);\n  } // Finally, if requested, insert an automatic module injector chunk\n\n\n  if (injectStandardStubs) {\n    source = source.replace('}\\s*$', function (match) {\n      return match + MODULE_INJECTORS[type];\n    });\n  }\n\n  return source;\n}\n/* eslint-enable complexity */\n// Takes an array of inject objects and combines them into one\n\nexport function combineInjects(injects) {\n  var result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(function (inject) {\n    for (var key in inject) {\n      result[key] = result[key] ? \"\".concat(result[key], \"\\n\").concat(inject[key]) : inject[key];\n    }\n  });\n  return result;\n}","map":null,"metadata":{},"sourceType":"module"}