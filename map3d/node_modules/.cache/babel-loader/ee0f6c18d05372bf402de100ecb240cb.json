{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // WebGL2 VertexArray Objects Helper\n\n\nimport { glKey } from './gl-constants';\nimport { isWebGL2 } from './context';\nimport Resource from './resource';\nimport assert from 'assert';\nimport { log } from '../utils';\n/* eslint-disable camelcase */\n\nvar OES_vertex_array_object = 'OES_vertex_array_object';\nvar GL_ELEMENT_ARRAY_BUFFER = 0x8893; // const GL_CURRENT_VERTEX_ATTRIB = 0x8626;\n\nvar GL_VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;\nvar GL_VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;\nvar GL_VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;\nvar GL_VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;\nvar GL_VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;\nvar GL_VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;\nvar GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;\nvar GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD;\nvar GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;\nvar PARAMETERS = [GL_VERTEX_ATTRIB_ARRAY_ENABLED, GL_VERTEX_ATTRIB_ARRAY_SIZE, GL_VERTEX_ATTRIB_ARRAY_STRIDE, GL_VERTEX_ATTRIB_ARRAY_TYPE, GL_VERTEX_ATTRIB_ARRAY_NORMALIZED, GL_VERTEX_ATTRIB_ARRAY_POINTER, GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING, GL_VERTEX_ATTRIB_ARRAY_INTEGER, GL_VERTEX_ATTRIB_ARRAY_DIVISOR];\nvar ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';\n\nvar VertexArray =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(VertexArray, _Resource);\n\n  _createClass(VertexArray, [{\n    key: 'MAX_ATTRIBUTES',\n    get: function get() {\n      return this.gl.getParameter(this.gl.MAX_VERTEX_ATTRIBS);\n    } // Create a VertexArray\n\n  }], [{\n    key: 'isSupported',\n    value: function isSupported(gl) {\n      return isWebGL2(gl) || gl.getExtension(OES_vertex_array_object);\n    }\n  }, {\n    key: 'getDefaultArray',\n    value: function getDefaultArray(gl) {\n      gl.luma = gl.luma || {};\n\n      if (!gl.luma.defaultVertexArray) {\n        gl.luma.defaultVertexArray = new VertexArray(gl, {\n          handle: null\n        });\n      }\n\n      return gl.luma.defaultVertexArray;\n    }\n  }, {\n    key: 'getMaxAttributes',\n    value: function getMaxAttributes(gl) {\n      return gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    }\n  }]);\n\n  function VertexArray(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, VertexArray);\n\n    var _this = _possibleConstructorReturn(this, (VertexArray.__proto__ || Object.getPrototypeOf(VertexArray)).call(this, gl, opts));\n\n    _this.elements = null;\n    _this.buffers = {}; // new Array(this.MAX_VERTEX_ATTRIBS).fill(null);\n\n    _this.locations = {};\n    _this.names = {};\n    _this.drawParameters = {};\n    _this._bound = false;\n    Object.seal(_this);\n\n    _this.initialize(opts);\n\n    return _this;\n  }\n\n  _createClass(VertexArray, [{\n    key: 'initialize',\n    value: function initialize() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$buffers = _ref.buffers,\n          buffers = _ref$buffers === undefined ? {} : _ref$buffers,\n          _ref$elements = _ref.elements,\n          elements = _ref$elements === undefined ? null : _ref$elements,\n          _ref$locations = _ref.locations,\n          locations = _ref$locations === undefined ? {} : _ref$locations;\n\n      this.setLocations(locations);\n      this.setBuffers(buffers, {\n        clear: true\n      });\n      this.setElements(elements);\n    } // Register an optional buffer name to location mapping\n\n  }, {\n    key: 'setLocations',\n    value: function setLocations(locations) {\n      this.locations = locations;\n      this.names = {};\n    } // Set (bind) an elements buffer, for indexed rendering. Must be GL.ELEMENT_ARRAY_BUFFER\n\n  }, {\n    key: 'setElements',\n    value: function setElements(elements) {\n      assert(!elements || elements.target === GL_ELEMENT_ARRAY_BUFFER, ERR_ELEMENTS);\n      this.ext.bindVertexArray(this.handle);\n      this.gl.bindBuffer(GL_ELEMENT_ARRAY_BUFFER, elements && elements.handle);\n      this.ext.bindVertexArray(null);\n      this.elements = elements;\n      return this;\n    } // Set (bind) an array or map of vertex array buffers, either in numbered or\n    // named locations. (named locations requires `locations` to have been provided).\n    // For names that are not present in `location`, the supplied buffers will be ignored.\n    // if a single buffer of type GL.ELEMENT_ARRAY_BUFFER is present, it will be set as elements\n    // @param {Object} buffers - An object map with attribute names being keys\n    //   and values are expected to be instances of Buffer.\n\n  }, {\n    key: '_getBufferAndLayout',\n    value: function _getBufferAndLayout(bufferData) {\n      // Check if buffer was supplied\n      var buffer = void 0;\n      var layout = void 0;\n\n      if (bufferData.handle) {\n        buffer = bufferData;\n        layout = bufferData.layout;\n      } else {\n        buffer = bufferData.buffer;\n        layout = Object.assign({}, buffer.layout, bufferData.layout || {}, bufferData);\n      }\n\n      return {\n        buffer: buffer,\n        layout: layout\n      };\n    }\n  }, {\n    key: 'setBuffers',\n    value: function setBuffers(buffers, _ref2) {\n      var clear = _ref2.clear,\n          check = _ref2.check;\n\n      var _getLocations2 = this._getLocations(buffers),\n          locations = _getLocations2.locations,\n          elements = _getLocations2.elements;\n\n      this.ext.bindVertexArray(this.handle); // Process locations in order\n\n      for (var location in locations) {\n        var bufferData = locations[location];\n\n        if (bufferData) {\n          var _getBufferAndLayout2 = this._getBufferAndLayout(bufferData),\n              buffer = _getBufferAndLayout2.buffer,\n              layout = _getBufferAndLayout2.layout;\n\n          this.setBuffer({\n            location: location,\n            buffer: buffer,\n            layout: layout\n          });\n          this.setDivisor(location, layout.instanced ? 1 : 0);\n          this.enable(location);\n        } else {\n          // DISABLE MISSING ATTRIBUTE\n          this.disable(location);\n        }\n      }\n\n      this.buffers = buffers;\n      this.ext.bindVertexArray(null);\n\n      if (elements) {\n        this.setElements(elements);\n      }\n\n      if (check) {\n        this._checkBuffers();\n      }\n    } // Enable an attribute\n\n  }, {\n    key: 'enable',\n    value: function enable(location) {\n      var _this2 = this;\n\n      this.bind(function () {\n        _this2.gl.enableVertexAttribArray(location);\n      });\n    } // Disable an attribute\n\n  }, {\n    key: 'disable',\n    value: function disable(location) {\n      var _this3 = this; // Don't disable location 0\n\n\n      if (location > 0) {\n        this.bind(function () {\n          _this3.gl.disableVertexAttribArray(location);\n        });\n      }\n    } // Set the frequency divisor used for instanced rendering.\n\n  }, {\n    key: 'setDivisor',\n    value: function setDivisor(location, divisor) {\n      var _this4 = this;\n\n      this.bind(function () {\n        _this4.ext.vertexAttribDivisor(location, divisor);\n      });\n    } // Set a location in vertex attributes array to a buffer\n\n  }, {\n    key: 'setBuffer',\n    value: function setBuffer() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          location = _ref3.location,\n          buffer = _ref3.buffer,\n          target = _ref3.target,\n          layout = _ref3.layout;\n\n      var gl = this.gl; // Copy main data characteristics from buffer\n\n      target = target !== undefined ? target : buffer.target;\n      layout = layout !== undefined ? layout : buffer.layout;\n      assert(target, 'setBuffer needs target');\n      assert(layout, 'setBuffer called on uninitialized buffer');\n      this.bind(function () {\n        // a non-zero named buffer object must be bound to the GL_ARRAY_BUFFER target\n        buffer.bind({\n          target: gl.ARRAY_BUFFER\n        });\n        var _layout = layout,\n            size = _layout.size,\n            type = _layout.type,\n            normalized = _layout.normalized,\n            stride = _layout.stride,\n            offset = _layout.offset; // Attach _bound ARRAY_BUFFER with specified buffer format to location\n\n        if (!layout.integer) {\n          gl.vertexAttribPointer(location, size, type, normalized, stride, offset);\n        } else {\n          // specifies *integer* data formats and locations of vertex attributes\n          assert(isWebGL2(gl));\n          gl.vertexAttribIPointer(location, size, type, stride, offset);\n        }\n      });\n    } // Specify values for generic vertex attributes\n\n  }, {\n    key: 'setGeneric',\n    value: function setGeneric(_ref4) {\n      var location = _ref4.location,\n          array = _ref4.array;\n      log.warn(0, 'VertexAttributes.setGeneric is not well tested'); // throw new Error('vertex attribute size must be between 1 and 4');\n\n      var gl = this.gl;\n\n      switch (array.constructor) {\n        case Float32Array:\n          gl.vertexAttrib4fv(location, array);\n          break;\n\n        case Int32Array:\n          assert(isWebGL2(gl));\n          gl.vertexAttribI4iv(location, array);\n          break;\n\n        case Uint32Array:\n          assert(isWebGL2(gl));\n          gl.vertexAttribI4uiv(location, array);\n          break;\n\n        default:\n      }\n\n      return this;\n    } // Specify values for generic vertex attributes\n\n  }, {\n    key: 'setGenericValues',\n    value: function setGenericValues(location, v0, v1, v2, v3) {\n      log.warn(0, 'VertexAttributes.setGenericValues is not well tested');\n\n      switch (arguments.length - 1) {\n        case 1:\n          this.gl.vertexAttrib1f(location, v0);\n          break;\n\n        case 2:\n          this.gl.vertexAttrib2f(location, v0, v1);\n          break;\n\n        case 3:\n          this.gl.vertexAttrib3f(location, v0, v1, v2);\n          break;\n\n        case 4:\n          this.gl.vertexAttrib4f(location, v0, v1, v2, v3);\n          break;\n\n        default:\n          throw new Error('vertex attribute size must be between 1 and 4');\n      } // assert(gl instanceof WebGL2RenderingContext, 'WebGL2 required');\n      // Looks like these will check how many arguments were supplied?\n      // gl.vertexAttribI4i(location, v0, v1, v2, v3);\n      // gl.vertexAttribI4ui(location, v0, v1, v2, v3);\n\n    }\n  }, {\n    key: 'bind',\n    value: function bind() {\n      var funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;\n\n      if (typeof funcOrHandle !== 'function') {\n        this.bindVertexArray(funcOrHandle);\n        return this;\n      }\n\n      var value = void 0;\n\n      if (!this._bound) {\n        this.ext.bindVertexArray(this.handle);\n        this._bound = true;\n        value = funcOrHandle();\n        this.ext.bindVertexArray(null);\n        this._bound = false;\n      } else {\n        value = funcOrHandle();\n      }\n\n      return value;\n    } // PRIVATE\n    // Auto detect draw parameters from the complement of buffers provided\n\n  }, {\n    key: '_deduceDrawParameters',\n    value: function _deduceDrawParameters() {\n      // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER\n      // index type is saved for drawElement calls\n      var isInstanced = false;\n      var isIndexed = false;\n      var indexType = null; // Check if we have an elements array buffer\n\n      if (this.elements) {\n        isIndexed = true;\n        indexType = this.elements.layout.type;\n      } // Check if any instanced buffers\n\n\n      this.buffers.forEach(function (buffer) {\n        if (buffer.layout.instanced > 0) {\n          isInstanced = true;\n        }\n      });\n      return {\n        isInstanced: isInstanced,\n        isIndexed: isIndexed,\n        indexType: indexType\n      };\n    } //         this._filledLocations[bufferName] = true;\n\n  }, {\n    key: '_getLocations',\n    value: function _getLocations(buffers) {\n      // Try to extract elements and locations\n      var elements = null;\n      var locations = {};\n\n      for (var bufferName in buffers) {\n        var buffer = buffers[bufferName]; // Check if this is an elements array\n\n        if (buffer && buffer.target === GL_ELEMENT_ARRAY_BUFFER) {\n          assert(!elements, 'Duplicate GL.ELEMENT_ARRAY_BUFFER'); // assert(location === undefined, 'GL.ELEMENT_ARRAY_BUFFER assigned to location');\n\n          elements = buffer;\n        } // else if (!this._warn[bufferName]) {\n        //   log.warn(2, `${this._print(bufferName)} not used`);\n        //   this._warn[bufferName] = true;\n        // }\n\n\n        var location = Number(bufferName); // if key is a number, interpret as the location\n        // if key is not a location number, assume it is a named buffer, look it up in supplied map\n\n        if (!Number.isFinite(location)) {\n          location = this.locations[bufferName];\n        }\n\n        assert(Number.isFinite(location));\n        assert(!locations[location], 'Duplicate attribute for binding point ' + location);\n        locations[location] = buffer;\n      }\n\n      return {\n        locations: locations,\n        elements: elements\n      };\n    }\n  }, {\n    key: '_sortBuffersByLocation',\n    value: function _sortBuffersByLocation(buffers) {\n      // Try to extract elements and locations\n      var elements = null;\n      var locations = new Array(this._attributeCount).fill(null);\n\n      for (var bufferName in buffers) {\n        var buffer = buffers[bufferName]; // Check if this is an elements arrau\n\n        if (buffer.target === GL_ELEMENT_ARRAY_BUFFER) {\n          assert(!elements, 'Duplicate GL.ELEMENT_ARRAY_BUFFER'); // assert(location === undefined, 'GL.ELEMENT_ARRAY_BUFFER assigned to location');\n\n          elements = buffer;\n        } else if (!this._warn[bufferName]) {\n          log.warn(2, this._print(bufferName) + ' not used');\n          this._warn[bufferName] = true;\n        }\n\n        var location = Number(bufferName); // if key is a number, interpret as the location\n        // if key is not a location number, assume it is a named buffer, look it up in supplied map\n\n        if (!Number.isFinite(location)) {\n          location = this.locations[bufferName];\n        }\n\n        locations[location] = bufferName;\n        assert(locations[location] === null, 'Duplicate attribute for binding point ' + location);\n        locations[location] = location;\n      }\n\n      return {\n        locations: locations,\n        elements: elements\n      };\n    }\n  }, {\n    key: '_checkBuffers',\n    value: function _checkBuffers() {\n      for (var attributeName in this._attributeLocations) {\n        if (!this._filledLocations[attributeName] && !this._warn[attributeName]) {\n          var location = this._attributeLocations[attributeName]; // throw new Error(`Program ${this.id}: ` +\n          //   `Attribute ${location}:${attributeName} not supplied`);\n\n          log.warn(0, 'Program ' + this.id + ': Attribute ' + location + ':' + attributeName + ' not supplied');\n          this._warn[attributeName] = true;\n        }\n      }\n\n      return this;\n    } // RESOURCE IMPLEMENTATION\n\n  }, {\n    key: '_createHandle',\n    value: function _createHandle() {\n      return this.ext.createVertexArray();\n    }\n  }, {\n    key: '_deleteHandle',\n    value: function _deleteHandle(handle) {\n      this.ext.deleteVertexArray(handle);\n      return [this.elements]; // return [this.elements, ...this.buffers];\n    } // Generic getter for information about a vertex attribute at a given position\n    // @param {GLuint} location - index of the vertex attribute.\n    // @param {GLenum} pname - specifies the information to query.\n    // @returns {*} - requested vertex attribute information (specified by pname)\n\n  }, {\n    key: '_getParameter',\n    value: function _getParameter(pname, _ref5) {\n      var location = _ref5.location;\n      assert(Number.isFinite(location));\n      this.ext.bindVertexArray(this.handle); // Let the polyfill intercept the query\n\n      var result = void 0;\n\n      switch (pname) {\n        case GL_VERTEX_ATTRIB_ARRAY_POINTER:\n          result = this.gl.getVertexAttribOffset(location, pname);\n          break;\n\n        default:\n          result = this.ext.getVertexAttrib(location, pname);\n      }\n\n      this.ext.bindVertexArray(null);\n      return result;\n    }\n  }, {\n    key: '_getData',\n    value: function _getData() {\n      var _this5 = this;\n\n      return new Array(this.MAX_ATTRIBUTES).fill(0).map(function (_, location) {\n        var result = {};\n        PARAMETERS.forEach(function (parameter) {\n          result[glKey(parameter)] = _this5.getParameter(parameter, {\n            location: location\n          });\n        });\n        return result;\n      });\n    }\n  }, {\n    key: '_bind',\n    value: function _bind(handle) {\n      this.ext.bindVertexArray(handle);\n    }\n  }]);\n\n  return VertexArray;\n}(Resource);\n\nexport default VertexArray;","map":null,"metadata":{},"sourceType":"module"}