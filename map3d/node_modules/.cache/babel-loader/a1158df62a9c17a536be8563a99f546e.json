{"ast":null,"code":"export { _fitBounds as fitBounds };\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // View and Projection Matrix calculations for mapbox-js style map view properties\n\n\nimport Viewport, { createMat4 } from './viewport';\nimport autobind from './autobind';\nimport assert from 'assert';\n/* eslint-disable camelcase */\n\nimport mat4 from 'gl-mat4';\nimport vec2_distance from 'gl-vec2/distance';\nimport vec2_add from 'gl-vec2/add';\nimport vec2_negate from 'gl-vec2/negate'; // CONSTANTS\n\nvar PI = Math.PI;\nvar PI_4 = PI / 4;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nvar TILE_SIZE = 512;\nvar WORLD_SCALE = TILE_SIZE;\nvar DEFAULT_MAP_STATE = {\n  latitude: 37,\n  longitude: -122,\n  zoom: 11,\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\nvar ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';\n\nvar WebMercatorViewport = function (_Viewport) {\n  _inherits(WebMercatorViewport, _Viewport);\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   *\n   * @class\n   * @param {Object} opt - options\n   * @param {Boolean} mercator=true - Whether to use mercator projection\n   *\n   * @param {Number} opt.width=1 - Width of \"viewport\" or window\n   * @param {Number} opt.height=1 - Height of \"viewport\" or window\n   * @param {Array} opt.center=[0, 0] - Center of viewport\n   *   [longitude, latitude] or [x, y]\n   * @param {Number} opt.scale=1 - Either use scale or zoom\n   * @param {Number} opt.pitch=0 - Camera angle in degrees (0 is straight down)\n   * @param {Number} opt.bearing=0 - Map rotation in degrees (0 means north is up)\n   * @param {Number} opt.altitude= - Altitude of camera in screen units\n   *\n   * Web mercator projection short-hand parameters\n   * @param {Number} opt.latitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.longitude - Center of viewport on map (alternative to opt.center)\n   * @param {Number} opt.zoom - Scale = Math.pow(2,zoom) on map (alternative to opt.scale)\n    * Notes:\n   *  - Only one of center or [latitude, longitude] can be specified\n   *  - [latitude, longitude] can only be specified when \"mercator\" is true\n   *  - Altitude has a default value that matches assumptions in mapbox-gl\n   *  - width and height are forced to 1 if supplied as 0, to avoid\n   *    division by zero. This is intended to reduce the burden of apps to\n   *    to check values before instantiating a Viewport.\n   */\n\n  /* eslint-disable complexity */\n\n\n  function WebMercatorViewport() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        width = _ref.width,\n        height = _ref.height,\n        latitude = _ref.latitude,\n        longitude = _ref.longitude,\n        zoom = _ref.zoom,\n        pitch = _ref.pitch,\n        bearing = _ref.bearing,\n        altitude = _ref.altitude,\n        _ref$farZMultiplier = _ref.farZMultiplier,\n        farZMultiplier = _ref$farZMultiplier === undefined ? 10 : _ref$farZMultiplier;\n\n    _classCallCheck(this, WebMercatorViewport); // Viewport - support undefined arguments\n\n\n    width = width !== undefined ? width : DEFAULT_MAP_STATE.width;\n    height = height !== undefined ? height : DEFAULT_MAP_STATE.height;\n    zoom = zoom !== undefined ? zoom : DEFAULT_MAP_STATE.zoom;\n    latitude = latitude !== undefined ? latitude : DEFAULT_MAP_STATE.latitude;\n    longitude = longitude !== undefined ? longitude : DEFAULT_MAP_STATE.longitude;\n    bearing = bearing !== undefined ? bearing : DEFAULT_MAP_STATE.bearing;\n    pitch = pitch !== undefined ? pitch : DEFAULT_MAP_STATE.pitch;\n    altitude = altitude !== undefined ? altitude : DEFAULT_MAP_STATE.altitude; // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n\n    width = width || 1;\n    height = height || 1;\n    var scale = Math.pow(2, zoom); // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n\n    altitude = Math.max(0.75, altitude);\n    var center = projectFlat([longitude, latitude], scale);\n    var distanceScales = calculateDistanceScales({\n      latitude: latitude,\n      longitude: longitude,\n      scale: scale\n    });\n    var projectionMatrix = makeProjectionMatrixFromMercatorParams({\n      width: width,\n      height: height,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude,\n      farZMultiplier: farZMultiplier\n    });\n    var viewMatrix = makeViewMatrixFromMercatorParams({\n      width: width,\n      height: height,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude,\n      distanceScales: distanceScales,\n      center: center\n    }); // Save parameters\n\n    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, {\n      width: width,\n      height: height,\n      viewMatrix: viewMatrix,\n      projectionMatrix: projectionMatrix\n    }));\n\n    _this.latitude = latitude;\n    _this.longitude = longitude;\n    _this.zoom = zoom;\n    _this.pitch = pitch;\n    _this.bearing = bearing;\n    _this.altitude = altitude;\n    _this.scale = scale;\n    _this.center = center;\n    _this._distanceScales = distanceScales;\n    autobind(_this);\n    Object.freeze(_this);\n    return _this;\n  }\n  /* eslint-enable complexity */\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n\n\n  _createClass(WebMercatorViewport, [{\n    key: '_projectFlat',\n    value: function _projectFlat(lngLat) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return projectFlat(lngLat, scale);\n    }\n    /**\n     * Unproject world point [x,y] on map onto {lat, lon} on sphere\n     *\n     * @param {object|Vector} xy - object with {x,y} members\n     *  representing point on projected map plane\n     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n     *   Has toArray method if you need a GeoJSON Array.\n     *   Per cartographic tradition, lat and lon are specified as degrees.\n     */\n\n  }, {\n    key: '_unprojectFlat',\n    value: function _unprojectFlat(xy) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return unprojectFlat(xy, scale);\n    }\n    /**\n     * Get the map center that place a given [lng, lat] coordinate at screen\n     * point [x, y]\n     *\n     * @param {Array} lngLat - [lng,lat] coordinates\n     *   Specifies a point on the sphere.\n     * @param {Array} pos - [x,y] coordinates\n     *   Specifies a point on the screen.\n     * @return {Array} [lng,lat] new map center.\n     */\n\n  }, {\n    key: 'getLocationAtPoint',\n    value: function getLocationAtPoint(_ref2) {\n      var lngLat = _ref2.lngLat,\n          pos = _ref2.pos;\n      var fromLocation = this.projectFlat(this.unproject(pos));\n      var toLocation = this.projectFlat(lngLat);\n      var center = this.projectFlat([this.longitude, this.latitude]);\n      var translate = vec2_add([], toLocation, vec2_negate([], fromLocation));\n      var newCenter = vec2_add([], center, translate);\n      return this.unprojectFlat(newCenter);\n    }\n    /*\n    getLngLatAtViewportPosition(lnglat, xy) {\n      const c = this.locationCoordinate(lnglat);\n      const coordAtPoint = this.pointCoordinate(xy);\n      const coordCenter = this.pointCoordinate(this.centerPoint);\n      const translate = coordAtPoint._sub(c);\n      this.center = this.coordinateLocation(coordCenter._sub(translate));\n    }\n    */\n\n  }, {\n    key: 'getDistanceScales',\n    value: function getDistanceScales() {\n      return this._distanceScales;\n    }\n    /**\n     * Converts a meter offset to a lnglat offset\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas\n     */\n\n  }, {\n    key: 'metersToLngLatDelta',\n    value: function metersToLngLatDelta(xyz) {\n      var _xyz = _slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          _xyz$ = _xyz[2],\n          z = _xyz$ === undefined ? 0 : _xyz$;\n\n      assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);\n      var _distanceScales = this._distanceScales,\n          pixelsPerMeter = _distanceScales.pixelsPerMeter,\n          degreesPerPixel = _distanceScales.degreesPerPixel;\n      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];\n      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];\n      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];\n    }\n    /**\n     * Converts a lnglat offset to a meter offset\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas\n     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas\n     */\n\n  }, {\n    key: 'lngLatDeltaToMeters',\n    value: function lngLatDeltaToMeters(deltaLngLatZ) {\n      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),\n          deltaLng = _deltaLngLatZ[0],\n          deltaLat = _deltaLngLatZ[1],\n          _deltaLngLatZ$ = _deltaLngLatZ[2],\n          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;\n\n      assert(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);\n      var _distanceScales2 = this._distanceScales,\n          pixelsPerDegree = _distanceScales2.pixelsPerDegree,\n          metersPerPixel = _distanceScales2.metersPerPixel;\n      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];\n      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];\n      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];\n    }\n    /**\n     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate\n     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas\n     */\n\n  }, {\n    key: 'addMetersToLngLat',\n    value: function addMetersToLngLat(lngLatZ, xyz) {\n      var _lngLatZ = _slicedToArray(lngLatZ, 3),\n          lng = _lngLatZ[0],\n          lat = _lngLatZ[1],\n          _lngLatZ$ = _lngLatZ[2],\n          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;\n\n      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),\n          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),\n          deltaLng = _metersToLngLatDelta2[0],\n          deltaLat = _metersToLngLatDelta2[1],\n          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],\n          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;\n\n      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];\n    }\n    /**\n     * Returns a new viewport that fit around the given rectangle.\n     * Only supports non-perspective mode.\n     * @param {Array} bounds - [[lon, lat], [lon, lat]]\n     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.\n     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,\n     *    [x, y] measured in pixels.\n     * @returns {WebMercatorViewport}\n     */\n\n  }, {\n    key: 'fitBounds',\n    value: function fitBounds(bounds) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var width = this.width,\n          height = this.height;\n\n      var _fitBounds2 = _fitBounds(Object.assign({\n        width: width,\n        height: height,\n        bounds: bounds\n      }, options)),\n          longitude = _fitBounds2.longitude,\n          latitude = _fitBounds2.latitude,\n          zoom = _fitBounds2.zoom;\n\n      return new WebMercatorViewport({\n        width: width,\n        height: height,\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom\n      });\n    } // INTERNAL METHODS\n\n  }, {\n    key: '_getParams',\n    value: function _getParams() {\n      return this._distanceScales;\n    }\n  }]);\n\n  return WebMercatorViewport;\n}(Viewport);\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param {Array} lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return {Array} [x,y] coordinates.\n */\n\n\nexport default WebMercatorViewport;\n\nfunction projectFlat(_ref3, scale) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      lng = _ref4[0],\n      lat = _ref4[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = lng * DEGREES_TO_RADIANS;\n  var phi2 = lat * DEGREES_TO_RADIANS;\n  var x = scale * (lambda2 + PI) / (2 * PI);\n  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param {object|Vector} xy - object with {x,y} members\n *  representing point on projected map plane\n * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\n\n\nfunction unprojectFlat(_ref5, scale) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n      x = _ref6[0],\n      y = _ref6[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = x / scale * (2 * PI) - PI;\n  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\n\n\nfunction calculateDistanceScales(_ref7) {\n  var latitude = _ref7.latitude,\n      longitude = _ref7.longitude,\n      scale = _ref7.scale;\n  assert(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale), ERR_ARGUMENT); // Approximately 111km per degree at equator\n\n  var METERS_PER_DEGREE = 111000;\n  var latCosine = Math.cos(latitude * Math.PI / 180);\n  var metersPerDegree = METERS_PER_DEGREE * latCosine; // Calculate number of pixels occupied by one degree longitude\n  // around current lat/lon\n\n  var pixelsPerDegreeX = vec2_distance(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale)); // Calculate number of pixels occupied by one degree latitude\n  // around current lat/lon\n\n  var pixelsPerDegreeY = vec2_distance(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));\n  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;\n  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;\n  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2; // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];\n\n  var worldSize = TILE_SIZE * scale;\n  var altPixelsPerMeter = worldSize / (4e7 * latCosine);\n  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];\n  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];\n  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];\n  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ]; // Main results, used for converting meters to latlng deltas and scaling offsets\n\n  return {\n    pixelsPerMeter: pixelsPerMeter,\n    metersPerPixel: metersPerPixel,\n    pixelsPerDegree: pixelsPerDegree,\n    degreesPerPixel: degreesPerPixel\n  };\n} // ATTRIBUTION:\n// view and projection matrix creation is intentionally kept compatible with\n// mapbox-gl's implementation to ensure that seamless interoperation\n// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\n// Variable fov (in radians)\n\n\nexport function getFov(_ref8) {\n  var height = _ref8.height,\n      altitude = _ref8.altitude;\n  return 2 * Math.atan(height / 2 / altitude);\n}\nexport function getClippingPlanes(_ref9) {\n  var altitude = _ref9.altitude,\n      pitch = _ref9.pitch; // Find the distance from the center point to the center top\n  // in altitude units using law of sines.\n\n  var pitchRadians = pitch * DEGREES_TO_RADIANS;\n  var halfFov = Math.atan(0.5 / altitude);\n  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov); // Calculate z value of the farthest fragment that should be rendered.\n\n  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;\n  return {\n    farZ: farZ,\n    nearZ: 0.1\n  };\n} // PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE\n\nexport function makeProjectionMatrixFromMercatorParams(_ref10) {\n  var width = _ref10.width,\n      height = _ref10.height,\n      pitch = _ref10.pitch,\n      altitude = _ref10.altitude,\n      _ref10$farZMultiplier = _ref10.farZMultiplier,\n      farZMultiplier = _ref10$farZMultiplier === undefined ? 10 : _ref10$farZMultiplier;\n\n  var _getClippingPlanes = getClippingPlanes({\n    altitude: altitude,\n    pitch: pitch\n  }),\n      nearZ = _getClippingPlanes.nearZ,\n      farZ = _getClippingPlanes.farZ;\n\n  var fov = getFov({\n    height: height,\n    altitude: altitude\n  });\n  var projectionMatrix = mat4.perspective(createMat4(), fov, // fov in radians\n  width / height, // aspect ratio\n  nearZ, // near plane\n  farZ * farZMultiplier // far plane\n  );\n  return projectionMatrix;\n}\n\nfunction makeViewMatrixFromMercatorParams(_ref11) {\n  var width = _ref11.width,\n      height = _ref11.height,\n      longitude = _ref11.longitude,\n      latitude = _ref11.latitude,\n      zoom = _ref11.zoom,\n      pitch = _ref11.pitch,\n      bearing = _ref11.bearing,\n      altitude = _ref11.altitude,\n      center = _ref11.center; // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE\n  // Note: As usual, matrix operation orders should be read in reverse\n  // since vectors will be multiplied from the right during transformation\n\n  var vm = createMat4(); // Move camera to altitude\n\n  mat4.translate(vm, vm, [0, 0, -altitude]); // After the rotateX, z values are in pixel units. Convert them to\n  // altitude units. 1 altitude unit = the screen height.\n\n  mat4.scale(vm, vm, [1, -1, 1 / height]); // Rotate by bearing, and then by pitch (which tilts the view)\n\n  mat4.rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);\n  mat4.rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS); // console.log(`VIEWPT Z ${pitch * DEGREES_TO_RADIANS} ${-bearing * DEGREES_TO_RADIANS} ${vm}`);\n\n  mat4.translate(vm, vm, [-center[0], -center[1], 0]); // console.log(`VIEWPT T ${pitch * DEGREES_TO_RADIANS} ${-bearing * DEGREES_TO_RADIANS} ${vm}`);\n\n  return vm;\n}\n/**\n * Returns map settings {latitude, longitude, zoom}\n * that will contain the provided corners within the provided width.\n * Only supports non-perspective mode.\n * @param {Number} width - viewport width\n * @param {Number} height - viewport height\n * @param {Array} bounds - [[lon, lat], [lon, lat]]\n * @param {Number} [padding] - The amount of padding in pixels to add to the given bounds.\n * @param {Array} [offset] - The center of the given bounds relative to the map's center,\n *    [x, y] measured in pixels.\n * @returns {Object} - latitude, longitude and zoom\n */\n\n\nfunction _fitBounds(_ref12) {\n  var width = _ref12.width,\n      height = _ref12.height,\n      bounds = _ref12.bounds,\n      _ref12$padding = _ref12.padding,\n      padding = _ref12$padding === undefined ? 0 : _ref12$padding,\n      _ref12$offset = _ref12.offset,\n      offset = _ref12$offset === undefined ? [0, 0] : _ref12$offset;\n\n  var _bounds = _slicedToArray(bounds, 2),\n      _bounds$ = _slicedToArray(_bounds[0], 2),\n      west = _bounds$[0],\n      south = _bounds$[1],\n      _bounds$2 = _slicedToArray(_bounds[1], 2),\n      east = _bounds$2[0],\n      north = _bounds$2[1];\n\n  var viewport = new WebMercatorViewport({\n    width: width,\n    height: height,\n    longitude: 0,\n    latitude: 0,\n    zoom: 0\n  });\n  var nw = viewport.project([west, north]);\n  var se = viewport.project([east, south]);\n  var size = [Math.abs(se[0] - nw[0]), Math.abs(se[1] - nw[1])];\n  var center = [(se[0] + nw[0]) / 2, (se[1] + nw[1]) / 2];\n  var scaleX = (width - padding * 2 - Math.abs(offset[0]) * 2) / size[0];\n  var scaleY = (height - padding * 2 - Math.abs(offset[1]) * 2) / size[1];\n  var centerLngLat = viewport.unproject(center);\n  var zoom = viewport.zoom + Math.log2(Math.abs(Math.min(scaleX, scaleY)));\n  return {\n    longitude: centerLngLat[0],\n    latitude: centerLngLat[1],\n    zoom: zoom\n  };\n}","map":null,"metadata":{},"sourceType":"module"}