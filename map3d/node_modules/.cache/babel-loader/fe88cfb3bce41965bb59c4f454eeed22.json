{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\n\n\nimport * as Polygon from './polygon';\nimport earcut from 'earcut';\nimport { experimental } from '../../core';\nvar fp64ify = experimental.fp64ify,\n    flattenVertices = experimental.flattenVertices,\n    fillArray = experimental.fillArray; // Maybe deck.gl or luma.gl needs to export this\n\nfunction getPickingColor(index) {\n  return [(index + 1) % 256, Math.floor((index + 1) / 256) % 256, Math.floor((index + 1) / 256 / 256) % 256];\n}\n\nvar DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\n\nexport var PolygonTesselator = function () {\n  function PolygonTesselator(_ref) {\n    var polygons = _ref.polygons,\n        _ref$fp = _ref.fp64,\n        fp64 = _ref$fp === undefined ? false : _ref$fp;\n\n    _classCallCheck(this, PolygonTesselator); // Normalize all polygons\n\n\n    this.polygons = polygons.map(function (polygon) {\n      return Polygon.normalize(polygon);\n    }); // Count all polygon vertices\n\n    this.pointCount = getPointCount(this.polygons);\n    this.fp64 = fp64;\n  }\n\n  _createClass(PolygonTesselator, [{\n    key: 'indices',\n    value: function indices() {\n      var polygons = this.polygons,\n          indexCount = this.indexCount;\n      return calculateIndices({\n        polygons: polygons,\n        indexCount: indexCount\n      });\n    }\n  }, {\n    key: 'positions',\n    value: function positions() {\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n      return calculatePositions({\n        polygons: polygons,\n        pointCount: pointCount,\n        fp64: this.fp64\n      });\n    }\n  }, {\n    key: 'normals',\n    value: function normals() {\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n      return calculateNormals({\n        polygons: polygons,\n        pointCount: pointCount\n      });\n    }\n  }, {\n    key: 'colors',\n    value: function colors() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$getColor = _ref2.getColor,\n          getColor = _ref2$getColor === undefined ? function (x) {\n        return DEFAULT_COLOR;\n      } : _ref2$getColor;\n\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n      return calculateColors({\n        polygons: polygons,\n        pointCount: pointCount,\n        getColor: getColor\n      });\n    }\n  }, {\n    key: 'pickingColors',\n    value: function pickingColors() {\n      var polygons = this.polygons,\n          pointCount = this.pointCount;\n      return calculatePickingColors({\n        polygons: polygons,\n        pointCount: pointCount\n      });\n    } // getAttribute({size, accessor}) {\n    //   const {polygons, pointCount} = this;\n    //   return calculateAttribute({polygons, pointCount, size, accessor});\n    // }\n\n  }]);\n\n  return PolygonTesselator;\n}(); // Count number of points in a list of complex polygons\n\nfunction getPointCount(polygons) {\n  return polygons.reduce(function (points, polygon) {\n    return points + Polygon.getVertexCount(polygon);\n  }, 0);\n} // COunt number of triangles in a list of complex polygons\n\n\nfunction getTriangleCount(polygons) {\n  return polygons.reduce(function (triangles, polygon) {\n    return triangles + Polygon.getTriangleCount(polygon);\n  }, 0);\n} // Returns the offsets of each complex polygon in the combined array of all polygons\n\n\nfunction getPolygonOffsets(polygons) {\n  var offsets = new Array(polygons.length + 1);\n  offsets[0] = 0;\n  var offset = 0;\n  polygons.forEach(function (polygon, i) {\n    offset += Polygon.getVertexCount(polygon);\n    offsets[i + 1] = offset;\n  });\n  return offsets;\n} // Returns the offset of each hole polygon in the flattened array for that polygon\n\n\nfunction getHoleIndices(complexPolygon) {\n  var holeIndices = null;\n\n  if (complexPolygon.length > 1) {\n    var polygonStartIndex = 0;\n    holeIndices = [];\n    complexPolygon.forEach(function (polygon) {\n      polygonStartIndex += polygon.length;\n      holeIndices.push(polygonStartIndex);\n    }); // Last element points to end of the flat array, remove it\n\n    holeIndices.pop();\n  }\n\n  return holeIndices;\n}\n\nfunction calculateIndices(_ref3) {\n  var polygons = _ref3.polygons,\n      _ref3$IndexType = _ref3.IndexType,\n      IndexType = _ref3$IndexType === undefined ? Uint32Array : _ref3$IndexType; // Calculate length of index array (3 * number of triangles)\n\n  var indexCount = 3 * getTriangleCount(polygons);\n  var offsets = getPolygonOffsets(polygons); // Allocate the attribute\n  // TODO it's not the index count but the vertex count that must be checked\n\n  if (IndexType === Uint16Array && indexCount > 65535) {\n    throw new Error(\"Vertex count exceeds browser's limit\");\n  }\n\n  var attribute = new IndexType(indexCount); // 1. get triangulated indices for the internal areas\n  // 2. offset them by the number of indices in previous polygons\n\n  var i = 0;\n  polygons.forEach(function (polygon, polygonIndex) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = calculateSurfaceIndices(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var index = _step.value;\n        attribute[i++] = index + offsets[polygonIndex];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return attribute;\n}\n/*\n * Get vertex indices for drawing complexPolygon mesh\n * @private\n * @param {[Number,Number,Number][][]} complexPolygon\n * @returns {[Number]} indices\n */\n\n\nfunction calculateSurfaceIndices(complexPolygon) {\n  // Prepare an array of hole indices as expected by earcut\n  var holeIndices = getHoleIndices(complexPolygon); // Flatten the polygon as expected by earcut\n\n  var verts = flattenVertices(complexPolygon); // Let earcut triangulate the polygon\n\n  return earcut(verts, holeIndices, 3);\n}\n\nfunction calculatePositions(_ref4) {\n  var polygons = _ref4.polygons,\n      pointCount = _ref4.pointCount,\n      fp64 = _ref4.fp64; // Flatten out all the vertices of all the sub subPolygons\n\n  var attribute = new Float32Array(pointCount * 3);\n  var attributeLow = void 0;\n\n  if (fp64) {\n    // We only need x, y component\n    attributeLow = new Float32Array(pointCount * 2);\n  }\n\n  var i = 0;\n  var j = 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = polygons[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var polygon = _step2.value; // eslint-disable-next-line\n\n      Polygon.forEachVertex(polygon, function (vertex) {\n        var x = vertex[0];\n        var y = vertex[1];\n        var z = vertex[2] || 0;\n        attribute[i++] = x;\n        attribute[i++] = y;\n        attribute[i++] = z;\n\n        if (fp64) {\n          attributeLow[j++] = fp64ify(x)[1];\n          attributeLow[j++] = fp64ify(y)[1];\n        }\n      });\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return {\n    positions: attribute,\n    positions64xyLow: attributeLow\n  };\n}\n\nfunction calculateNormals(_ref5) {\n  var polygons = _ref5.polygons,\n      pointCount = _ref5.pointCount; // TODO - use generic vertex attribute?\n\n  var attribute = new Float32Array(pointCount * 3); // normals is not used in flat polygon shader\n  // fillArray({target: attribute, source: [0, 0, 1], start: 0, count: pointCount});\n\n  return attribute;\n}\n\nfunction calculateColors(_ref6) {\n  var polygons = _ref6.polygons,\n      pointCount = _ref6.pointCount,\n      getColor = _ref6.getColor;\n  var attribute = new Uint8ClampedArray(pointCount * 4);\n  var i = 0;\n  polygons.forEach(function (complexPolygon, polygonIndex) {\n    // Calculate polygon color\n    var color = getColor(polygonIndex);\n    color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n    var vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({\n      target: attribute,\n      source: color,\n      start: i,\n      count: vertexCount\n    });\n    i += color.length * vertexCount;\n  });\n  return attribute;\n}\n\nfunction calculatePickingColors(_ref7) {\n  var polygons = _ref7.polygons,\n      pointCount = _ref7.pointCount;\n  var attribute = new Uint8ClampedArray(pointCount * 3);\n  var i = 0;\n  polygons.forEach(function (complexPolygon, polygonIndex) {\n    var color = getPickingColor(polygonIndex);\n    var vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({\n      target: attribute,\n      source: color,\n      start: i,\n      count: vertexCount\n    });\n    i += color.length * vertexCount;\n  });\n  return attribute;\n}","map":null,"metadata":{},"sourceType":"module"}