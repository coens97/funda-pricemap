{"ast":null,"code":"function _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { createGLContext, resizeGLContext, resetParameters } from '../webgl-context';\nimport { pageLoadPromise } from '../webgl-context';\nimport { makeDebugContext } from '../webgl-context/debug-context';\nimport { isWebGL, requestAnimationFrame, cancelAnimationFrame } from '../webgl-utils';\nimport { log } from '../utils';\nimport assert from '../utils/assert'; // TODO - remove dependency on webgl classes\n\nimport { Framebuffer } from '../webgl';\nvar DEFAULT_GL_OPTIONS = {\n  preserveDrawingBuffer: true\n};\n\nvar AnimationLoop =\n/*#__PURE__*/\nfunction () {\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  function AnimationLoop() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, AnimationLoop);\n\n    var _props$onCreateContex = props.onCreateContext,\n        onCreateContext = _props$onCreateContex === void 0 ? function (opts) {\n      return createGLContext(opts);\n    } : _props$onCreateContex,\n        _props$onInitialize = props.onInitialize,\n        onInitialize = _props$onInitialize === void 0 ? function () {} : _props$onInitialize,\n        _props$onRender = props.onRender,\n        onRender = _props$onRender === void 0 ? function () {} : _props$onRender,\n        _props$onFinalize = props.onFinalize,\n        onFinalize = _props$onFinalize === void 0 ? function () {} : _props$onFinalize,\n        _props$offScreen = props.offScreen,\n        offScreen = _props$offScreen === void 0 ? false : _props$offScreen,\n        _props$gl = props.gl,\n        gl = _props$gl === void 0 ? null : _props$gl,\n        _props$glOptions = props.glOptions,\n        glOptions = _props$glOptions === void 0 ? {} : _props$glOptions,\n        _props$debug = props.debug,\n        debug = _props$debug === void 0 ? false : _props$debug,\n        _props$createFramebuf = props.createFramebuffer,\n        createFramebuffer = _props$createFramebuf === void 0 ? false : _props$createFramebuf,\n        _props$autoResizeView = props.autoResizeViewport,\n        autoResizeViewport = _props$autoResizeView === void 0 ? true : _props$autoResizeView,\n        _props$autoResizeDraw = props.autoResizeDrawingBuffer,\n        autoResizeDrawingBuffer = _props$autoResizeDraw === void 0 ? true : _props$autoResizeDraw;\n    var _props$useDevicePixel = props.useDevicePixels,\n        useDevicePixels = _props$useDevicePixel === void 0 ? true : _props$useDevicePixel;\n\n    if ('useDevicePixelRatio' in props) {\n      log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n      useDevicePixels = props.useDevicePixelRatio;\n    }\n\n    this.props = {\n      onCreateContext: onCreateContext,\n      onInitialize: onInitialize,\n      onRender: onRender,\n      onFinalize: onFinalize,\n      gl: gl,\n      glOptions: glOptions,\n      debug: debug,\n      createFramebuffer: createFramebuffer\n    }; // state\n\n    this.gl = gl;\n    this.offScreen = offScreen;\n    this.needsRedraw = null;\n    this.setProps({\n      autoResizeViewport: autoResizeViewport,\n      autoResizeDrawingBuffer: autoResizeDrawingBuffer,\n      useDevicePixels: useDevicePixels\n    }); // Bind methods\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._renderFrame = this._renderFrame.bind(this);\n    return this;\n  }\n\n  _createClass(AnimationLoop, [{\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      assert(typeof reason === 'string');\n      this.needsRedraw = this.needsRedraw || reason;\n      return this;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('autoResizeViewport' in props) {\n        this.autoResizeViewport = props.autoResizeViewport;\n      }\n\n      if ('autoResizeDrawingBuffer' in props) {\n        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;\n      }\n\n      if ('useDevicePixels' in props) {\n        this.useDevicePixels = props.useDevicePixels;\n      }\n\n      return this;\n    } // Starts a render loop if not already running\n    // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._stopped = false; // console.debug(`Starting ${this.constructor.name}`);\n\n      if (!this._animationFrameId) {\n        // Wait for start promise before rendering frame\n        this._startPromise = pageLoadPromise.then(function () {\n          if (_this._stopped) {\n            return null;\n          } // Create the WebGL context\n\n\n          _this._createWebGLContext(opts);\n\n          _this._createFramebuffer(); // Initialize the callback data\n\n\n          _this._initializeCallbackData();\n\n          _this._updateCallbackData(); // Default viewport setup, in case onInitialize wants to render\n\n\n          _this._resizeCanvasDrawingBuffer();\n\n          _this._resizeViewport(); // Note: onIntialize can return a promise (in case it needs to load resources)\n\n\n          return _this.props.onInitialize(_this._callbackData);\n        }).then(function (appContext) {\n          if (!_this._stopped) {\n            _this._addCallbackData(appContext || {});\n\n            if (appContext !== false && !_this._animationFrameId) {\n              _this._animationFrameId = requestAnimationFrame(_this._renderFrame);\n            }\n          }\n        });\n      }\n\n      return this;\n    } // Stops a render loop if already running, finalizing\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // console.debug(`Stopping ${this.constructor.name}`);\n      if (this._animationFrameId) {\n        this._finalizeCallbackData();\n\n        cancelAnimationFrame(this._animationFrameId);\n        this._animationFrameId = null;\n        this._stopped = true;\n      }\n\n      return this;\n    } // DEPRECATED METHODS\n    // Update parameters\n\n  }, {\n    key: \"setViewParameters\",\n    value: function setViewParameters(_ref) {\n      var _ref$autoResizeDrawin = _ref.autoResizeDrawingBuffer,\n          autoResizeDrawingBuffer = _ref$autoResizeDrawin === void 0 ? true : _ref$autoResizeDrawin,\n          _ref$autoResizeCanvas = _ref.autoResizeCanvas,\n          autoResizeCanvas = _ref$autoResizeCanvas === void 0 ? true : _ref$autoResizeCanvas,\n          _ref$autoResizeViewpo = _ref.autoResizeViewport,\n          autoResizeViewport = _ref$autoResizeViewpo === void 0 ? true : _ref$autoResizeViewpo,\n          _ref$useDevicePixels = _ref.useDevicePixels,\n          useDevicePixels = _ref$useDevicePixels === void 0 ? true : _ref$useDevicePixels,\n          _ref$useDevicePixelRa = _ref.useDevicePixelRatio,\n          useDevicePixelRatio = _ref$useDevicePixelRa === void 0 ? null : _ref$useDevicePixelRa;\n      log.deprecated('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();\n      this.autoResizeViewport = autoResizeViewport;\n      this.autoResizeCanvas = autoResizeCanvas;\n      this.autoResizeDrawingBuffer = autoResizeDrawingBuffer;\n      this.useDevicePixels = useDevicePixels;\n\n      if (useDevicePixelRatio !== null) {\n        log.deprecated('useDevicePixelRatio', 'useDevicePixels')();\n        this.useDevicePixels = useDevicePixelRatio;\n      }\n\n      return this;\n    } // PRIVATE METHODS\n\n  }, {\n    key: \"_setupFrame\",\n    value: function _setupFrame() {\n      if (this._onSetupFrame) {\n        // call callback\n        this._onSetupFrame(this._callbackData); // end callback\n\n      } else {\n        this._resizeCanvasDrawingBuffer();\n\n        this._resizeViewport();\n\n        this._resizeFramebuffer();\n      }\n    }\n    /**\n     * @private\n     * Handles a render loop frame - updates context and calls the application\n     * callback\n     */\n\n  }, {\n    key: \"_renderFrame\",\n    value: function _renderFrame() {\n      if (this._stopped) {\n        return;\n      }\n\n      this._setupFrame();\n\n      this._updateCallbackData(); // call callback\n\n\n      this.props.onRender(this._callbackData); // end callback\n\n      if (this.offScreen) {\n        // commit returns a Promise\n        this.gl.commit().then(this._renderFrame);\n      } else {\n        // Request another render frame (now )\n        this._animationFrameId = requestAnimationFrame(this._renderFrame);\n      }\n    } // Initialize the  object that will be passed to app callbacks\n\n  }, {\n    key: \"_initializeCallbackData\",\n    value: function _initializeCallbackData() {\n      this._callbackData = {\n        gl: this.gl,\n        canvas: this.gl.canvas,\n        framebuffer: this.framebuffer,\n        stop: this.stop,\n        // Initial values\n        useDevicePixels: this.useDevicePixels,\n        needsRedraw: null,\n        tick: 0,\n        tock: 0\n      };\n    } // Update the context object that will be passed to app callbacks\n\n  }, {\n    key: \"_updateCallbackData\",\n    value: function _updateCallbackData() {\n      // CallbackData width and height represent drawing buffer width and height\n      var width = this.gl.drawingBufferWidth;\n      var height = this.gl.drawingBufferHeight;\n\n      if (width !== this._callbackData.width || height !== this._callbackData.height) {\n        this.setNeedsRedraw('drawing buffer resized');\n      }\n\n      this._callbackData.width = width;\n      this._callbackData.height = height;\n      this._callbackData.aspect = width / height;\n      this._callbackData.needsRedraw = this.needsRedraw;\n      this._callbackData.offScreen = this.offScreen; // Update redraw reason\n\n      this._callbackData.needsRedraw = this.needsRedraw;\n      this.needsRedraw = null; // Increment tick\n\n      this._callbackData.tick++;\n    }\n  }, {\n    key: \"_finalizeCallbackData\",\n    value: function _finalizeCallbackData() {\n      // call callback\n      this.props.onFinalize(this._callbackData); // end callback\n    } // Add application's data to the app context object\n\n  }, {\n    key: \"_addCallbackData\",\n    value: function _addCallbackData(appContext) {\n      if (_typeof(appContext) === 'object' && appContext !== null) {\n        this._callbackData = Object.assign({}, this._callbackData, appContext);\n      }\n    } // Either uses supplied or existing context, or calls provided callback to create one\n\n  }, {\n    key: \"_createWebGLContext\",\n    value: function _createWebGLContext(opts) {\n      // Create the WebGL context if necessary\n      opts = Object.assign({}, opts, DEFAULT_GL_OPTIONS, this.props.glOptions);\n      this.gl = this.props.gl || this.props.onCreateContext(opts);\n\n      if (!isWebGL(this.gl)) {\n        throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n      }\n\n      if (this.props.debug) {\n        this.gl = makeDebugContext(this.gl);\n      } // Reset the WebGL context.\n\n\n      resetParameters(this.gl);\n    } // Default viewport setup\n\n  }, {\n    key: \"_resizeViewport\",\n    value: function _resizeViewport() {\n      if (this.autoResizeViewport) {\n        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);\n      }\n    } // Resize the render buffer of the canvas to match canvas client size\n    // Optionally multiplying with devicePixel ratio\n\n  }, {\n    key: \"_resizeCanvasDrawingBuffer\",\n    value: function _resizeCanvasDrawingBuffer() {\n      if (this.autoResizeDrawingBuffer) {\n        resizeGLContext(this.gl, {\n          useDevicePixels: this.useDevicePixels\n        });\n      }\n    } // TBD - deprecated?\n\n  }, {\n    key: \"_createFramebuffer\",\n    value: function _createFramebuffer() {\n      // Setup default framebuffer\n      if (this.props.createFramebuffer) {\n        this.framebuffer = new Framebuffer(this.gl);\n      }\n    }\n  }, {\n    key: \"_resizeFramebuffer\",\n    value: function _resizeFramebuffer() {\n      if (this.framebuffer) {\n        this.framebuffer.resize({\n          width: this.gl.drawingBufferWidth,\n          height: this.gl.drawingBufferHeight\n        });\n      }\n    }\n  }]);\n\n  return AnimationLoop;\n}();\n\nexport { AnimationLoop as default };","map":null,"metadata":{},"sourceType":"module"}