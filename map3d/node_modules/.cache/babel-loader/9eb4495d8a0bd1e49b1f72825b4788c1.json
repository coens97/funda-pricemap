{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _SHADER_TYPE;\n\nimport { VERTEX_SHADER, FRAGMENT_SHADER } from './constants';\nimport { resolveModules, getShaderModule } from './resolve-modules';\nimport { getPlatformShaderDefines, getVersionDefines } from './platform-defines';\nimport injectShader from './inject-shader';\nimport assert from '../utils/assert';\nvar SHADER_TYPE = (_SHADER_TYPE = {}, _defineProperty(_SHADER_TYPE, VERTEX_SHADER, 'vertex'), _defineProperty(_SHADER_TYPE, FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE); // Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\n\nvar FRAGMENT_SHADER_PROLOGUE = \"precision highp float;\\n\\n\"; // Inject a list of modules\n\nexport function assembleShaders(gl) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var vs = opts.vs,\n      fs = opts.fs;\n  var modules = resolveModules(opts.modules || []);\n  return {\n    gl: gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {\n      source: vs,\n      type: VERTEX_SHADER,\n      modules: modules\n    })),\n    fs: assembleShader(gl, Object.assign({}, opts, {\n      source: fs,\n      type: FRAGMENT_SHADER,\n      modules: modules\n    })),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n} // Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\n\nfunction assembleShader(gl, _ref) {\n  var id = _ref.id,\n      source = _ref.source,\n      type = _ref.type,\n      _ref$modules = _ref.modules,\n      modules = _ref$modules === void 0 ? [] : _ref$modules,\n      _ref$defines = _ref.defines,\n      defines = _ref$defines === void 0 ? {} : _ref$defines,\n      _ref$inject = _ref.inject,\n      inject = _ref$inject === void 0 ? {} : _ref$inject,\n      _ref$prologue = _ref.prologue,\n      prologue = _ref$prologue === void 0 ? true : _ref$prologue,\n      log = _ref.log;\n  assert(typeof source === 'string', 'shader source must be a string');\n  var isVertex = type === VERTEX_SHADER;\n  var sourceLines = source.split('\\n');\n  var glslVersion = 100;\n  var versionLine = '';\n  var coreSource = source; // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    glslVersion = 300; // TODO - regexp that matches atual version number\n\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n\n\n  var assembledSource = prologue ? \"\".concat(versionLine, \"\\n\").concat(getShaderName({\n    id: id,\n    source: source,\n    type: type\n  }), \"\\n\").concat(getPlatformShaderDefines(gl), \"\\n\").concat(getVersionDefines(gl, glslVersion, !isVertex), \"\\n\").concat(getApplicationDefines(defines), \"\\n\").concat(isVertex ? '' : FRAGMENT_SHADER_PROLOGUE, \"\\n\") : \"\".concat(versionLine, \"\\n\"); // Add source of dependent modules in resolved order\n\n  var injectStandardStubs = false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var module = _step.value;\n\n      switch (module.name) {\n        case 'inject':\n          injectStandardStubs = true;\n          break;\n\n        default:\n          module.checkDeprecations(coreSource, log);\n          var moduleSource = module.getModuleSource(type, glslVersion); // Add the module source, and a #define that declares it presence\n\n          assembledSource += moduleSource;\n      }\n    } // Add the version directive and actual source of this shader\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  assembledSource += coreSource; // Apply any requested shader injections\n\n  assembledSource = injectShader(assembledSource, type, inject, injectStandardStubs);\n  return assembledSource;\n} // Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\n\n\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    var uniforms = {};\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var module = _step2.value; // `modules` is already sorted by dependency level. This guarantees that\n        // modules have access to the uniforms that are generated by their dependencies.\n\n        var moduleUniforms = module.getUniforms(opts, uniforms);\n        Object.assign(uniforms, moduleUniforms);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return uniforms;\n  };\n} // Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\n\n\nfunction assembleModuleMap(modules) {\n  var result = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var moduleName = _step3.value;\n      var shaderModule = getShaderModule(moduleName);\n      result[moduleName] = shaderModule;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return result;\n} // Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\n\n\nfunction getShaderName(_ref2) {\n  var id = _ref2.id,\n      source = _ref2.source,\n      type = _ref2.type;\n  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? \"\\n#define SHADER_NAME \".concat(id, \"_\").concat(SHADER_TYPE[type], \"\\n\\n\") : '';\n} // Generates application defines from an object\n\n\nfunction getApplicationDefines() {\n  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var count = 0;\n  var sourceText = '';\n\n  for (var define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n\n    count++;\n    var value = defines[define];\n\n    if (value || Number.isFinite(value)) {\n      sourceText += \"#define \".concat(define.toUpperCase(), \" \").concat(defines[define], \"\\n\");\n    }\n  }\n\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n\n  return sourceText;\n}","map":null,"metadata":{},"sourceType":"module"}