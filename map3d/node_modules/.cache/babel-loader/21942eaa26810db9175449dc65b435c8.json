{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* eslint quotes: [\"error\", \"single\", { \"allowTemplateLiterals\": true }]*/\n// A scenegraph object node\n\n\nimport GL from '../constants';\nimport { Attribute, Buffer, Program, checkUniformValues } from '../webgl';\nimport Query from '../webgl/query';\nimport { isWebGL } from '../webgl-utils';\nimport { getUniformsTable, areUniformsEqual } from '../webgl/uniforms';\nimport { getDrawMode } from '../geometry/geometry';\nimport Object3D from '../core/object-3d';\nimport { MODULAR_SHADERS } from '../shadertools/shaders';\nimport { assembleShaders } from '../shadertools';\nimport { addModel, removeModel, logModel, getOverrides } from '../debug/seer-integration';\nimport { log, formatValue, isObjectEmpty } from '../utils';\nimport assert from '../utils/assert';\nvar MSG_INSTANCED_PARAM_DEPRECATED = \"Warning: Model constructor: parameter \\\"instanced\\\" renamed to \\\"isInstanced\\\".\\nThis will become a hard error in a future version of luma.gl.\";\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\nvar LOG_DRAW_PRIORITY = 2; // These old picking uniforms should be avoided and we should use picking module\n// and set uniforms using Model class 'updateModuleSettings()'\n\nvar DEPRECATED_PICKING_UNIFORMS = ['renderPickingBuffer', 'pickingEnabled']; // Model abstract O3D Class\n\nvar Model =\n/*#__PURE__*/\nfunction (_Object3D) {\n  _inherits(Model, _Object3D);\n\n  function Model(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Model);\n\n    _this = _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).call(this, opts));\n    assert(isWebGL(gl));\n    _this.gl = gl;\n\n    _this.init(opts);\n\n    return _this;\n  }\n  /* eslint-disable max-statements  */\n\n  /* eslint-disable complexity  */\n\n\n  _createClass(Model, [{\n    key: \"init\",\n    value: function init() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$vs = _ref.vs,\n          vs = _ref$vs === void 0 ? null : _ref$vs,\n          _ref$fs = _ref.fs,\n          fs = _ref$fs === void 0 ? null : _ref$fs,\n          _ref$modules = _ref.modules,\n          modules = _ref$modules === void 0 ? null : _ref$modules,\n          _ref$defines = _ref.defines,\n          defines = _ref$defines === void 0 ? {} : _ref$defines,\n          _ref$moduleSettings = _ref.moduleSettings,\n          moduleSettings = _ref$moduleSettings === void 0 ? {} : _ref$moduleSettings,\n          defaultUniforms = _ref.defaultUniforms,\n          _ref$program = _ref.program,\n          program = _ref$program === void 0 ? null : _ref$program,\n          _ref$shaderCache = _ref.shaderCache,\n          shaderCache = _ref$shaderCache === void 0 ? null : _ref$shaderCache,\n          _ref$isInstanced = _ref.isInstanced,\n          isInstanced = _ref$isInstanced === void 0 ? false : _ref$isInstanced,\n          instanced = _ref.instanced,\n          _ref$vertexCount = _ref.vertexCount,\n          vertexCount = _ref$vertexCount === void 0 ? undefined : _ref$vertexCount,\n          _ref$instanceCount = _ref.instanceCount,\n          instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount,\n          drawMode = _ref.drawMode,\n          _ref$uniforms = _ref.uniforms,\n          uniforms = _ref$uniforms === void 0 ? {} : _ref$uniforms,\n          _ref$attributes = _ref.attributes,\n          attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n          _ref$geometry = _ref.geometry,\n          geometry = _ref$geometry === void 0 ? null : _ref$geometry,\n          _ref$pickable = _ref.pickable,\n          pickable = _ref$pickable === void 0 ? true : _ref$pickable,\n          _ref$pick = _ref.pick,\n          pick = _ref$pick === void 0 ? null : _ref$pick,\n          _ref$render = _ref.render,\n          render = _ref$render === void 0 ? null : _ref$render,\n          _ref$onBeforeRender = _ref.onBeforeRender,\n          onBeforeRender = _ref$onBeforeRender === void 0 ? function () {} : _ref$onBeforeRender,\n          _ref$onAfterRender = _ref.onAfterRender,\n          onAfterRender = _ref$onAfterRender === void 0 ? function () {} : _ref$onAfterRender,\n          _ref$varyings = _ref.varyings,\n          varyings = _ref$varyings === void 0 ? null : _ref$varyings,\n          _ref$bufferMode = _ref.bufferMode,\n          bufferMode = _ref$bufferMode === void 0 ? GL.SEPARATE_ATTRIBS : _ref$bufferMode,\n          _ref$timerQueryEnable = _ref.timerQueryEnabled,\n          timerQueryEnabled = _ref$timerQueryEnable === void 0 ? false : _ref$timerQueryEnable;\n\n      this._initializeProgram({\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        moduleSettings: moduleSettings,\n        defaultUniforms: defaultUniforms,\n        program: program,\n        shaderCache: shaderCache,\n        varyings: varyings,\n        bufferMode: bufferMode\n      });\n\n      this.uniforms = {}; // Make sure we have some reasonable default uniforms in place\n\n      uniforms = Object.assign({}, this.program.defaultUniforms, uniforms);\n      this.setUniforms(uniforms); // Get all default uniforms\n\n      this.setUniforms(this.getModuleUniforms()); // Get unforms for supplied parameters\n\n      this.setUniforms(this.getModuleUniforms(moduleSettings));\n\n      if (instanced) {\n        /* global console */\n\n        /* eslint-disable no-console */\n        console.warn(MSG_INSTANCED_PARAM_DEPRECATED);\n        isInstanced = isInstanced || instanced;\n      } // All attributes\n\n\n      this._attributes = {}; // User defined attributes\n\n      this.attributes = {};\n      this.samplers = {};\n      this.userData = {};\n      this.drawParams = {};\n      this.dynamic = false;\n      this.needsRedraw = true; // Attributes and buffers\n\n      if (geometry) {\n        this.setGeometry(geometry);\n      }\n\n      this.setAttributes(attributes); // geometry might have set drawMode and vertexCount\n\n      if (drawMode !== undefined) {\n        this.drawMode = getDrawMode(drawMode);\n      }\n\n      if (vertexCount !== undefined) {\n        this.vertexCount = vertexCount;\n      }\n\n      this.isInstanced = isInstanced;\n      this.instanceCount = instanceCount; // picking options\n\n      this.pickable = Boolean(pickable);\n\n      this.pick = pick || function () {\n        return false;\n      };\n\n      this.onBeforeRender = onBeforeRender;\n      this.onAfterRender = onAfterRender; // assert(program || program instanceof Program);\n\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n      this.timerQueryEnabled = timerQueryEnabled && Query.isSupported(this.gl, {\n        timer: true\n      });\n      this.timeElapsedQuery = undefined;\n      this.lastQueryReturned = true;\n      this.stats = {\n        accumulatedFrameTime: 0,\n        averageFrameTime: 0,\n        profileFrameCount: 0\n      };\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      // delete all attributes created by this model\n      for (var key in this._attributes) {\n        if (this._attributes[key] !== this.attributes[key]) {\n          this._attributes[key].delete();\n        }\n      }\n\n      this.program.delete();\n      removeModel(this.id);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.delete();\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = redraw;\n      return this;\n    }\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,\n          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? false : _ref2$clearRedrawFlag;\n\n      var redraw = false;\n      redraw = redraw || this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n\n      if (this.geometry) {\n        redraw = redraw || this.geometry.getNeedsRedraw({\n          clearRedrawFlags: clearRedrawFlags\n        });\n      }\n\n      return redraw;\n    }\n  }, {\n    key: \"setDrawMode\",\n    value: function setDrawMode(drawMode) {\n      this.drawMode = getDrawMode(drawMode);\n      return this;\n    }\n  }, {\n    key: \"getDrawMode\",\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: \"setVertexCount\",\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: \"setInstanceCount\",\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: \"getProgram\",\n    value: function getProgram() {\n      return this.program;\n    }\n  }, {\n    key: \"setGeometry\",\n    // TODO - just set attributes, don't hold on to geometry\n    value: function setGeometry(geometry) {\n      this.geometry = geometry;\n      this.vertexCount = geometry.getVertexCount();\n      this.drawMode = geometry.drawMode;\n\n      this._createBuffersFromAttributeDescriptors(this.geometry.getAttributes());\n\n      this.setNeedsRedraw();\n      return this;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Reutrn early if no attributes to set.\n\n      if (isObjectEmpty(attributes)) {\n        return this;\n      }\n\n      Object.assign(this.attributes, attributes);\n\n      this._createBuffersFromAttributeDescriptors(attributes);\n\n      this.setNeedsRedraw();\n      return this;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      return this.uniforms;\n    } // TODO - should actually set the uniforms\n\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // TODO: we are still setting these uniforms in deck.gl so we don't break any external\n      // application, these are marked deprecated in 5.0, remove them in deck.gl in 6.0.\n      // Disabling since it gets too noisy in console, these are documented as deprecated.\n      // this._checkForDeprecatedUniforms(uniforms);\n\n      var somethingChanged = false;\n\n      for (var key in uniforms) {\n        if (!areUniformsEqual(this.uniforms[key], uniforms[key])) {\n          somethingChanged = true;\n          break;\n        }\n      }\n\n      if (somethingChanged) {\n        checkUniformValues(uniforms, this.id);\n        Object.assign(this.uniforms, uniforms);\n        this.setNeedsRedraw();\n      }\n\n      return this;\n    } // getModuleUniforms (already on object)\n\n  }, {\n    key: \"updateModuleSettings\",\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts);\n      return this.setUniforms(uniforms);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$moduleSettings = _ref3.moduleSettings,\n          moduleSettings = _ref3$moduleSettings === void 0 ? null : _ref3$moduleSettings,\n          _ref3$uniforms = _ref3.uniforms,\n          uniforms = _ref3$uniforms === void 0 ? {} : _ref3$uniforms,\n          _ref3$attributes = _ref3.attributes,\n          attributes = _ref3$attributes === void 0 ? {} : _ref3$attributes,\n          _ref3$samplers = _ref3.samplers,\n          samplers = _ref3$samplers === void 0 ? {} : _ref3$samplers,\n          _ref3$parameters = _ref3.parameters,\n          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters,\n          settings = _ref3.settings,\n          _ref3$framebuffer = _ref3.framebuffer,\n          framebuffer = _ref3$framebuffer === void 0 ? null : _ref3$framebuffer,\n          _ref3$vertexArray = _ref3.vertexArray,\n          vertexArray = _ref3$vertexArray === void 0 ? null : _ref3$vertexArray,\n          _ref3$transformFeedba = _ref3.transformFeedback,\n          transformFeedback = _ref3$transformFeedba === void 0 ? null : _ref3$transformFeedba;\n\n      if (settings) {\n        log.deprecated('settings', 'parameters')();\n        parameters = settings;\n      }\n\n      if (moduleSettings) {\n        this.updateModuleSettings(moduleSettings);\n      }\n\n      if (framebuffer) {\n        parameters = Object.assign(parameters, {\n          framebuffer: framebuffer\n        });\n      }\n\n      this.render(uniforms, attributes, samplers, transformFeedback, parameters, vertexArray);\n\n      if (framebuffer) {\n        framebuffer.log({\n          priority: LOG_DRAW_PRIORITY,\n          message: \"Rendered to \".concat(framebuffer.id)\n        });\n      }\n\n      return this;\n    }\n    /* eslint-disable max-params  */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var samplers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var transformFeedback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      var parameters = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var vertexArray = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n      addModel(this);\n      var resolvedUniforms = this.addViewUniforms(uniforms);\n      getOverrides(this.id, resolvedUniforms);\n      this.setUniforms(resolvedUniforms);\n      this.setAttributes(attributes);\n      Object.assign(this.samplers, samplers);\n      log.group(LOG_DRAW_PRIORITY, \">>> RENDERING MODEL \".concat(this.id), {\n        collapsed: log.priority <= 2\n      })();\n      this.setProgramState({\n        vertexArray: vertexArray\n      });\n\n      this._logAttributesAndUniforms(2, resolvedUniforms);\n\n      this.onBeforeRender();\n      var drawParams = this.drawParams;\n\n      if (drawParams.isInstanced && !this.isInstanced) {\n        log.warn('Found instanced attributes on non-instanced model')();\n      }\n\n      var isIndexed = drawParams.isIndexed,\n          indexType = drawParams.indexType;\n      var isInstanced = this.isInstanced,\n          instanceCount = this.instanceCount;\n\n      this._timerQueryStart();\n\n      this.program.draw({\n        parameters: parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray: vertexArray,\n        transformFeedback: transformFeedback,\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount\n      });\n\n      this._timerQueryEnd();\n\n      this.onAfterRender();\n      this.unsetProgramState();\n      this.setNeedsRedraw(false);\n      log.groupEnd(LOG_DRAW_PRIORITY, \">>> RENDERING MODEL \".concat(this.id))();\n      return this;\n    }\n    /* eslint-enable max-params  */\n\n  }, {\n    key: \"setProgramState\",\n    value: function setProgramState() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$vertexArray = _ref4.vertexArray,\n          vertexArray = _ref4$vertexArray === void 0 ? null : _ref4$vertexArray;\n\n      var program = this.program;\n      program.use();\n      this.drawParams = {};\n      program.setAttributes(this._attributes, {\n        drawParams: this.drawParams\n      });\n      program.checkAttributeBindings({\n        vertexArray: vertexArray\n      });\n      program.setUniforms(this.uniforms, this.samplers);\n      return this;\n    }\n  }, {\n    key: \"unsetProgramState\",\n    value: function unsetProgramState() {\n      // Ensures all vertex attributes are disabled and ELEMENT_ARRAY_BUFFER\n      // is unbound\n      this.program.unsetBuffers();\n      return this;\n    } // DEPRECATED METHODS\n    // TODO - uniform names are too strongly linked camera <=> default shaders\n    // At least all special handling is collected here.\n\n  }, {\n    key: \"addViewUniforms\",\n    value: function addViewUniforms(uniforms) {\n      // TODO - special treatment of these parameters should be removed\n      var camera = uniforms.camera,\n          viewMatrix = uniforms.viewMatrix,\n          modelMatrix = uniforms.modelMatrix; // Camera exposes uniforms that can be used directly in shaders\n\n      var cameraUniforms = camera ? camera.getUniforms() : {};\n      var viewUniforms = viewMatrix ? this.getCoordinateUniforms(viewMatrix, modelMatrix) : {};\n      return Object.assign({}, uniforms, cameraUniforms, viewUniforms);\n    } // PRIVATE METHODS\n\n  }, {\n    key: \"_initializeProgram\",\n    value: function _initializeProgram(_ref5) {\n      var vs = _ref5.vs,\n          fs = _ref5.fs,\n          modules = _ref5.modules,\n          defines = _ref5.defines,\n          moduleSettings = _ref5.moduleSettings,\n          defaultUniforms = _ref5.defaultUniforms,\n          program = _ref5.program,\n          shaderCache = _ref5.shaderCache,\n          varyings = _ref5.varyings,\n          bufferMode = _ref5.bufferMode;\n\n      this.getModuleUniforms = function (x) {};\n\n      if (!program) {\n        // Assign default shaders if none are provided\n        if (!vs) {\n          vs = MODULAR_SHADERS.vs;\n        }\n\n        if (!fs) {\n          fs = MODULAR_SHADERS.fs;\n        }\n\n        var assembleResult = assembleShaders(this.gl, {\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          defines: defines\n        });\n        vs = assembleResult.vs;\n        fs = assembleResult.fs;\n\n        if (shaderCache) {\n          program = shaderCache.getProgram(this.gl, {\n            vs: vs,\n            fs: fs,\n            id: this.id\n          });\n        } else {\n          program = new Program(this.gl, {\n            vs: vs,\n            fs: fs,\n            varyings: varyings,\n            bufferMode: bufferMode\n          });\n        }\n\n        var getUniforms = assembleResult.getUniforms;\n\n        this.getModuleUniforms = getUniforms || function (x) {};\n      }\n\n      this.program = program;\n      assert(_instanceof(this.program, Program), 'Model needs a program');\n    }\n    /* eslint-enable complexity */\n\n  }, {\n    key: \"_checkForDeprecatedUniforms\",\n    value: function _checkForDeprecatedUniforms(uniforms) {\n      // deprecated picking uniforms\n      DEPRECATED_PICKING_UNIFORMS.forEach(function (uniform) {\n        if (uniform in uniforms) {\n          log.deprecated(uniform, 'use picking shader module and Model class updateModuleSettings()')();\n        }\n      });\n    }\n  }, {\n    key: \"_timerQueryStart\",\n    value: function _timerQueryStart() {\n      if (this.timerQueryEnabled === true) {\n        if (!this.timeElapsedQuery) {\n          this.timeElapsedQuery = new Query(this.gl);\n        }\n\n        if (this.lastQueryReturned) {\n          this.lastQueryReturned = false;\n          this.timeElapsedQuery.beginTimeElapsedQuery();\n        }\n      }\n    }\n  }, {\n    key: \"_timerQueryEnd\",\n    value: function _timerQueryEnd() {\n      if (this.timerQueryEnabled === true) {\n        this.timeElapsedQuery.end(); // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n        // should this be incorporated into Query object?\n\n        if (this.timeElapsedQuery.isResultAvailable()) {\n          this.lastQueryReturned = true;\n          var elapsedTime = this.timeElapsedQuery.getResult(); // Update stats (e.g. for seer)\n\n          this.stats.lastFrameTime = elapsedTime;\n          this.stats.accumulatedFrameTime += elapsedTime;\n          this.stats.profileFrameCount++;\n          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount; // Log stats\n\n          log.log(LOG_DRAW_PRIORITY, \"GPU time \".concat(this.program.id, \": \").concat(this.stats.lastFrameTime, \"ms average \").concat(this.stats.averageFrameTime, \"ms accumulated: \").concat(this.stats.accumulatedFrameTime, \"ms count: \").concat(this.stats.profileFrameCount))();\n        }\n      }\n    } // Makes sure buffers are created for all attributes\n    // and that the program is updated with those buffers\n    // TODO - do we need the separation between \"attributes\" and \"buffers\"\n    // couldn't apps just create buffers directly?\n\n  }, {\n    key: \"_createBuffersFromAttributeDescriptors\",\n    value: function _createBuffersFromAttributeDescriptors(attributes) {\n      var gl = this.program.gl;\n\n      for (var attributeName in attributes) {\n        var descriptor = attributes[attributeName];\n        var attribute = this._attributes[attributeName];\n\n        if (_instanceof(descriptor, Attribute)) {\n          attribute = descriptor;\n        } else if (_instanceof(descriptor, Buffer)) {\n          attribute = attribute || new Attribute(gl, Object.assign({}, descriptor.layout, {\n            id: attributeName\n          }));\n          attribute.update({\n            isGeneric: false,\n            buffer: descriptor\n          });\n        } else if (attribute) {\n          attribute.update(descriptor);\n        } else {\n          attribute = new Attribute(gl, descriptor);\n        }\n\n        this._attributes[attributeName] = attribute;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_logAttributesAndUniforms\",\n    value: function _logAttributesAndUniforms(priority) {\n      var uniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (log.priority >= priority) {\n        var attributeTable = this._getAttributesTable({\n          header: \"\".concat(this.id, \" attributes\"),\n          program: this.program,\n          attributes: this._attributes\n        });\n\n        log.table(priority, attributeTable)();\n\n        var _getUniformsTable = getUniformsTable({\n          header: \"\".concat(this.id, \" uniforms\"),\n          program: this.program,\n          uniforms: Object.assign({}, this.uniforms, uniforms)\n        }),\n            table = _getUniformsTable.table,\n            unusedTable = _getUniformsTable.unusedTable,\n            unusedCount = _getUniformsTable.unusedCount;\n\n        log.table(priority, table)();\n        log.log(priority, \"\".concat(unusedCount || 'No', \" unused uniforms \"), unusedTable)();\n      } else {\n        // Always log missing uniforms\n        var _getUniformsTable2 = getUniformsTable({\n          header: \"\".concat(this.id, \" uniforms\"),\n          program: this.program,\n          uniforms: Object.assign({}, this.uniforms, uniforms),\n          undefinedOnly: true\n        }),\n            _table = _getUniformsTable2.table,\n            count = _getUniformsTable2.count;\n\n        if (count > 0) {\n          log.table(priority, _table)();\n        }\n      }\n\n      logModel(this, uniforms);\n    } // Todo move to attributes manager\n\n  }, {\n    key: \"_getAttributesTable\",\n    value: function _getAttributesTable() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          attributes = _ref6.attributes,\n          _ref6$header = _ref6.header,\n          header = _ref6$header === void 0 ? 'Attributes' : _ref6$header,\n          instanced = _ref6.instanced,\n          program = _ref6.program;\n\n      assert(program);\n      var attributeLocations = program._attributeToLocationMap;\n      var table = {}; // {[header]: {}};\n      // Add index if available\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        if (attribute.isIndexed) {\n          this._createAttributeEntry(attribute, 'ELEMENT_ARRAY_BUFFER', header);\n        }\n      } // Add used attributes\n\n\n      for (var _attributeName in attributeLocations) {\n        var _attribute = attributes[_attributeName];\n        var location = attributeLocations[_attributeName];\n        table[_attributeName] = this._createAttributeEntry(_attribute, location, header);\n      } // Add any unused attributes\n\n\n      for (var _attributeName2 in attributes) {\n        var _attribute2 = attributes[_attributeName2];\n\n        if (!table[_attributeName2]) {\n          table[_attributeName2] = this._createAttributeEntry(_attribute2, null, header);\n        }\n      }\n\n      return table;\n    }\n  }, {\n    key: \"_createAttributeEntry\",\n    value: function _createAttributeEntry(attribute, location, header) {\n      var _ref7;\n\n      var round = function round(num) {\n        return Math.round(num * 10) / 10;\n      };\n\n      var type = 'NOT PROVIDED';\n      var instanced = 0;\n      var size = 'N/A';\n      var verts = 'N/A';\n      var bytes = 'N/A';\n      var value = 'N/A';\n\n      if (attribute && location === null) {\n        location = attribute.isIndexed ? 'ELEMENT_ARRAY_BUFFER' : 'NOT USED';\n      }\n\n      if (attribute) {\n        type = attribute.type;\n        instanced = attribute.instanced;\n        size = attribute.size;\n\n        if (attribute.externalBuffer) {\n          value = attribute.externalBuffer.data;\n          bytes = attribute.externalBuffer.bytes;\n          verts = bytes / value.BYTES_PER_ELEMENT;\n        } else if (attribute.value) {\n          value = attribute.value;\n          verts = round(value.length / size);\n          bytes = value.length * value.BYTES_PER_ELEMENT;\n        }\n      } // Generate a type name by dropping Array from Float32Array etc.\n\n\n      type = String(type).replace('Array', ''); // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n\n      var isInteger = type.indexOf('nt') !== -1;\n      return _ref7 = {}, _defineProperty(_ref7, header, formatValue(value, {\n        size: size,\n        isInteger: isInteger\n      })), _defineProperty(_ref7, 'Memory Size and Layout', \"\".concat(instanced ? 'I ' : 'P ', \" \").concat(verts, \" (x\").concat(size, \"=\").concat(bytes, \"bytes \").concat(type, \") loc=\").concat(location)), _ref7;\n    } // DEPRECATED / REMOVED\n\n  }, {\n    key: \"isPickable\",\n    value: function isPickable() {\n      return this.pickable;\n    }\n  }, {\n    key: \"setPickable\",\n    value: function setPickable() {\n      var pickable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.pickable = Boolean(pickable);\n      return this;\n    }\n  }, {\n    key: \"getGeometry\",\n    value: function getGeometry() {\n      return this.geometry;\n    }\n  }, {\n    key: \"varyingMap\",\n    get: function get() {\n      return this.program.varyingMap;\n    }\n  }]);\n\n  return Model;\n}(Object3D);\n\nexport { Model as default };","map":null,"metadata":{},"sourceType":"module"}