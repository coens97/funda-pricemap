{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _wheelInput = require('./wheel-input');\n\nvar _wheelInput2 = _interopRequireDefault(_wheelInput);\n\nvar _moveInput = require('./move-input');\n\nvar _moveInput2 = _interopRequireDefault(_moveInput);\n\nvar _isBrowser = require('../is-browser');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // Hammer.js directly references `document` and `window`,\n// which means that importing it in environments without\n// those objects throws errors. Therefore, instead of\n// directly `import`ing 'hammerjs' and './constants'\n// (which imports Hammer.js) we conditionally require it\n// depending on support for those globals, and provide mocks\n// for environments without `document`/`window`.\n\n\nfunction ManagerMock(m) {\n  var instance = {};\n\n  var chainedNoop = function chainedNoop() {\n    return instance;\n  };\n\n  instance.on = chainedNoop;\n  instance.off = chainedNoop;\n  instance.destroy = chainedNoop;\n  instance.emit = chainedNoop;\n\n  instance.get = function () {\n    return null;\n  };\n\n  instance.set = chainedNoop;\n  return instance;\n}\n\nvar Manager = _isBrowser.isBrowser ? require('hammerjs').Manager : ManagerMock;\n\nvar _ref = _isBrowser.isBrowser ? require('./constants') : {\n  BASIC_EVENT_ALIASES: {},\n  EVENT_RECOGNIZER_MAP: {},\n  GESTURE_EVENT_ALIASES: {}\n},\n    BASIC_EVENT_ALIASES = _ref.BASIC_EVENT_ALIASES,\n    EVENT_RECOGNIZER_MAP = _ref.EVENT_RECOGNIZER_MAP,\n    RECOGNIZERS = _ref.RECOGNIZERS,\n    GESTURE_EVENT_ALIASES = _ref.GESTURE_EVENT_ALIASES;\n/**\n * Single API for subscribing to events about both\n * basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n * and gestural input (e.g. 'click', 'tap', 'panstart').\n * Delegates event registration and handling to Hammer.js.\n * @param {DOM Element} element         DOM element on which event handlers will be registered.\n * @param {Object} options              Options for instantiation\n * @param {Object} options.events       Map of {event name: handler} to register on init.\n * @param {Object} options.recognizers  Gesture recognizers from Hammer.js to register,\n *                                      as an Array in Hammer.Recognizer format.\n *                                      (http://hammerjs.github.io/api/#hammermanager)\n */\n\n\nvar EventManager = function () {\n  function EventManager(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    (0, _classCallCheck3.default)(this, EventManager);\n    this.element = element;\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this.manager = new Manager(element, {\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n    this.eventHandlers = []; // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n    this.wheelInput = new _wheelInput2.default(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new _moveInput2.default(element, this._onOtherEvent, {\n      enable: false\n    }); // Register all passed events.\n\n    var events = options.events;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n  /**\n   * Tear down internal event management implementations.\n   */\n\n\n  (0, _createClass3.default)(EventManager, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.manager.destroy();\n    }\n    /**\n     * Register an event handler function to be called on `event`.\n     * @param {string|Object} event   An event name (String) or map of event names to handlers.\n     * @param {Function} [handler]    The function to be called on `event`.\n     */\n\n  }, {\n    key: 'on',\n    value: function on(event, handler) {\n      if (typeof event === 'string') {\n        this._addEventHandler(event, handler);\n      } else {\n        // If `event` is a map, call `on()` for each entry.\n        for (var eventName in event) {\n          this._addEventHandler(eventName, event[eventName]);\n        }\n      }\n    }\n    /**\n     * Deregister a previously-registered event handler.\n     * @param {string|Object} event   An event name (String) or map of event names to handlers\n     * @param {Function} [handler]    The function to be called on `event`.\n     */\n\n  }, {\n    key: 'off',\n    value: function off(event, handler) {\n      if (typeof event === 'string') {\n        this._removeEventHandler(event, handler);\n      } else {\n        // If `event` is a map, call `off()` for each entry.\n        for (var eventName in event) {\n          this._removeEventHandler(eventName, event[eventName]);\n        }\n      }\n    }\n    /*\n     * Enable/disable recognizer for the given event\n     */\n\n  }, {\n    key: '_toggleRecognizer',\n    value: function _toggleRecognizer(name, enabled) {\n      var recognizer = this.manager.get(name);\n\n      if (recognizer) {\n        recognizer.set({\n          enable: enabled\n        });\n      }\n\n      this.wheelInput.toggleIfEventSupported(name, enabled);\n      this.moveInput.toggleIfEventSupported(name, enabled);\n    }\n    /**\n     * Process the event registration for a single event + handler.\n     */\n\n  }, {\n    key: '_addEventHandler',\n    value: function _addEventHandler(event, handler) {\n      var wrappedHandler = this._wrapEventHandler(event, handler); // Alias to a recognized gesture as necessary.\n\n\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event; // Get recognizer for this event\n\n      var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Enable recognizer for this event.\n\n      this._toggleRecognizer(recognizerName, true); // Save wrapped handler\n\n\n      this.eventHandlers.push({\n        event: event,\n        eventAlias: eventAlias,\n        recognizerName: recognizerName,\n        handler: handler,\n        wrappedHandler: wrappedHandler\n      });\n      this.manager.on(eventAlias, wrappedHandler);\n    }\n    /**\n     * Process the event deregistration for a single event + handler.\n     */\n\n  }, {\n    key: '_removeEventHandler',\n    value: function _removeEventHandler(event, handler) {\n      var success = false; // Find saved handler if any.\n\n      for (var i = this.eventHandlers.length; i--;) {\n        var entry = this.eventHandlers[i];\n\n        if (entry.event === event && entry.handler === handler) {\n          // Deregister event handler.\n          this.manager.off(entry.eventAlias, entry.wrappedHandler); // Delete saved handler\n\n          this.eventHandlers.splice(i, 1);\n          success = true;\n        }\n      }\n\n      if (success) {\n        // Alias to a recognized gesture as necessary.\n        var eventAlias = GESTURE_EVENT_ALIASES[event] || event; // Get recognizer for this event\n\n        var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Disable recognizer if no more handlers are attached to its events\n\n        var isRecognizerUsed = this.eventHandlers.find(function (entry) {\n          return entry.recognizerName === recognizerName;\n        });\n\n        if (!isRecognizerUsed) {\n          this._toggleRecognizer(recognizerName, false);\n        }\n      }\n    }\n    /**\n     * Returns an event handler that aliases events and add props before passing\n     * to the real handler.\n     */\n\n  }, {\n    key: '_wrapEventHandler',\n    value: function _wrapEventHandler(type, handler) {\n      var _this = this;\n\n      return function (event) {\n        var element = _this.element;\n        var srcEvent = event.srcEvent;\n        var center = event.center || {\n          x: srcEvent.clientX,\n          y: srcEvent.clientY\n        };\n        var rect = element.getBoundingClientRect(); // Fix scale for map affected by a CSS transform.\n        // See https://stackoverflow.com/a/26893663/3528533\n\n        var scaleX = rect.width / element.offsetWidth;\n        var scaleY = rect.height / element.offsetHeight; // Calculate center relative to the root element\n\n        var offsetCenter = {\n          x: (center.x - rect.left - element.clientLeft) / scaleX,\n          y: (center.y - rect.top - element.clientTop) / scaleY\n        };\n        handler((0, _assign2.default)({}, event, {\n          type: type,\n          center: center,\n          offsetCenter: offsetCenter,\n          rootElement: element\n        }));\n      };\n    }\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n\n  }, {\n    key: '_onBasicInput',\n    value: function _onBasicInput(event) {\n      var srcEvent = event.srcEvent;\n      var alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        var emitEvent = (0, _assign2.default)({}, event, {\n          type: alias\n        });\n        this.manager.emit(alias, emitEvent);\n      }\n    }\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n\n  }, {\n    key: '_onOtherEvent',\n    value: function _onOtherEvent(event) {\n      this.manager.emit(event.type, event);\n    }\n  }]);\n  return EventManager;\n}();\n\nexports.default = EventManager;","map":null,"metadata":{},"sourceType":"script"}