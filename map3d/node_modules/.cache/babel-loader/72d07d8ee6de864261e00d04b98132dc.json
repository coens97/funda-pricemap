{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}(); // TODO - THESE UTILITIES COULD BE IMPORTED FROM WEB_MERCATOR_VIEWPORT\n\n\nimport mat4_perspective from 'gl-mat4/perspective';\nimport mat4_scale from 'gl-mat4/scale';\nimport mat4_translate from 'gl-mat4/translate';\nimport mat4_rotateX from 'gl-mat4/rotateX';\nimport mat4_rotateZ from 'gl-mat4/rotateZ';\nimport vec2_distance from 'gl-vec2/distance';\nimport assert from 'assert'; // CONSTANTS\n\nvar PI = Math.PI;\nvar PI_4 = PI / 4;\nvar DEGREES_TO_RADIANS = PI / 180;\nvar RADIANS_TO_DEGREES = 180 / PI;\nvar TILE_SIZE = 512;\nvar WORLD_SCALE = TILE_SIZE;\nvar METERS_PER_DEGREE_AT_EQUATOR = 111000; // Approximately 111km per degree at equator\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\n\nfunction createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n/**\n * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n * Performs the nonlinear part of the web mercator projection.\n * Remaining projection is done with 4x4 matrices which also handles\n * perspective.\n *\n * @param {Array} lngLat - [lng, lat] coordinates\n *   Specifies a point on the sphere to project onto the map.\n * @return {Array} [x,y] coordinates.\n */\n\n\nexport function projectFlat(_ref, scale) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      lng = _ref2[0],\n      lat = _ref2[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = lng * DEGREES_TO_RADIANS;\n  var phi2 = lat * DEGREES_TO_RADIANS;\n  var x = scale * (lambda2 + PI) / (2 * PI);\n  var y = scale * (PI - Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);\n  return [x, y];\n}\n/**\n * Unproject world point [x,y] on map onto {lat, lon} on sphere\n *\n * @param {object|Vector} xy - object with {x,y} members\n *  representing point on projected map plane\n * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n *   Has toArray method if you need a GeoJSON Array.\n *   Per cartographic tradition, lat and lon are specified as degrees.\n */\n\nexport function unprojectFlat(_ref3, scale) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      x = _ref4[0],\n      y = _ref4[1];\n\n  scale = scale * WORLD_SCALE;\n  var lambda2 = x / scale * (2 * PI) - PI;\n  var phi2 = 2 * (Math.atan(Math.exp(PI - y / scale * (2 * PI))) - PI_4);\n  return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];\n}\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\n\nexport function calculateDistanceScales(_ref5) {\n  var latitude = _ref5.latitude,\n      longitude = _ref5.longitude,\n      zoom = _ref5.zoom,\n      scale = _ref5.scale; // Calculate scale from zoom if not provided\n\n  scale = scale !== undefined ? scale : Math.pow(2, zoom);\n  assert(!isNaN(latitude) && !isNaN(longitude) && !isNaN(scale));\n  var latCosine = Math.cos(latitude * Math.PI / 180);\n  var metersPerDegree = METERS_PER_DEGREE_AT_EQUATOR * latCosine; // Calculate number of pixels occupied by one degree longitude\n  // around current lat/lon\n\n  var pixelsPerDegreeX = vec2_distance(projectFlat([longitude + 0.5, latitude], scale), projectFlat([longitude - 0.5, latitude], scale)); // Calculate number of pixels occupied by one degree latitude\n  // around current lat/lon\n\n  var pixelsPerDegreeY = vec2_distance(projectFlat([longitude, latitude + 0.5], scale), projectFlat([longitude, latitude - 0.5], scale));\n  var pixelsPerMeterX = pixelsPerDegreeX / metersPerDegree;\n  var pixelsPerMeterY = pixelsPerDegreeY / metersPerDegree;\n  var pixelsPerMeterZ = (pixelsPerMeterX + pixelsPerMeterY) / 2; // const pixelsPerMeter = [pixelsPerMeterX, pixelsPerMeterY, pixelsPerMeterZ];\n\n  var worldSize = TILE_SIZE * scale;\n  var altPixelsPerMeter = worldSize / (4e7 * latCosine);\n  var pixelsPerMeter = [altPixelsPerMeter, altPixelsPerMeter, altPixelsPerMeter];\n  var metersPerPixel = [1 / altPixelsPerMeter, 1 / altPixelsPerMeter, 1 / pixelsPerMeterZ];\n  var pixelsPerDegree = [pixelsPerDegreeX, pixelsPerDegreeY, pixelsPerMeterZ];\n  var degreesPerPixel = [1 / pixelsPerDegreeX, 1 / pixelsPerDegreeY, 1 / pixelsPerMeterZ]; // Main results, used for converting meters to latlng deltas and scaling offsets\n\n  return {\n    pixelsPerMeter: pixelsPerMeter,\n    metersPerPixel: metersPerPixel,\n    pixelsPerDegree: pixelsPerDegree,\n    degreesPerPixel: degreesPerPixel\n  };\n} // ATTRIBUTION:\n// view and projection matrix creation is intentionally kept compatible with\n// mapbox-gl's implementation to ensure that seamless interoperation\n// with mapbox and react-map-gl. See: https://github.com/mapbox/mapbox-gl-js\n// Variable fov (in radians)\n\nexport function getFov(_ref6) {\n  var height = _ref6.height,\n      altitude = _ref6.altitude;\n  return 2 * Math.atan(height / 2 / altitude);\n}\nexport function getClippingPlanes(_ref7) {\n  var altitude = _ref7.altitude,\n      pitch = _ref7.pitch; // Find the distance from the center point to the center top\n  // in altitude units using law of sines.\n\n  var pitchRadians = pitch * DEGREES_TO_RADIANS;\n  var halfFov = Math.atan(0.5 / altitude);\n  var topHalfSurfaceDistance = Math.sin(halfFov) * altitude / Math.sin(Math.PI / 2 - pitchRadians - halfFov); // Calculate z value of the farthest fragment that should be rendered.\n\n  var farZ = Math.cos(Math.PI / 2 - pitchRadians) * topHalfSurfaceDistance + altitude;\n  return {\n    farZ: farZ,\n    nearZ: 0.1\n  };\n} // PROJECTION MATRIX: PROJECTS FROM CAMERA (VIEW) SPACE TO CLIPSPACE\n\nexport function makeProjectionMatrixFromMercatorParams(_ref8) {\n  var width = _ref8.width,\n      height = _ref8.height,\n      pitch = _ref8.pitch,\n      altitude = _ref8.altitude,\n      _ref8$farZMultiplier = _ref8.farZMultiplier,\n      farZMultiplier = _ref8$farZMultiplier === undefined ? 10 : _ref8$farZMultiplier;\n\n  var _getClippingPlanes = getClippingPlanes({\n    altitude: altitude,\n    pitch: pitch\n  }),\n      nearZ = _getClippingPlanes.nearZ,\n      farZ = _getClippingPlanes.farZ;\n\n  var fov = getFov({\n    height: height,\n    altitude: altitude\n  });\n  var projectionMatrix = mat4_perspective(createMat4(), fov, // fov in radians\n  width / height, // aspect ratio\n  nearZ, // near plane\n  farZ * farZMultiplier // far plane\n  );\n  return projectionMatrix;\n}\nexport function makeUncenteredViewMatrixFromMercatorParams(_ref9) {\n  var width = _ref9.width,\n      height = _ref9.height,\n      longitude = _ref9.longitude,\n      latitude = _ref9.latitude,\n      zoom = _ref9.zoom,\n      pitch = _ref9.pitch,\n      bearing = _ref9.bearing,\n      altitude = _ref9.altitude,\n      center = _ref9.center; // VIEW MATRIX: PROJECTS FROM VIRTUAL PIXELS TO CAMERA SPACE\n  // Note: As usual, matrix operation orders should be read in reverse\n  // since vectors will be multiplied from the right during transformation\n\n  var vm = createMat4(); // Move camera to altitude\n\n  mat4_translate(vm, vm, [0, 0, -altitude]); // After the rotateX, z values are in pixel units. Convert them to\n  // altitude units. 1 altitude unit = the screen height.\n\n  mat4_scale(vm, vm, [1, -1, 1 / height]); // Rotate by bearing, and then by pitch (which tilts the view)\n\n  mat4_rotateX(vm, vm, pitch * DEGREES_TO_RADIANS);\n  mat4_rotateZ(vm, vm, -bearing * DEGREES_TO_RADIANS);\n  return vm;\n}","map":null,"metadata":{},"sourceType":"module"}