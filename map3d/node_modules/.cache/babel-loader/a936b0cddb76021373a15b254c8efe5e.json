{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Support for listening to context state changes and intercepting state queries\n//\n// NOTE: this system does not handle buffer bindings\n\n\nimport GL from './constants';\nimport { setParameters, getParameters, GL_PARAMETER_DEFAULTS } from './set-parameters';\nimport polyfillContext from './polyfill-context';\nimport assert from 'assert';\nexport var clone = function clone(x) {\n  return Array.isArray(x) || ArrayBuffer.isView(x) ? x.slice() : x;\n};\nexport var deepEqual = function deepEqual(x, y) {\n  var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);\n  var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);\n\n  if (isArrayX && isArrayY && x.length === y.length) {\n    for (var i = 0; i < x.length; ++i) {\n      if (x[i] !== y[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return x === y;\n}; // interceptors for WEBGL FUNCTIONS that set WebGLRenderingContext state\n\nvar GL_STATE_SETTERS = {\n  // GENERIC SETTERS\n  enable: function enable(setter, cap) {\n    return setter(_defineProperty({}, cap, true));\n  },\n  disable: function disable(setter, cap) {\n    return setter(_defineProperty({}, cap, false));\n  },\n  pixelStorei: function pixelStorei(setter, pname, param) {\n    return setter(_defineProperty({}, pname, param));\n  },\n  hint: function hint(setter, pname, _hint) {\n    return setter(_defineProperty({}, pname, _hint));\n  },\n  // SPECIFIC SETTERS\n  bindFramebuffer: function bindFramebuffer(setter, target, fb) {\n    return setter(_defineProperty({}, target === GL.READ_FRAMEBUFFER ? GL.READ_FRAMEBUFFER_BINDING : GL.DRAW_FRAMEBUFFER_BINDING, fb));\n  },\n  blendColor: function blendColor(setter, r, g, b, a) {\n    return setter(_defineProperty({}, GL.BLEND_COLOR, new Float32Array([r, g, b, a])));\n  },\n  blendEquation: function blendEquation(setter, mode) {\n    var _setter7;\n\n    return setter((_setter7 = {}, _defineProperty(_setter7, GL.BLEND_EQUATION_RGB, mode), _defineProperty(_setter7, GL.BLEND_EQUATION_ALPHA, mode), _setter7));\n  },\n  blendEquationSeparate: function blendEquationSeparate(setter, modeRGB, modeAlpha) {\n    var _setter8;\n\n    return setter((_setter8 = {}, _defineProperty(_setter8, GL.BLEND_EQUATION_RGB, modeRGB), _defineProperty(_setter8, GL.BLEND_EQUATION_ALPHA, modeAlpha), _setter8));\n  },\n  blendFunc: function blendFunc(setter, src, dst) {\n    var _setter9;\n\n    return setter((_setter9 = {}, _defineProperty(_setter9, GL.BLEND_SRC_RGB, src), _defineProperty(_setter9, GL.BLEND_DST_RGB, dst), _defineProperty(_setter9, GL.BLEND_SRC_ALPHA, src), _defineProperty(_setter9, GL.BLEND_DST_ALPHA, dst), _setter9));\n  },\n  blendFuncSeparate: function blendFuncSeparate(setter, srcRGB, dstRGB, srcAlpha, dstAlpha) {\n    var _setter10;\n\n    return setter((_setter10 = {}, _defineProperty(_setter10, GL.BLEND_SRC_RGB, srcRGB), _defineProperty(_setter10, GL.BLEND_DST_RGB, dstRGB), _defineProperty(_setter10, GL.BLEND_SRC_ALPHA, srcAlpha), _defineProperty(_setter10, GL.BLEND_DST_ALPHA, dstAlpha), _setter10));\n  },\n  clearColor: function clearColor(setter, r, g, b, a) {\n    return setter(_defineProperty({}, GL.COLOR_CLEAR_VALUE, new Float32Array([r, g, b, a])));\n  },\n  clearDepth: function clearDepth(setter, depth) {\n    return setter(_defineProperty({}, GL.DEPTH_CLEAR_VALUE, depth));\n  },\n  clearStencil: function clearStencil(setter, s) {\n    return setter(_defineProperty({}, GL.STENCIL_CLEAR_VALUE, s));\n  },\n  colorMask: function colorMask(setter, r, g, b, a) {\n    return setter(_defineProperty({}, GL.COLOR_WRITEMASK, [r, g, b, a]));\n  },\n  cullFace: function cullFace(setter, mode) {\n    return setter(_defineProperty({}, GL.CULL_FACE_MODE, mode));\n  },\n  depthFunc: function depthFunc(setter, func) {\n    return setter(_defineProperty({}, GL.DEPTH_FUNC, func));\n  },\n  depthRange: function depthRange(setter, zNear, zFar) {\n    return setter(_defineProperty({}, GL.DEPTH_RANGE, new Float32Array([zNear, zFar])));\n  },\n  depthMask: function depthMask(setter, mask) {\n    return setter(_defineProperty({}, GL.DEPTH_WRITEMASK, mask));\n  },\n  frontFace: function frontFace(setter, face) {\n    return setter(_defineProperty({}, GL.FRONT_FACE, face));\n  },\n  lineWidth: function lineWidth(setter, width) {\n    return setter(_defineProperty({}, GL.LINE_WIDTH, width));\n  },\n  polygonOffset: function polygonOffset(setter, factor, units) {\n    var _setter21;\n\n    return setter((_setter21 = {}, _defineProperty(_setter21, GL.POLYGON_OFFSET_FACTOR, factor), _defineProperty(_setter21, GL.POLYGON_OFFSET_UNITS, units), _setter21));\n  },\n  sampleCoverage: function sampleCoverage(setter, value, invert) {\n    var _setter22;\n\n    return setter((_setter22 = {}, _defineProperty(_setter22, GL.SAMPLE_COVERAGE_VALUE, value), _defineProperty(_setter22, GL.SAMPLE_COVERAGE_INVERT, invert), _setter22));\n  },\n  scissor: function scissor(setter, x, y, width, height) {\n    return setter(_defineProperty({}, GL.SCISSOR_BOX, new Int32Array([x, y, width, height])));\n  },\n  stencilMask: function stencilMask(setter, mask) {\n    var _setter24;\n\n    return setter((_setter24 = {}, _defineProperty(_setter24, GL.STENCIL_WRITEMASK, mask), _defineProperty(_setter24, GL.STENCIL_BACK_WRITEMASK, mask), _setter24));\n  },\n  stencilMaskSeparate: function stencilMaskSeparate(setter, face, mask) {\n    return setter(_defineProperty({}, face === GL.FRONT ? GL.STENCIL_WRITEMASK : GL.STENCIL_BACK_WRITEMASK, mask));\n  },\n  stencilFunc: function stencilFunc(setter, func, ref, mask) {\n    var _setter26;\n\n    return setter((_setter26 = {}, _defineProperty(_setter26, GL.STENCIL_FUNC, func), _defineProperty(_setter26, GL.STENCIL_REF, ref), _defineProperty(_setter26, GL.STENCIL_VALUE_MASK, mask), _defineProperty(_setter26, GL.STENCIL_BACK_FUNC, func), _defineProperty(_setter26, GL.STENCIL_BACK_REF, ref), _defineProperty(_setter26, GL.STENCIL_BACK_VALUE_MASK, mask), _setter26));\n  },\n  stencilFuncSeparate: function stencilFuncSeparate(setter, face, func, ref, mask) {\n    var _setter27;\n\n    return setter((_setter27 = {}, _defineProperty(_setter27, face === GL.FRONT ? GL.STENCIL_FUNC : GL.STENCIL_BACK_FUNC, func), _defineProperty(_setter27, face === GL.FRONT ? GL.STENCIL_REF : GL.STENCIL_BACK_REF, ref), _defineProperty(_setter27, face === GL.FRONT ? GL.STENCIL_VALUE_MASK : GL.STENCIL_BACK_VALUE_MASK, mask), _setter27));\n  },\n  stencilOp: function stencilOp(setter, fail, zfail, zpass) {\n    var _setter28;\n\n    return setter((_setter28 = {}, _defineProperty(_setter28, GL.STENCIL_FAIL, fail), _defineProperty(_setter28, GL.STENCIL_PASS_DEPTH_FAIL, zfail), _defineProperty(_setter28, GL.STENCIL_PASS_DEPTH_PASS, zpass), _defineProperty(_setter28, GL.STENCIL_BACK_FAIL, fail), _defineProperty(_setter28, GL.STENCIL_BACK_PASS_DEPTH_FAIL, zfail), _defineProperty(_setter28, GL.STENCIL_BACK_PASS_DEPTH_PASS, zpass), _setter28));\n  },\n  stencilOpSeparate: function stencilOpSeparate(setter, face, fail, zfail, zpass) {\n    var _setter29;\n\n    return setter((_setter29 = {}, _defineProperty(_setter29, face === GL.FRONT ? GL.STENCIL_FAIL : GL.STENCIL_BACK_FAIL, fail), _defineProperty(_setter29, face === GL.FRONT ? GL.STENCIL_PASS_DEPTH_FAIL : GL.STENCIL_BACK_PASS_DEPTH_FAIL, zfail), _defineProperty(_setter29, face === GL.FRONT ? GL.STENCIL_PASS_DEPTH_PASS : GL.STENCIL_BACK_PASS_DEPTH_PASS, zpass), _setter29));\n  },\n  viewport: function viewport(setter, x, y, width, height) {\n    return setter(_defineProperty({}, GL.VIEWPORT, new Int32Array([x, y, width, height])));\n  }\n}; // HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT\n// Overrides a WebGLRenderingContext state \"getter\" function\n// to return values directly from cache\n\nexport { GL_STATE_SETTERS };\n\nfunction installGetterOverride(gl, functionName) {\n  // Get the original function from the WebGLRenderingContext\n  var originalGetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called\n\n  gl[functionName] = function () {\n    var pname = arguments.length <= 0 ? undefined : arguments[0]; // WebGL limits are not prepopulated in the cache, we must\n    // query first time. They are all primitive (single value)\n\n    if (!(pname in gl.state.cache)) {\n      gl.state.cache[pname] = originalGetterFunc.apply(undefined, arguments);\n    } // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n\n\n    return gl.state.enable ? // Call the getter the params so that it can e.g. serve from a cache\n    gl.state.cache[pname] : // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n    originalGetterFunc.apply(undefined, arguments);\n  }; // Set the name of this anonymous function to help in debugging and profiling\n\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: functionName + '-from-cache',\n    configurable: false\n  });\n} // Overrides a WebGLRenderingContext state \"setter\" function\n// to call a setter spy before the actual setter. Allows us to keep a cache\n// updated with a copy of the WebGL context state.\n\n\nfunction installSetterSpy(gl, functionName, setter, updateCache) {\n  // Get the original function from the WebGLRenderingContext\n  var originalSetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called\n\n  gl[functionName] = function () {\n    for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    } // Update the value\n    // Call the setter with the state cache and the params so that it can store the parameters\n\n\n    var valueChanged = setter.apply(undefined, [updateCache].concat(params)); // Call the original WebGLRenderingContext func to make sure the context actually gets updated\n\n    if (valueChanged) {\n      var _gl$state;\n\n      (_gl$state = gl.state).log.apply(_gl$state, ['gl.' + functionName].concat(params)); // eslint-disable-line\n\n\n      originalSetterFunc.apply(undefined, params);\n    } // Note: if the original function fails to set the value, our state cache will be bad\n    // No solution for this at the moment, but assuming that this is unlikely to be a real problem\n    // We could call the setter after the originalSetterFunc. Concern is that this would\n    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions\n\n  }; // Set the name of this anonymous function to help in debugging and profiling\n\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: functionName + '-to-cache',\n    configurable: false\n  });\n} // HELPER CLASS - GLState\n\n/* eslint-disable no-shadow */\n\n\nvar GLState =\n/*#__PURE__*/\nfunction () {\n  function GLState(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$copyState = _ref.copyState,\n        copyState = _ref$copyState === undefined ? false : _ref$copyState,\n        _ref$log = _ref.log,\n        log = _ref$log === undefined ? function () {} : _ref$log;\n\n    _classCallCheck(this, GLState);\n\n    this.gl = gl;\n    this.stateStack = [];\n    this.enable = true;\n    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    this.log = log;\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  _createClass(GLState, [{\n    key: 'push',\n    value: function push() {\n      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.stateStack.push({});\n    }\n  }, {\n    key: 'pop',\n    value: function pop() {\n      assert(this.stateStack.length > 0); // Use the saved values in the state stack to restore parameters\n\n      var oldValues = this.stateStack[this.stateStack.length - 1];\n      setParameters(this.gl, oldValues, this.cache); // Don't pop until we have reset parameters (to make sure other \"stack frames\" are not affected)\n\n      this.stateStack.pop();\n    } // interceptor for context set functions - update our cache and our stack\n    // values (Object) - the key values for this setter\n\n  }, {\n    key: '_updateCache',\n    value: function _updateCache(values) {\n      var valueChanged = false;\n      var oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];\n\n      for (var key in values) {\n        assert(key !== undefined); // Check that value hasn't already been shadowed\n\n        if (!deepEqual(values[key], this.cache[key])) {\n          valueChanged = true; // First, save current value being shadowed\n          // If a state stack frame is active, save the current parameter values for pop\n          // but first check that value hasn't already been shadowed and saved\n\n          if (oldValues && !(key in oldValues)) {\n            oldValues[key] = this.cache[key];\n          } // Save current value being shadowed\n\n\n          this.cache[key] = values[key];\n        }\n      }\n\n      return valueChanged;\n    }\n  }]);\n\n  return GLState;\n}(); // PUBLIC API\n\n/**\n * Initialize WebGL state caching on a context\n * can be called multiple times to enable/disable\n * @param {WebGLRenderingContext} - context\n */\n// After calling this function, context state will be cached\n// gl.state.push() and gl.state.pop() will be available for saving,\n// temporarily modifying, and then restoring state.\n\n\nexport default function trackContextState(gl) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$enable = _ref2.enable,\n      enable = _ref2$enable === undefined ? true : _ref2$enable,\n      copyState = _ref2.copyState;\n\n  assert(copyState !== undefined);\n\n  if (!gl.state) {\n    polyfillContext(gl); // Create a state cache\n\n    gl.state = new GLState(gl, {\n      copyState: copyState,\n      enable: enable\n    }); // intercept all setter functions in the table\n\n    for (var key in GL_STATE_SETTERS) {\n      var setter = GL_STATE_SETTERS[key];\n      installSetterSpy(gl, key, setter, gl.state._updateCache);\n    } // intercept all getter functions in the table\n\n\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  gl.state.enable = enable;\n  return gl;\n}\nexport function pushContextState(gl) {\n  assert(gl.state);\n  gl.state.push();\n}\nexport function popContextState(gl) {\n  assert(gl.state);\n  gl.state.pop();\n}","map":null,"metadata":{},"sourceType":"module"}