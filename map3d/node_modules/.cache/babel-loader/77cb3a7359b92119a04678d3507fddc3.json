{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport Controller from './controller';\nimport ViewState from './view-state';\nimport { Vector2, clamp } from 'math.gl'; // TODO: not sure whether we should have these constants\n// as part of viewport props\n\nvar MOVEMENT_SPEED = 10; // per keyboard click\n\nvar MIN_ZOOM = 0.1;\nvar MAX_ZOOM = 10;\n\nvar OrthographicState =\n/*#__PURE__*/\nfunction (_ViewState) {\n  _inherits(OrthographicState, _ViewState);\n\n  function OrthographicState(_ref) {\n    var _this;\n\n    var width = _ref.width,\n        height = _ref.height,\n        offset = _ref.offset,\n        zoom = _ref.zoom,\n        startPanPosition = _ref.startPanPosition,\n        startPanOffset = _ref.startPanOffset,\n        startRotatePosition = _ref.startRotatePosition,\n        startRotateOffset = _ref.startRotateOffset;\n\n    _classCallCheck(this, OrthographicState);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(OrthographicState).call(this, {\n      width: width,\n      height: height,\n      offset: offset,\n      zoom: zoom\n    }));\n    _this._interactiveState = {\n      startPanPosition: startPanPosition,\n      startPanOffset: startPanOffset,\n      startRotatePosition: startRotatePosition,\n      startRotateOffset: startRotateOffset\n    };\n    return _this;\n  }\n  /* Public API */\n\n\n  _createClass(OrthographicState, [{\n    key: \"getInteractiveState\",\n    value: function getInteractiveState() {\n      return this._interactiveState;\n    }\n    /**\n     * Start panning\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n\n  }, {\n    key: \"panStart\",\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      var offset = this._viewportProps.offset;\n      return this._getUpdatedState({\n        startPanPosition: pos,\n        startPanOffset: offset\n      });\n    }\n    /**\n     * Pan\n     * @param {[Number, Number]} pos - position on screen where the pointer is\n     */\n\n  }, {\n    key: \"pan\",\n    value: function pan(_ref3) {\n      var pos = _ref3.pos;\n      var _this$_interactiveSta = this._interactiveState,\n          startPanPosition = _this$_interactiveSta.startPanPosition,\n          startPanOffset = _this$_interactiveSta.startPanOffset;\n      var delta = new Vector2(pos).subtract(startPanPosition);\n      return this._getUpdatedState({\n        offset: new Vector2(startPanOffset).subtract(delta)\n      });\n    }\n    /**\n     * End panning\n     * Must call if `panStart()` was called\n     */\n\n  }, {\n    key: \"panEnd\",\n    value: function panEnd() {\n      return this._getUpdatedState({\n        startPanPosition: null,\n        startPanOffset: null\n      });\n    }\n    /**\n     * Start rotating\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n\n  }, {\n    key: \"rotateStart\",\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos;\n      return this;\n    }\n    /**\n     * Rotate\n     * @param {[Number, Number]} pos - position on screen where the pointer is\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(_ref5) {\n      var deltaScaleX = _ref5.deltaScaleX,\n          deltaScaleY = _ref5.deltaScaleY;\n      return this;\n    }\n    /**\n     * End rotating\n     * Must call if `rotateStart()` was called\n     */\n\n  }, {\n    key: \"rotateEnd\",\n    value: function rotateEnd() {\n      return this;\n    }\n    /**\n     * Zoom\n     * @param {Number} scale - a number between [0, 1] specifying the accumulated\n     *   relative scale.\n     * @param {[number, number]} pos - current mouse cursor screen position\n     */\n\n  }, {\n    key: \"zoom\",\n    value: function zoom(_ref6) {\n      var pos = _ref6.pos,\n          scale = _ref6.scale;\n      var _this$_viewportProps = this._viewportProps,\n          zoom = _this$_viewportProps.zoom,\n          width = _this$_viewportProps.width,\n          height = _this$_viewportProps.height,\n          offset = _this$_viewportProps.offset;\n      var newZoom = clamp(zoom * scale, MIN_ZOOM, MAX_ZOOM);\n      var centerX = width / 2 - offset[0];\n      var centerY = height / 2 - offset[1];\n      var dX = (pos[0] - centerX) * (zoom / newZoom - 1);\n      var dY = (pos[1] - centerY) * (zoom / newZoom - 1);\n      return this._getUpdatedState({\n        zoom: newZoom,\n        offset: [offset[0] + dX, offset[1] + dY]\n      });\n    }\n  }, {\n    key: \"moveLeft\",\n    value: function moveLeft() {\n      var offset = this._viewportProps.offset;\n      var delta = [MOVEMENT_SPEED, 0];\n      return this._getUpdatedState({\n        offset: new Vector2(offset).add(delta)\n      });\n    }\n  }, {\n    key: \"moveRight\",\n    value: function moveRight() {\n      var offset = this._viewportProps.offset;\n      var delta = [-MOVEMENT_SPEED, 0];\n      return this._getUpdatedState({\n        offset: new Vector2(offset).add(delta)\n      });\n    }\n  }, {\n    key: \"moveUp\",\n    value: function moveUp() {\n      var offset = this._viewportProps.offset;\n      var delta = [0, MOVEMENT_SPEED];\n      return this._getUpdatedState({\n        offset: new Vector2(offset).add(delta)\n      });\n    }\n  }, {\n    key: \"moveDown\",\n    value: function moveDown() {\n      var offset = this._viewportProps.offset;\n      var delta = [0, -MOVEMENT_SPEED];\n      return this._getUpdatedState({\n        offset: new Vector2(offset).add(delta)\n      });\n    }\n    /* Private methods */\n\n  }, {\n    key: \"_getUpdatedState\",\n    value: function _getUpdatedState(newProps) {\n      // Update _viewportProps\n      return new OrthographicState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));\n    }\n  }]);\n\n  return OrthographicState;\n}(ViewState);\n\nvar OrthographicController =\n/*#__PURE__*/\nfunction (_Controller) {\n  _inherits(OrthographicController, _Controller);\n\n  function OrthographicController(props) {\n    var _this2;\n\n    _classCallCheck(this, OrthographicController);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(OrthographicController).call(this, OrthographicState, props));\n    _this2.invertPan = true;\n    return _this2;\n  }\n\n  return OrthographicController;\n}(Controller);\n\nexport { OrthographicController as default };","map":null,"metadata":{},"sourceType":"module"}