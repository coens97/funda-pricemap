{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport LayerManager from '../lib/layer-manager';\nimport EffectManager from '../experimental/lib/effect-manager';\nimport Effect from '../experimental/lib/effect';\nimport WebMercatorViewport from '../viewports/web-mercator-viewport';\nimport { EventManager } from 'mjolnir.js';\nimport { GL, AnimationLoop, createGLContext, setParameters } from 'luma.gl';\nimport PropTypes from 'prop-types';\n/* global document */\n\nfunction noop() {}\n\nvar propTypes = {\n  id: PropTypes.string,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  layers: PropTypes.array.isRequired,\n  // Array can contain falsy values\n  viewports: PropTypes.array,\n  // Array can contain falsy values\n  effects: PropTypes.arrayOf(PropTypes.instanceOf(Effect)),\n  layerFilter: PropTypes.func,\n  glOptions: PropTypes.object,\n  gl: PropTypes.object,\n  pickingRadius: PropTypes.number,\n  onWebGLInitialized: PropTypes.func,\n  onBeforeRender: PropTypes.func,\n  onAfterRender: PropTypes.func,\n  onLayerClick: PropTypes.func,\n  onLayerHover: PropTypes.func,\n  useDevicePixels: PropTypes.bool,\n  // Debug settings\n  debug: PropTypes.bool,\n  drawPickingColors: PropTypes.bool\n};\nvar defaultProps = {\n  id: 'deckgl-overlay',\n  pickingRadius: 0,\n  layerFilter: null,\n  glOptions: {},\n  gl: null,\n  effects: [],\n  onWebGLInitialized: noop,\n  onBeforeRender: noop,\n  onAfterRender: noop,\n  onLayerClick: null,\n  onLayerHover: null,\n  useDevicePixels: true,\n  debug: false,\n  drawPickingColors: false\n}; // TODO - should this class be joined with `LayerManager`?\n\nvar DeckGLJS = function () {\n  function DeckGLJS(props) {\n    var _this = this;\n\n    _classCallCheck(this, DeckGLJS);\n\n    props = Object.assign({}, defaultProps, props);\n    this.state = {};\n    this.needsRedraw = true;\n    this.layerManager = null;\n    this.effectManager = null;\n    this.viewports = []; // Bind methods\n\n    this._onRendererInitialized = this._onRendererInitialized.bind(this);\n    this._onRenderFrame = this._onRenderFrame.bind(this);\n    this.canvas = this._createCanvas(props);\n    var _props = props,\n        width = _props.width,\n        height = _props.height,\n        gl = _props.gl,\n        glOptions = _props.glOptions,\n        debug = _props.debug,\n        useDevicePixels = _props.useDevicePixels;\n    this.animationLoop = new AnimationLoop({\n      width: width,\n      height: height,\n      useDevicePixels: useDevicePixels,\n      onCreateContext: function onCreateContext(opts) {\n        return gl || createGLContext(Object.assign({}, glOptions, {\n          canvas: _this.canvas,\n          debug: debug\n        }));\n      },\n      onInitialize: this._onRendererInitialized,\n      onRender: this._onRenderFrame,\n      onBeforeRender: props.onBeforeRender,\n      onAfterRender: props.onAfterRender\n    });\n    this.animationLoop.start();\n    this.setProps(props);\n  }\n\n  _createClass(DeckGLJS, [{\n    key: 'setProps',\n    value: function setProps(props) {\n      props = Object.assign({}, this.props, props);\n      this.props = props;\n\n      if (!this.layerManager) {\n        return;\n      }\n\n      var _props2 = props,\n          layers = _props2.layers,\n          pickingRadius = _props2.pickingRadius,\n          onLayerClick = _props2.onLayerClick,\n          onLayerHover = _props2.onLayerHover,\n          useDevicePixels = _props2.useDevicePixels,\n          drawPickingColors = _props2.drawPickingColors,\n          layerFilter = _props2.layerFilter; // Update viewports (creating one if not supplied)\n\n      var viewports = props.viewports || props.viewport;\n\n      if (!viewports) {\n        var _props3 = props,\n            width = _props3.width,\n            height = _props3.height,\n            latitude = _props3.latitude,\n            longitude = _props3.longitude,\n            zoom = _props3.zoom,\n            pitch = _props3.pitch,\n            bearing = _props3.bearing;\n        viewports = [new WebMercatorViewport({\n          width: width,\n          height: height,\n          latitude: latitude,\n          longitude: longitude,\n          zoom: zoom,\n          pitch: pitch,\n          bearing: bearing\n        })];\n      } // If more parameters need to be updated on layerManager add them to this method.\n\n\n      this.layerManager.setParameters({\n        layers: layers,\n        viewports: viewports,\n        useDevicePixels: useDevicePixels,\n        drawPickingColors: drawPickingColors,\n        layerFilter: layerFilter,\n        pickingRadius: pickingRadius,\n        onLayerClick: onLayerClick,\n        onLayerHover: onLayerHover\n      }); // TODO - unify setParameters/setOptions/setProps etc naming.\n\n      this.animationLoop.setViewParameters({\n        useDevicePixels: useDevicePixels\n      });\n    }\n  }, {\n    key: 'finalize',\n    value: function finalize() {\n      this.animationLoop.stop();\n      this.animationLoop = null;\n\n      if (this.layerManager) {\n        this.layerManager.finalize();\n        this.layerManager = null;\n      }\n    } // Public API\n\n  }, {\n    key: 'pickObject',\n    value: function pickObject(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          _ref$radius = _ref.radius,\n          radius = _ref$radius === undefined ? 0 : _ref$radius,\n          _ref$layerIds = _ref.layerIds,\n          layerIds = _ref$layerIds === undefined ? null : _ref$layerIds;\n      var selectedInfos = this.layerManager.pickObject({\n        x: x,\n        y: y,\n        radius: radius,\n        layerIds: layerIds,\n        mode: 'query'\n      });\n      return selectedInfos.length ? selectedInfos[0] : null;\n    }\n  }, {\n    key: 'pickObjects',\n    value: function pickObjects(_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y,\n          _ref2$width = _ref2.width,\n          width = _ref2$width === undefined ? 1 : _ref2$width,\n          _ref2$height = _ref2.height,\n          height = _ref2$height === undefined ? 1 : _ref2$height,\n          _ref2$layerIds = _ref2.layerIds,\n          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds;\n      return this.layerManager.pickObjects({\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        layerIds: layerIds\n      });\n    }\n  }, {\n    key: 'getViewports',\n    value: function getViewports() {\n      return this.layerManager ? this.layerManager.getViewports() : [];\n    } // Private Methods\n\n  }, {\n    key: '_createCanvas',\n    value: function _createCanvas(props) {\n      if (props.canvas) {\n        return props.canvas;\n      }\n\n      var id = props.id,\n          width = props.width,\n          height = props.height,\n          style = props.style;\n      var canvas = document.createElement('canvas');\n      canvas.id = id;\n      canvas.width = width;\n      canvas.height = height;\n      canvas.style = style;\n      var parent = props.parent || document.body;\n      parent.appendChild(canvas);\n      return canvas;\n    } // Callbacks\n\n  }, {\n    key: '_onRendererInitialized',\n    value: function _onRendererInitialized(_ref3) {\n      var gl = _ref3.gl,\n          canvas = _ref3.canvas;\n      setParameters(gl, {\n        blend: true,\n        blendFunc: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA],\n        polygonOffsetFill: true,\n        depthTest: true,\n        depthFunc: GL.LEQUAL\n      });\n      this.props.onWebGLInitialized(gl); // Note: avoid React setState due GL animation loop / setState timing issue\n\n      this.layerManager = new LayerManager(gl, {\n        eventManager: new EventManager(canvas)\n      });\n      this.effectManager = new EffectManager({\n        gl: gl,\n        layerManager: this.layerManager\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.props.effects[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var effect = _step.value;\n          this.effectManager.addEffect(effect);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.setProps(this.props);\n    }\n  }, {\n    key: '_onRenderFrame',\n    value: function _onRenderFrame(_ref4) {\n      var gl = _ref4.gl;\n      var redrawReason = this.layerManager.needsRedraw({\n        clearRedrawFlags: true\n      });\n\n      if (!redrawReason) {\n        return;\n      }\n\n      this.props.onBeforeRender({\n        gl: gl\n      }); // TODO - should be called by AnimationLoop\n\n      this.layerManager.drawLayers({\n        pass: 'screen',\n        redrawReason: redrawReason,\n        // Helps debug layer picking, especially in framebuffer powered layers\n        drawPickingColors: this.props.drawPickingColors\n      });\n      this.props.onAfterRender({\n        gl: gl\n      }); // TODO - should be called by AnimationLoop\n    }\n  }]);\n\n  return DeckGLJS;\n}();\n\nexport default DeckGLJS;\nDeckGLJS.propTypes = propTypes;\nDeckGLJS.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}