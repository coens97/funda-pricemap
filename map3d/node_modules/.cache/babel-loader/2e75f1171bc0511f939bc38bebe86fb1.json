{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}(); // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\n\n\nimport mat4_invert from 'gl-mat4/invert';\nimport mat4_multiply from 'gl-mat4/multiply';\nimport vec4_transformMat4 from 'gl-vec4/transformMat4';\nimport assert from 'assert';\nimport { COORDINATE_SYSTEM } from '../../lib/constants';\n\nfunction fp64ify(a) {\n  var hiPart = Math.fround(a);\n  var loPart = a - hiPart;\n  return [hiPart, loPart];\n} // To quickly set a vector to zero\n\n\nvar ZERO_VECTOR = [0, 0, 0, 0]; // 4x4 matrix that drops 4th component of vector\n\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; // The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\n// Uncomment when debugging\n\nfunction calculateMatrixAndOffset(_ref) {\n  var projectionMode = _ref.projectionMode,\n      positionOrigin = _ref.positionOrigin,\n      viewport = _ref.viewport;\n  var viewMatrixUncentered = viewport.viewMatrixUncentered,\n      projectionMatrix = viewport.projectionMatrix;\n  var viewMatrix = viewport.viewMatrix,\n      viewProjectionMatrix = viewport.viewProjectionMatrix;\n  var projectionCenter = void 0;\n\n  switch (projectionMode) {\n    case COORDINATE_SYSTEM.IDENTITY:\n    case COORDINATE_SYSTEM.LNGLAT:\n      projectionCenter = ZERO_VECTOR;\n      break;\n    // TODO: make lighitng work for meter offset mode\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      // Calculate transformed projectionCenter (in 64 bit precision)\n      // This is the key to offset mode precision (avoids doing this\n      // addition in 32 bit precision)\n      var positionPixels = viewport.projectFlat(positionOrigin); // projectionCenter = new Matrix4(viewProjectionMatrix)\n      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n\n      projectionCenter = vec4_transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix); // Always apply uncentered projection matrix if available (shader adds center)\n      // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n\n      viewMatrix = mat4_multiply([], viewMatrixUncentered || viewMatrix, VECTOR_TO_POINT_MATRIX);\n      viewProjectionMatrix = mat4_multiply([], projectionMatrix, viewMatrix);\n      break;\n\n    default:\n      throw new Error('Unknown projection mode');\n  }\n\n  var viewMatrixInv = mat4_invert([], viewMatrix) || viewMatrix;\n  var cameraPos = [viewMatrixInv[12], viewMatrixInv[13], viewMatrixInv[14]];\n  return {\n    viewMatrix: viewMatrix,\n    viewProjectionMatrix: viewProjectionMatrix,\n    projectionCenter: projectionCenter,\n    cameraPos: cameraPos\n  };\n}\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\n\n\nexport function getUniformsFromViewport() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      viewport = _ref2.viewport,\n      _ref2$modelMatrix = _ref2.modelMatrix,\n      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,\n      _ref2$projectionMode = _ref2.projectionMode,\n      projectionMode = _ref2$projectionMode === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref2$projectionMode,\n      _ref2$positionOrigin = _ref2.positionOrigin,\n      positionOrigin = _ref2$positionOrigin === undefined ? [0, 0] : _ref2$positionOrigin;\n\n  if (!viewport) {\n    return {};\n  }\n\n  assert(viewport.scale, 'Viewport scale missing');\n\n  var _calculateMatrixAndOf = calculateMatrixAndOffset({\n    projectionMode: projectionMode,\n    positionOrigin: positionOrigin,\n    viewport: viewport\n  }),\n      projectionCenter = _calculateMatrixAndOf.projectionCenter,\n      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,\n      cameraPos = _calculateMatrixAndOf.cameraPos; // Calculate projection pixels per unit\n\n\n  var _viewport$getDistance = viewport.getDistanceScales(),\n      pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;\n\n  assert(pixelsPerMeter, 'Viewport missing pixelsPerMeter'); // \"Float64Array\"\n  // Transpose the projection matrix to column major for GLSL.\n\n  var glProjectionMatrixFP64 = new Float32Array(32);\n\n  for (var i = 0; i < 4; ++i) {\n    for (var j = 0; j < 4; ++j) {\n      var _fp64ify = fp64ify(viewProjectionMatrix[j * 4 + i]);\n\n      var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n      glProjectionMatrixFP64[(i * 4 + j) * 2] = _fp64ify2[0];\n      glProjectionMatrixFP64[(i * 4 + j) * 2 + 1] = _fp64ify2[1];\n    }\n  }\n\n  var devicePixelRatio = window && window.devicePixelRatio || 1;\n  return {\n    // Projection mode values\n    projectionMode: projectionMode,\n    projectionCenter: projectionCenter,\n    // Screen size\n    viewportSize: [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio],\n    devicePixelRatio: devicePixelRatio,\n    // Main projection matrices\n    modelMatrix: new Float32Array(modelMatrix || IDENTITY_MATRIX),\n    // viewMatrix: new Float32Array(viewMatrix),\n    projectionMatrix: new Float32Array(viewProjectionMatrix),\n    projectionFP64: glProjectionMatrixFP64,\n    projectionPixelsPerUnit: pixelsPerMeter,\n    projectionScale: viewport.scale,\n    // This is the mercator scale (2 ** zoom)\n    projectionScaleFP64: fp64ify(viewport.scale),\n    // Deprecated?\n    // This is for lighting calculations\n    cameraPos: new Float32Array(cameraPos)\n  };\n}","map":null,"metadata":{},"sourceType":"module"}