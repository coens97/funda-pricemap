{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/* global window, setTimeout, clearTimeout */\n\n\nimport { isBrowser } from '../utils';\nimport { getPageLoadPromise, resizeDrawingBuffer } from '../webgl-utils';\nimport { createGLContext, deleteGLContext, isWebGL, resetParameters } from '../webgl';\nimport { Framebuffer } from '../webgl'; // Node.js polyfills for requestAnimationFrame and cancelAnimationFrame\n\nexport function requestAnimationFrame(callback) {\n  return isBrowser ? window.requestAnimationFrame(callback) : setTimeout(callback, 1000 / 60);\n}\nexport function cancelAnimationFrame(timerId) {\n  return isBrowser ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);\n}\n\nvar AnimationLoop =\n/*#__PURE__*/\nfunction () {\n  /*\n   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n   */\n  function AnimationLoop() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$onCreateContext = _ref.onCreateContext,\n        onCreateContext = _ref$onCreateContext === undefined ? function (opts) {\n      return createGLContext(opts);\n    } : _ref$onCreateContext,\n        _ref$onDeleteContext = _ref.onDeleteContext,\n        onDeleteContext = _ref$onDeleteContext === undefined ? function (gl) {\n      return deleteGLContext(gl);\n    } : _ref$onDeleteContext,\n        _ref$onInitialize = _ref.onInitialize,\n        onInitialize = _ref$onInitialize === undefined ? function () {} : _ref$onInitialize,\n        _ref$onRender = _ref.onRender,\n        onRender = _ref$onRender === undefined ? function () {} : _ref$onRender,\n        _ref$onFinalize = _ref.onFinalize,\n        onFinalize = _ref$onFinalize === undefined ? function () {} : _ref$onFinalize,\n        _ref$gl = _ref.gl,\n        gl = _ref$gl === undefined ? null : _ref$gl,\n        _ref$glOptions = _ref.glOptions,\n        glOptions = _ref$glOptions === undefined ? {\n      preserveDrawingBuffer: true\n    } : _ref$glOptions,\n        _ref$width = _ref.width,\n        width = _ref$width === undefined ? null : _ref$width,\n        _ref$height = _ref.height,\n        height = _ref$height === undefined ? null : _ref$height,\n        _ref$autoResizeViewpo = _ref.autoResizeViewport,\n        autoResizeViewport = _ref$autoResizeViewpo === undefined ? true : _ref$autoResizeViewpo,\n        _ref$autoResizeCanvas = _ref.autoResizeCanvas,\n        autoResizeCanvas = _ref$autoResizeCanvas === undefined ? true : _ref$autoResizeCanvas,\n        _ref$autoResizeDrawin = _ref.autoResizeDrawingBuffer,\n        autoResizeDrawingBuffer = _ref$autoResizeDrawin === undefined ? true : _ref$autoResizeDrawin,\n        _ref$useDevicePixelRa = _ref.useDevicePixelRatio,\n        useDevicePixelRatio = _ref$useDevicePixelRa === undefined ? true : _ref$useDevicePixelRa;\n\n    _classCallCheck(this, AnimationLoop);\n\n    this.start = this.start.bind(this);\n    this.stop = this.stop.bind(this);\n    this._renderFrame = this._renderFrame.bind(this);\n    this.setViewParameters({\n      autoResizeViewport: autoResizeViewport,\n      autoResizeCanvas: autoResizeCanvas,\n      autoResizeDrawingBuffer: autoResizeDrawingBuffer,\n      useDevicePixelRatio: useDevicePixelRatio\n    });\n    this._onCreateContext = onCreateContext;\n    this.glOptions = glOptions;\n    this._onInitialize = onInitialize;\n    this._onRender = onRender;\n    this._onFinalize = onFinalize;\n    this.width = width;\n    this.height = height;\n    this.gl = gl;\n    return this;\n  } // Update parameters (TODO - should these be specified in `start`?)\n\n\n  _createClass(AnimationLoop, [{\n    key: 'setViewParameters',\n    value: function setViewParameters(_ref2) {\n      var _ref2$autoResizeDrawi = _ref2.autoResizeDrawingBuffer,\n          autoResizeDrawingBuffer = _ref2$autoResizeDrawi === undefined ? true : _ref2$autoResizeDrawi,\n          _ref2$autoResizeCanva = _ref2.autoResizeCanvas,\n          autoResizeCanvas = _ref2$autoResizeCanva === undefined ? true : _ref2$autoResizeCanva,\n          _ref2$autoResizeViewp = _ref2.autoResizeViewport,\n          autoResizeViewport = _ref2$autoResizeViewp === undefined ? true : _ref2$autoResizeViewp,\n          _ref2$useDevicePixelR = _ref2.useDevicePixelRatio,\n          useDevicePixelRatio = _ref2$useDevicePixelR === undefined ? true : _ref2$useDevicePixelR;\n      this.autoResizeViewport = autoResizeViewport;\n      this.autoResizeCanvas = autoResizeCanvas;\n      this.autoResizeDrawingBuffer = autoResizeDrawingBuffer;\n      this.useDevicePixelRatio = useDevicePixelRatio;\n      return this;\n    } // Starts a render loop if not already running\n    // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)\n\n  }, {\n    key: 'start',\n    value: function start() {\n      var _this = this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._stopped = false; // console.debug(`Starting ${this.constructor.name}`);\n\n      if (!this._animationFrameId) {\n        // Wait for start promise before rendering frame\n        this._startPromise = getPageLoadPromise().then(function () {\n          if (_this._stopped) {\n            return null;\n          } // Create the WebGL context\n\n\n          _this._createWebGLContext(opts); // Initialize the callback data\n\n\n          _this._initializeCallbackData();\n\n          _this._updateCallbackData(); // Default viewport setup, in case onInitialize wants to render\n\n\n          _this._resizeCanvasDrawingBuffer();\n\n          _this._resizeViewport(); // Note: onIntialize can return a promise (in case it needs to load resources)\n\n\n          return _this._onInitialize(_this._callbackData);\n        }).then(function (appContext) {\n          if (!_this._stopped) {\n            _this._addCallbackData(appContext || {});\n\n            if (appContext !== false && !_this._animationFrameId) {\n              _this._animationFrameId = requestAnimationFrame(_this._renderFrame);\n            }\n          }\n        });\n      }\n\n      return this;\n    } // Stops a render loop if already running, finalizing\n\n  }, {\n    key: 'stop',\n    value: function stop() {\n      // console.debug(`Stopping ${this.constructor.name}`);\n      if (this._animationFrameId) {\n        this._finalizeCallbackData();\n\n        cancelAnimationFrame(this._animationFrameId);\n        this._animationFrameId = null;\n        this._stopped = true;\n      }\n\n      return this;\n    } // PRIVATE METHODS\n\n  }, {\n    key: '_setupFrame',\n    value: function _setupFrame() {\n      if (this._onSetupFrame) {\n        // call callback\n        this._onSetupFrame(this._callbackData); // end callback\n\n      } else {\n        this._resizeCanvasDrawingBuffer();\n\n        this._resizeViewport();\n\n        this._resizeFramebuffer();\n      }\n    }\n    /**\n     * @private\n     * Handles a render loop frame- updates context and calls the application\n     * callback\n     */\n\n  }, {\n    key: '_renderFrame',\n    value: function _renderFrame() {\n      this._setupFrame();\n\n      this._updateCallbackData(); // call callback\n\n\n      this._onRender(this._callbackData); // end callback\n      // Increment tick\n\n\n      this._callbackData.tick++; // Request another render frame (now )\n\n      this._animationFrameId = requestAnimationFrame(this._renderFrame);\n    } // Initialize the  object that will be passed to app callbacks\n\n  }, {\n    key: '_initializeCallbackData',\n    value: function _initializeCallbackData() {\n      this._callbackData = {\n        gl: this.gl,\n        canvas: this.gl.canvas,\n        framebuffer: this.framebuffer,\n        stop: this.stop,\n        // Initial values\n        tick: 0,\n        tock: 0\n      };\n    } // Update the context object that will be passed to app callbacks\n\n  }, {\n    key: '_updateCallbackData',\n    value: function _updateCallbackData() {\n      // CallbackData width and height represent drawing buffer width and height\n      var canvas = this.gl.canvas;\n      this._callbackData.width = canvas.width;\n      this._callbackData.height = canvas.height;\n      this._callbackData.aspect = canvas.width / canvas.height;\n    }\n  }, {\n    key: '_finalizeCallbackData',\n    value: function _finalizeCallbackData() {\n      // call callback\n      this._onFinalize(this._callbackData); // end callback\n\n    } // Add application's data to the app context object\n\n  }, {\n    key: '_addCallbackData',\n    value: function _addCallbackData(appContext) {\n      if ((typeof appContext === 'undefined' ? 'undefined' : _typeof(appContext)) === 'object' && appContext !== null) {\n        this._callbackData = Object.assign({}, this._callbackData, appContext);\n      }\n    } // Either uses supplied or existing context, or calls provided callback to create one\n\n  }, {\n    key: '_createWebGLContext',\n    value: function _createWebGLContext(opts) {\n      // Create the WebGL context if necessary\n      opts = Object.assign({}, opts, this.glOptions);\n\n      if (opts.gl) {\n        this.gl = opts.gl;\n      } else {\n        this.gl = this._onCreateContext(opts);\n      }\n\n      if (!isWebGL(this.gl)) {\n        throw new Error('AnimationLoop.onCreateContext - illegal context returned');\n      } // Setup default framebuffer\n\n\n      this.framebuffer = new Framebuffer(this.gl); // Reset the WebGL context.\n\n      resetParameters(this.gl);\n    } // Default viewport setup\n\n  }, {\n    key: '_resizeViewport',\n    value: function _resizeViewport() {\n      if (this.autoResizeViewport) {\n        this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      }\n    }\n  }, {\n    key: '_resizeFramebuffer',\n    value: function _resizeFramebuffer() {\n      this.framebuffer.resize({\n        width: this.gl.canvas.width,\n        height: this.gl.canvas.height\n      });\n    } // Resize the render buffer of the canvas to match canvas client size\n    // Optionally multiplying with devicePixel ratio\n\n  }, {\n    key: '_resizeCanvasDrawingBuffer',\n    value: function _resizeCanvasDrawingBuffer() {\n      if (this.autoResizeDrawingBuffer) {\n        resizeDrawingBuffer(this.gl.canvas, {\n          useDevicePixelRatio: this.useDevicePixelRatio\n        });\n      }\n    }\n  }]);\n\n  return AnimationLoop;\n}();\n\nexport default AnimationLoop;","map":null,"metadata":{},"sourceType":"module"}