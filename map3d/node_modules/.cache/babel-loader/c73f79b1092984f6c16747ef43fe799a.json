{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _UNIFORM_TYPES;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/* eslint-disable camelcase */\n\n\nimport assert from 'assert';\nvar ERR_ARGUMENT = 'UniformBufferLayout illegal argument'; // Local constants - these will \"collapse\" during minification\n\nvar GL_INT = 0x1404;\nvar GL_INT_VEC2 = 0x8B53;\nvar GL_INT_VEC3 = 0x8B54;\nvar GL_INT_VEC4 = 0x8B55;\nvar GL_FLOAT = 0x1406;\nvar GL_FLOAT_VEC2 = 0x8B50;\nvar GL_FLOAT_VEC3 = 0x8B51;\nvar GL_FLOAT_VEC4 = 0x8B52;\nvar GL_BOOL = 0x8B56;\nvar GL_BOOL_VEC2 = 0x8B57;\nvar GL_BOOL_VEC3 = 0x8B58;\nvar GL_BOOL_VEC4 = 0x8B59;\nvar GL_UNSIGNED_INT = 0x1405;\nvar GL_UNSIGNED_INT_VEC2 = 0x8DC6;\nvar GL_UNSIGNED_INT_VEC3 = 0x8DC7;\nvar GL_UNSIGNED_INT_VEC4 = 0x8DC8;\nvar GL_FLOAT_MAT2 = 0x8B5A;\nvar GL_FLOAT_MAT3 = 0x8B5B;\nvar GL_FLOAT_MAT4 = 0x8B5C;\nvar GL_FLOAT_MAT2x3 = 0x8B65;\nvar GL_FLOAT_MAT2x4 = 0x8B66;\nvar GL_FLOAT_MAT3x2 = 0x8B67;\nvar GL_FLOAT_MAT3x4 = 0x8B68;\nvar GL_FLOAT_MAT4x2 = 0x8B69;\nvar GL_FLOAT_MAT4x3 = 0x8B6A; // Uniform table for std140\n\nvar UNIFORM_TYPES = (_UNIFORM_TYPES = {}, _defineProperty(_UNIFORM_TYPES, GL_FLOAT, [GL_FLOAT, 1]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC2, [GL_FLOAT, 2]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC3, [GL_FLOAT, 3]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_VEC4, [GL_FLOAT, 4]), _defineProperty(_UNIFORM_TYPES, GL_INT, [GL_INT, 1]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC2, [GL_INT, 2]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC3, [GL_INT, 3]), _defineProperty(_UNIFORM_TYPES, GL_INT_VEC4, [GL_INT, 4]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT, [GL_UNSIGNED_INT, 1]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC2, [GL_UNSIGNED_INT, 2]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC3, [GL_UNSIGNED_INT, 3]), _defineProperty(_UNIFORM_TYPES, GL_UNSIGNED_INT_VEC4, [GL_UNSIGNED_INT, 4]), _defineProperty(_UNIFORM_TYPES, GL_BOOL, [GL_FLOAT, 1]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC2, [GL_FLOAT, 2]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC3, [GL_FLOAT, 3]), _defineProperty(_UNIFORM_TYPES, GL_BOOL_VEC4, [GL_FLOAT, 4]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2x3, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT2x4, [GL_FLOAT, 8]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3x2, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT3x4, [GL_FLOAT, 12]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4, [GL_FLOAT, 16]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4x2, [GL_FLOAT, 16]), _defineProperty(_UNIFORM_TYPES, GL_FLOAT_MAT4x3, [GL_FLOAT, 16]), _UNIFORM_TYPES); // Std140 layout for uniforms\n\nvar UniformBufferLayout =\n/*#__PURE__*/\nfunction () {\n  function UniformBufferLayout(layout) {\n    var _typedArray;\n\n    _classCallCheck(this, UniformBufferLayout);\n\n    this.layout = {};\n    this.size = 0; // Add layout (type, size and offset) definitions for each uniform in the layout\n\n    for (var key in layout) {\n      this._addUniform(key, layout[key]);\n    } // Allocate three typed arrays pointing at same memory\n\n\n    var data = new Float32Array(this.size);\n    this.typedArray = (_typedArray = {}, _defineProperty(_typedArray, GL_FLOAT, data), _defineProperty(_typedArray, GL_INT, new Int32Array(data.buffer)), _defineProperty(_typedArray, GL_UNSIGNED_INT, new Uint32Array(data.buffer)), _typedArray);\n  } // Get number of bytes needed for buffer allocation\n\n\n  _createClass(UniformBufferLayout, [{\n    key: 'getBytes',\n    value: function getBytes() {\n      return this.size * 4;\n    } // Get the current data as Float32Array, for bufferSubData\n\n  }, {\n    key: 'getData',\n    value: function getData() {\n      return this.typedArray[GL_FLOAT];\n    } // Get offset and data for one object (for bufferSubData)\n\n  }, {\n    key: 'getSubData',\n    value: function getSubData(index) {\n      var data = void 0;\n      var offset = void 0;\n\n      if (index === undefined) {\n        data = this.data;\n        offset = 0;\n      } else {\n        var begin = this.offsets[index];\n        var end = begin + this.sizes[index];\n        data = this.data.subarray(begin, end);\n        offset = begin * 4;\n      }\n\n      return {\n        data: data,\n        offset: offset\n      };\n    } // Set a map of values\n\n  }, {\n    key: 'setUniforms',\n    value: function setUniforms(values) {\n      for (var key in values) {\n        this._setValue(key, values[key]);\n      }\n\n      return this;\n    }\n  }, {\n    key: '_setValue',\n    value: function _setValue(key, value) {\n      var layout = this.layout[key];\n      assert(layout, 'UniformLayoutStd140 illegal argument');\n      var typedArray = this.typedArray[layout.type];\n\n      if (layout.size === 1) {\n        // single value -> just set it\n        typedArray[layout.offset] = value;\n      } else {\n        // vector/matrix -> copy the supplied (typed) array, starting from offset\n        typedArray.set(value, layout.offset);\n      }\n    }\n  }, {\n    key: '_addUniform',\n    value: function _addUniform(key, uniformType) {\n      var definition = UNIFORM_TYPES[uniformType];\n      assert(definition, ERR_ARGUMENT);\n\n      var _definition = _slicedToArray(definition, 2),\n          type = _definition[0],\n          count = _definition[1]; // Get the current offset and calculate the next offset based on aligned size of this element\n\n\n      var offset = this.size; // First, align (bump) current offset to an even multiple of current object (1, 2, 4)\n\n      this.size = this._alignTo(this.size, count); // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset\n\n      this.size += count;\n      this.layout[key] = {\n        type: type,\n        size: count,\n        offset: offset\n      };\n    } // Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes)\n\n  }, {\n    key: '_alignTo',\n    value: function _alignTo(size, count) {\n      switch (count) {\n        case 1:\n          return size;\n        // Pad upwards to even multiple of 2\n\n        case 2:\n          return size + size % 2;\n        // Pad upwards to even multiple of 2\n\n        default:\n          return size + (4 - size % 4) % 4;\n        // Pad upwards to even multiple of 4\n      }\n    }\n  }]);\n\n  return UniformBufferLayout;\n}();\n\nexport default UniformBufferLayout;","map":null,"metadata":{},"sourceType":"module"}