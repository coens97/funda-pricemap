{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport { window } from '../globals';\nvar ua = typeof window.navigator !== 'undefined' ? window.navigator.userAgent.toLowerCase() : '';\nvar firefox = ua.indexOf('firefox') !== -1;\nvar WHEEL_EVENTS = [// Chrome, Safari\n'wheel', // IE\n'mousewheel', // legacy Firefox\n'DOMMouseScroll'];\nvar EVENT_TYPE = 'wheel'; // Constants for normalizing input delta\n\nvar WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nvar WHEEL_DELTA_PER_LINE = 40;\nvar TRACKPAD_MAX_DELTA = 4;\nvar TRACKPAD_MAX_DELTA_PER_TIME = 200; // Slow down zoom if shift key is held for more precise zooming\n\nvar SHIFT_MULTIPLIER = 0.25;\n\nvar WheelInput = function () {\n  function WheelInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, WheelInput);\n\n    this.element = element;\n    this.callback = callback;\n    var events = WHEEL_EVENTS.concat(options.events || []);\n    this.options = Object.assign({\n      enable: true\n    }, options, {\n      events: events\n    });\n    this.time = 0;\n    this.wheelPosition = null;\n    this.type = null;\n    this.timeout = null;\n    this.lastValue = 0;\n    this.handleEvent = this.handleEvent.bind(this);\n    this.options.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n  }\n\n  _createClass(WheelInput, [{\n    key: 'destroy',\n    value: function destroy() {\n      var _this2 = this;\n\n      this.options.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: 'set',\n    value: function set(options) {\n      Object.assign(this.options, options);\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n\n  }, {\n    key: 'toggleIfEventSupported',\n    value: function toggleIfEventSupported(eventType, enabled) {\n      if (eventType === EVENT_TYPE) {\n        this.options.enable = enabled;\n      }\n    }\n    /* eslint-disable complexity, max-statements */\n\n  }, {\n    key: 'handleEvent',\n    value: function handleEvent(event) {\n      if (!this.options.enable) {\n        return;\n      }\n\n      event.preventDefault();\n      var value = event.deltaY;\n\n      if (window.WheelEvent) {\n        // Firefox doubles the values on retina screens...\n        if (firefox && event.deltaMode === window.WheelEvent.DOM_DELTA_PIXEL) {\n          value /= window.devicePixelRatio;\n        }\n\n        if (event.deltaMode === window.WheelEvent.DOM_DELTA_LINE) {\n          value *= WHEEL_DELTA_PER_LINE;\n        }\n      }\n\n      var type = this.type,\n          timeout = this.timeout,\n          lastValue = this.lastValue,\n          time = this.time;\n      var now = (window && window.performance || Date).now();\n      var timeDelta = now - (time || 0);\n      this.wheelPosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      time = now;\n\n      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n        // This one is definitely a mouse wheel event.\n        type = 'wheel'; // Normalize this value to match trackpad.\n\n        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n      } else if (value !== 0 && Math.abs(value) < TRACKPAD_MAX_DELTA) {\n        // This one is definitely a trackpad event because it is so small.\n        type = 'trackpad';\n      } else if (timeDelta > 400) {\n        // This is likely a new scroll action.\n        type = null;\n        lastValue = value; // Start a timeout in case this was a singular event,\n        // and delay it by up to 40ms.\n\n        timeout = window.setTimeout(function setTimeout() {\n          this._onWheel(event, -lastValue, this.wheelPosition);\n\n          type = 'wheel';\n        }.bind(this), 40);\n      } else if (!type) {\n        // This is a repeating event, but we don't know the type of event just yet.\n        // If the delta per time is small, we assume it's a fast trackpad;\n        // otherwise we switch into wheel mode.\n        type = Math.abs(timeDelta * value) < TRACKPAD_MAX_DELTA_PER_TIME ? 'trackpad' : 'wheel'; // Make sure our delayed event isn't fired again, because we accumulate\n        // the previous event (which was less than 40ms ago) into this event.\n\n        if (timeout) {\n          window.clearTimeout(timeout);\n          timeout = null;\n          value += lastValue;\n        }\n      }\n\n      if (event.shiftKey && value) {\n        value = value * SHIFT_MULTIPLIER;\n      } // Only fire the callback if we actually know\n      // what type of scrolling device the user uses.\n\n\n      if (type) {\n        this._onWheel(event, -value, this.wheelPosition);\n      }\n    }\n  }, {\n    key: '_onWheel',\n    value: function _onWheel(srcEvent, delta, position) {\n      this.callback({\n        type: EVENT_TYPE,\n        center: position,\n        delta: delta,\n        srcEvent: srcEvent,\n        pointerType: 'mouse',\n        target: srcEvent.target\n      });\n    }\n  }]);\n\n  return WheelInput;\n}();\n\nexport default WheelInput;","map":null,"metadata":{},"sourceType":"module"}