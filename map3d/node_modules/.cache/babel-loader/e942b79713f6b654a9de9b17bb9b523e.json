{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport GL from '../../constants';\nimport Buffer from '../../webgl/buffer';\nimport TransformFeedback from '../../webgl/transform-feedback';\nimport Model from '../model';\nimport { isWebGL2, assertWebGL2Context } from '../../webgl-utils';\nimport assert from '../../utils/assert';\nimport { log } from '../../utils';\nvar PASS_THROUGH_FS = \"void main()\\n{\\n}\\n\";\n\nvar Transform =\n/*#__PURE__*/\nfunction () {\n  _createClass(Transform, null, [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      // For now WebGL2 only\n      return isWebGL2(gl);\n    }\n  }]);\n\n  function Transform(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Transform);\n\n    assertWebGL2Context(gl);\n    this.gl = gl;\n    this.model = null;\n    this._buffersSwapable = false;\n    this.currentIndex = 0;\n    this.sourceBuffers = new Array(2);\n    this.destinationBuffers = new Array(2);\n    this.transformFeedbacks = new Array(2);\n    this._buffersToDelete = [];\n    this.initialize(opts);\n    Object.seal(this);\n  } // Delete owned resources.\n\n\n  _createClass(Transform, [{\n    key: \"delete\",\n    value: function _delete() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._buffersToDelete[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var buffer = _step.value;\n          buffer.delete();\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.model.delete();\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize(_ref) {\n      var _ref$sourceBuffers = _ref.sourceBuffers,\n          sourceBuffers = _ref$sourceBuffers === void 0 ? null : _ref$sourceBuffers,\n          _ref$destinationBuffe = _ref.destinationBuffers,\n          destinationBuffers = _ref$destinationBuffe === void 0 ? null : _ref$destinationBuffe,\n          _ref$vs = _ref.vs,\n          vs = _ref$vs === void 0 ? null : _ref$vs,\n          _ref$sourceDestinatio = _ref.sourceDestinationMap,\n          sourceDestinationMap = _ref$sourceDestinatio === void 0 ? null : _ref$sourceDestinatio,\n          _ref$varyings = _ref.varyings,\n          varyings = _ref$varyings === void 0 ? null : _ref$varyings,\n          _ref$drawMode = _ref.drawMode,\n          drawMode = _ref$drawMode === void 0 ? GL.POINTS : _ref$drawMode,\n          _ref$elementCount = _ref.elementCount,\n          elementCount = _ref$elementCount === void 0 ? null : _ref$elementCount;\n      assert(sourceBuffers && vs && varyings && elementCount); // If destinationBuffers are not provided, sourceDestinationMap must be provided\n      // to create destinaitonBuffers with layout of corresponding source buffer.\n\n      assert(destinationBuffers || sourceDestinationMap);\n\n      if (sourceDestinationMap) {\n        this.sourceDestinationMap = sourceDestinationMap;\n        this._buffersSwapable = true;\n      }\n\n      var index = 0;\n      this.varyings = [];\n      this.varyingMap = {};\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = varyings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var varying = _step2.value;\n          this.varyings[index] = varying;\n          this.varyingMap[varying] = index;\n          index++;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this._bindBuffers({\n        sourceBuffers: sourceBuffers,\n        destinationBuffers: destinationBuffers\n      });\n\n      this._buildModel({\n        vs: vs,\n        drawMode: drawMode,\n        elementCount: elementCount\n      });\n    } // Update some or all buffer bindings.\n\n  }, {\n    key: \"update\",\n    value: function update(_ref2) {\n      var _ref2$sourceBuffers = _ref2.sourceBuffers,\n          sourceBuffers = _ref2$sourceBuffers === void 0 ? null : _ref2$sourceBuffers,\n          _ref2$destinationBuff = _ref2.destinationBuffers,\n          destinationBuffers = _ref2$destinationBuff === void 0 ? null : _ref2$destinationBuff,\n          _ref2$elementCount = _ref2.elementCount,\n          elementCount = _ref2$elementCount === void 0 ? this.elementCount : _ref2$elementCount;\n\n      if (!sourceBuffers && !destinationBuffers) {\n        log.warn('Transform : no buffers updated')();\n        return this;\n      }\n\n      this.model.setVertexCount(elementCount);\n      var currentIndex = this.currentIndex,\n          varyingMap = this.varyingMap,\n          _buffersSwapable = this._buffersSwapable,\n          transformFeedbacks = this.transformFeedbacks;\n\n      for (var bufferName in destinationBuffers) {\n        assert(_instanceof(destinationBuffers[bufferName], Buffer));\n      }\n\n      Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);\n      Object.assign(this.destinationBuffers[currentIndex], destinationBuffers);\n      transformFeedbacks[currentIndex].bindBuffers(this.destinationBuffers[currentIndex], {\n        varyingMap: varyingMap\n      });\n\n      if (_buffersSwapable) {\n        var nextIndex = (currentIndex + 1) % 2;\n\n        for (var sourceBufferName in this.sourceDestinationMap) {\n          var destinationBufferName = this.sourceDestinationMap[sourceBufferName];\n          this.sourceBuffers[nextIndex][sourceBufferName] = this.destinationBuffers[currentIndex][destinationBufferName];\n          this.destinationBuffers[nextIndex][destinationBufferName] = this.sourceBuffers[currentIndex][sourceBufferName]; // make sure the new destination buffer is a Buffer object\n\n          assert(_instanceof(this.destinationBuffers[nextIndex][destinationBufferName], Buffer));\n        }\n\n        transformFeedbacks[nextIndex].bindBuffers(this.destinationBuffers[nextIndex], {\n          varyingMap: varyingMap\n        });\n      }\n\n      return this;\n    } // Run one transformfeedback loop.\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$uniforms = _ref3.uniforms,\n          uniforms = _ref3$uniforms === void 0 ? {} : _ref3$uniforms;\n\n      var model = this.model,\n          transformFeedbacks = this.transformFeedbacks,\n          sourceBuffers = this.sourceBuffers,\n          currentIndex = this.currentIndex;\n      model.setAttributes(sourceBuffers[currentIndex]);\n      model.draw({\n        transformFeedback: transformFeedbacks[currentIndex],\n        uniforms: uniforms,\n        parameters: _defineProperty({}, GL.RASTERIZER_DISCARD, true)\n      });\n    } // Swap source and destination buffers.\n\n  }, {\n    key: \"swapBuffers\",\n    value: function swapBuffers() {\n      assert(this._buffersSwapable);\n      this.currentIndex = (this.currentIndex + 1) % 2;\n    } // Return Buffer object for given varying name.\n\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var destinationBuffers = this.destinationBuffers,\n          currentIndex = this.currentIndex;\n      assert(varyingName && destinationBuffers[currentIndex][varyingName]);\n      return destinationBuffers[currentIndex][varyingName];\n    } // Private\n    // build source and destination buffers\n\n  }, {\n    key: \"_bindBuffers\",\n    value: function _bindBuffers(_ref4) {\n      var _ref4$sourceBuffers = _ref4.sourceBuffers,\n          sourceBuffers = _ref4$sourceBuffers === void 0 ? null : _ref4$sourceBuffers,\n          _ref4$destinationBuff = _ref4.destinationBuffers,\n          destinationBuffers = _ref4$destinationBuff === void 0 ? null : _ref4$destinationBuff;\n      var _buffersSwapable = this._buffersSwapable;\n\n      for (var bufferName in destinationBuffers) {\n        assert(_instanceof(destinationBuffers[bufferName], Buffer));\n      }\n\n      this.sourceBuffers[0] = Object.assign({}, sourceBuffers);\n      this.destinationBuffers[0] = Object.assign({}, destinationBuffers);\n\n      if (_buffersSwapable) {\n        this.sourceBuffers[1] = {};\n        this.destinationBuffers[1] = {};\n\n        for (var sourceBufferName in this.sourceDestinationMap) {\n          var destinationBufferName = this.sourceDestinationMap[sourceBufferName];\n\n          if (!this.destinationBuffers[0][destinationBufferName]) {\n            // Create new buffer with same layout and settings as source buffer\n            var sourceBuffer = this.sourceBuffers[0][sourceBufferName];\n            var bytes = sourceBuffer.bytes,\n                type = sourceBuffer.type,\n                usage = sourceBuffer.usage,\n                layout = sourceBuffer.layout;\n            this.destinationBuffers[0][destinationBufferName] = new Buffer(this.gl, {\n              bytes: bytes,\n              type: type,\n              usage: usage,\n              layout: layout\n            });\n\n            this._buffersToDelete.push(this.destinationBuffers[0][destinationBufferName]);\n          }\n\n          this.sourceBuffers[1][sourceBufferName] = this.destinationBuffers[0][destinationBufferName];\n          this.destinationBuffers[1][destinationBufferName] = this.sourceBuffers[0][sourceBufferName]; // make sure the new destination buffer is a Buffer object\n\n          assert(_instanceof(this.destinationBuffers[1][destinationBufferName], Buffer));\n        }\n      }\n    } // build Model and TransformFeedback objects\n\n  }, {\n    key: \"_buildModel\",\n    value: function _buildModel(_ref5) {\n      var vs = _ref5.vs,\n          drawMode = _ref5.drawMode,\n          elementCount = _ref5.elementCount;\n      var varyings = this.varyings,\n          varyingMap = this.varyingMap,\n          _buffersSwapable = this._buffersSwapable; // Append matching version string to FS.\n\n      var fs = PASS_THROUGH_FS;\n      var vsLines = vs.split('\\n');\n\n      if (vsLines[0].indexOf('#version ') === 0) {\n        fs = \"\".concat(vsLines[0], \"\\n\").concat(PASS_THROUGH_FS, \"\\n\");\n      }\n\n      this.model = new Model(this.gl, {\n        vs: vs,\n        fs: fs,\n        varyings: varyings,\n        drawMode: drawMode,\n        vertexCount: elementCount\n      });\n      this.transformFeedbacks[0] = new TransformFeedback(this.gl, {\n        buffers: this.destinationBuffers[0],\n        varyingMap: varyingMap\n      });\n\n      if (_buffersSwapable) {\n        this.transformFeedbacks[1] = new TransformFeedback(this.gl, {\n          buffers: this.destinationBuffers[1],\n          varyingMap: this.varyingMap\n        });\n      }\n    }\n  }, {\n    key: \"elementCount\",\n    get: function get() {\n      return this.model.getVertexCount();\n    }\n  }]);\n\n  return Transform;\n}();\n\nexport { Transform as default };","map":null,"metadata":{},"sourceType":"module"}