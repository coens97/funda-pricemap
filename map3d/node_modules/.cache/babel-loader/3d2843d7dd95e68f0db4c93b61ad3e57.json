{"ast":null,"code":"// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\nimport { GL, withParameters, setParameters } from 'luma.gl';\nimport { log } from './utils';\nvar EMPTY_PIXEL = new Uint8Array(4);\nvar renderCount = 0;\nexport function drawLayers(_ref) {\n  var layers = _ref.layers,\n      pass = _ref.pass; // render layers in normal colors\n\n  var visibleCount = 0;\n  var compositeCount = 0; // render layers in normal colors\n\n  layers.forEach(function (layer, layerIndex) {\n    if (layer.isComposite) {\n      compositeCount++;\n    } else if (layer.props.visible) {\n      layer.drawLayer({\n        moduleParameters: Object.assign({}, layer.props, {\n          viewport: layer.context.viewport\n        }),\n        uniforms: Object.assign({\n          renderPickingBuffer: 0,\n          pickingEnabled: 0\n        }, layer.context.uniforms, {\n          layerIndex: layerIndex\n        }),\n        parameters: layer.props.parameters || {}\n      });\n      visibleCount++;\n    }\n  });\n  var totalCount = layers.length;\n  var primitiveCount = totalCount - compositeCount;\n  var hiddenCount = primitiveCount - visibleCount;\n  var message = '#' + renderCount++ + ': Rendering ' + visibleCount + ' of ' + totalCount + ' layers ' + pass + ' (' + hiddenCount + ' hidden, ' + compositeCount + ' composite)';\n  log.log(2, message);\n} // Pick all objects within the given bounding box\n\nexport function queryLayers(gl, _ref2) {\n  var layers = _ref2.layers,\n      pickingFBO = _ref2.pickingFBO,\n      x = _ref2.x,\n      y = _ref2.y,\n      width = _ref2.width,\n      height = _ref2.height,\n      viewport = _ref2.viewport,\n      mode = _ref2.mode; // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n\n  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n  var deviceLeft = Math.round(x * pixelRatio);\n  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);\n  var deviceRight = Math.round((x + width) * pixelRatio);\n  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);\n  var pickInfos = getUniquesFromPickingBuffer(gl, {\n    layers: layers,\n    pickingFBO: pickingFBO,\n    deviceRect: {\n      x: deviceLeft,\n      y: deviceTop,\n      width: deviceRight - deviceLeft,\n      height: deviceBottom - deviceTop\n    }\n  }); // Only return unique infos, identified by info.object\n\n  var uniqueInfos = new Map();\n  pickInfos.forEach(function (pickInfo) {\n    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);\n    info.devicePixel = [pickInfo.x, pickInfo.y];\n    info.pixelRatio = pixelRatio;\n    info.color = pickInfo.pickedColor;\n    info.index = pickInfo.pickedObjectIndex;\n    info.picked = true;\n    info = getLayerPickingInfo({\n      layer: pickInfo.pickedLayer,\n      info: info,\n      mode: mode\n    });\n\n    if (!uniqueInfos.has(info.object)) {\n      uniqueInfos.set(info.object, info);\n    }\n  });\n  return Array.from(uniqueInfos.values());\n}\n/* eslint-disable max-depth, max-statements */\n// Pick the closest object at the given (x,y) coordinate\n\nexport function pickLayers(gl, _ref3) {\n  var layers = _ref3.layers,\n      pickingFBO = _ref3.pickingFBO,\n      x = _ref3.x,\n      y = _ref3.y,\n      radius = _ref3.radius,\n      viewport = _ref3.viewport,\n      mode = _ref3.mode,\n      lastPickedInfo = _ref3.lastPickedInfo; // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n\n  var pixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n  var deviceX = Math.round(x * pixelRatio);\n  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);\n  var deviceRadius = Math.round(radius * pixelRatio);\n\n  var _getClosestFromPickin = getClosestFromPickingBuffer(gl, {\n    layers: layers,\n    pickingFBO: pickingFBO,\n    deviceX: deviceX,\n    deviceY: deviceY,\n    deviceRadius: deviceRadius\n  }),\n      pickedColor = _getClosestFromPickin.pickedColor,\n      pickedLayer = _getClosestFromPickin.pickedLayer,\n      pickedObjectIndex = _getClosestFromPickin.pickedObjectIndex;\n\n  var affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n  if (mode === 'hover') {\n    // only invoke onHover events if picked object has changed\n    var lastPickedObjectIndex = lastPickedInfo.index;\n    var lastPickedLayerId = lastPickedInfo.layerId;\n    var pickedLayerId = pickedLayer && pickedLayer.props.id; // proceed only if picked object changed\n\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        var lastPickedLayer = layers.find(function (layer) {\n          return layer.props.id === lastPickedLayerId;\n        });\n\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      } // Update layer manager context\n\n\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n    }\n  }\n\n  var baseInfo = createInfo([x, y], viewport);\n  baseInfo.devicePixel = [deviceX, deviceY];\n  baseInfo.pixelRatio = pixelRatio; // Use a Map to store all picking infos.\n  // The following two forEach loops are the result of\n  // https://github.com/uber/deck.gl/issues/443\n  // Please be very careful when changing this pattern\n\n  var infos = new Map();\n  var unhandledPickInfos = [];\n  affectedLayers.forEach(function (layer) {\n    var info = Object.assign({}, baseInfo);\n\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n\n    info = getLayerPickingInfo({\n      layer: layer,\n      info: info,\n      mode: mode\n    }); // This guarantees that there will be only one copy of info for\n    // one composite layer\n\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n  });\n  infos.forEach(function (info) {\n    var handled = false; // Per-layer event handlers (e.g. onClick, onHover) are provided by the\n    // user and out of deck.gl's control. It's very much possible that\n    // the user calls React lifecycle methods in these function, such as\n    // ReactComponent.setState(). React lifecycle methods sometimes induce\n    // a re-render and re-generation of props of deck.gl and its layers,\n    // which invalidates all layers currently passed to this very function.\n    // Therefore, per-layer event handlers must be invoked at the end\n    // of this function. NO operation that relies on the states of current\n    // layers should be called after this code.\n\n    switch (mode) {\n      case 'click':\n        handled = info.layer.props.onClick(info);\n        break;\n\n      case 'hover':\n        handled = info.layer.props.onHover(info);\n        break;\n\n      case 'query':\n        break;\n\n      default:\n        throw new Error('unknown pick type');\n    }\n\n    if (!handled) {\n      unhandledPickInfos.push(info);\n    }\n  });\n  return unhandledPickInfos;\n}\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\n\nfunction getClosestFromPickingBuffer(gl, _ref4) {\n  var layers = _ref4.layers,\n      pickingFBO = _ref4.pickingFBO,\n      deviceX = _ref4.deviceX,\n      deviceY = _ref4.deviceY,\n      deviceRadius = _ref4.deviceRadius;\n  var closestResultToCenter = {\n    pickedColor: EMPTY_PIXEL,\n    pickedLayer: null,\n    pickedObjectIndex: -1\n  };\n\n  if (deviceX < 0 || deviceY < 0 || deviceX > pickingFBO.width || deviceY > pickingFBO.height || layers.length <= 0) {\n    // x, y out of bounds or no layers to pick.\n    return closestResultToCenter;\n  } // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n\n\n  var x = Math.max(0, deviceX - deviceRadius);\n  var y = Math.max(0, deviceY - deviceRadius);\n  var width = Math.min(pickingFBO.width, deviceX + deviceRadius) - x + 1;\n  var height = Math.min(pickingFBO.height, deviceY + deviceRadius) - y + 1;\n  var pickedColors = getPickedColors(gl, {\n    layers: layers,\n    pickingFBO: pickingFBO,\n    deviceRect: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  }); // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n\n  var minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  var i = 0;\n\n  for (var row = 0; row < height; row++) {\n    for (var col = 0; col < width; col++) {\n      // Decode picked layer from color\n      var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        var dx = col + x - deviceX;\n        var dy = row + y - deviceY;\n        var d2 = dx * dx + dy * dy;\n\n        if (d2 <= minSquareDistanceToCenter) {\n          minSquareDistanceToCenter = d2; // Decode picked object index from color\n\n          var pickedColor = pickedColors.slice(i, i + 4);\n          var pickedLayer = layers[pickedLayerIndex];\n          var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n          closestResultToCenter = {\n            pickedColor: pickedColor,\n            pickedLayer: pickedLayer,\n            pickedObjectIndex: pickedObjectIndex\n          };\n        }\n      }\n\n      i += 4;\n    }\n  }\n\n  return closestResultToCenter;\n}\n/* eslint-enable max-depth, max-statements */\n\n/**\n * Query within a specified rectangle\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\n\n\nfunction getUniquesFromPickingBuffer(gl, _ref5) {\n  var layers = _ref5.layers,\n      pickingFBO = _ref5.pickingFBO,\n      _ref5$deviceRect = _ref5.deviceRect,\n      x = _ref5$deviceRect.x,\n      y = _ref5$deviceRect.y,\n      width = _ref5$deviceRect.width,\n      height = _ref5$deviceRect.height;\n  var pickedColors = getPickedColors(gl, {\n    layers: layers,\n    pickingFBO: pickingFBO,\n    deviceRect: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n  var uniqueColors = new Map(); // Traverse all pixels in picking results and get unique colors\n\n  for (var i = 0; i < pickedColors.length; i += 4) {\n    // Decode picked layer from color\n    var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n    if (pickedLayerIndex >= 0) {\n      var pickedColor = pickedColors.slice(i, i + 4);\n      var colorKey = pickedColor.join(',');\n\n      if (!uniqueColors.has(colorKey)) {\n        var pickedLayer = layers[pickedLayerIndex];\n        uniqueColors.set(colorKey, {\n          pickedColor: pickedColor,\n          pickedLayer: pickedLayer,\n          pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n        });\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n} // Returns an Uint8ClampedArray of picked pixels\n\n\nfunction getPickedColors(gl, _ref6) {\n  var layers = _ref6.layers,\n      pickingFBO = _ref6.pickingFBO,\n      _ref6$deviceRect = _ref6.deviceRect,\n      x = _ref6$deviceRect.x,\n      y = _ref6$deviceRect.y,\n      width = _ref6$deviceRect.width,\n      height = _ref6$deviceRect.height; // Make sure we clear scissor test and fbo bindings in case of exceptions\n  // We are only interested in one pixel, no need to render anything else\n  // Note that the callback here is called synchronously.\n  // Set blend mode for picking\n  // always overwrite existing pixel with [r,g,b,layerIndex]\n\n  return withParameters(gl, {\n    framebuffer: pickingFBO,\n    scissorTest: true,\n    scissor: [x, y, width, height],\n    clearColor: [0, 0, 0, 0]\n  }, function () {\n    // Clear the frame buffer\n    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT); // Render all pickable layers in picking colors\n\n    layers.forEach(function (layer, layerIndex) {\n      if (!layer.isComposite && layer.props.visible && layer.props.pickable) {\n        // Encode layerIndex with alpha\n        setParameters(gl, {\n          blendColor: [0, 0, 0, (layerIndex + 1) / 255]\n        });\n        layer.drawLayer({\n          moduleParameters: Object.assign({}, layer.props, {\n            viewport: layer.context.viewport\n          }),\n          uniforms: Object.assign({\n            renderPickingBuffer: 1,\n            pickingEnabled: 1\n          }, layer.context.uniforms, {\n            layerIndex: layerIndex\n          }),\n          // Blend parameters must not be overriden\n          parameters: Object.assign({}, layer.props.parameters || {}, {\n            blend: true,\n            blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],\n            blendEquation: gl.FUNC_ADD\n          })\n        });\n      }\n    }); // Read color in the central pixel, to be mapped with picking colors\n\n    var pickedColors = new Uint8Array(width * height * 4);\n    gl.readPixels(x, y, width, height, GL.RGBA, GL.UNSIGNED_BYTE, pickedColors);\n    return pickedColors;\n  });\n}\n\nfunction createInfo(pixel, viewport) {\n  // Assign a number of potentially useful props to the \"info\" object\n  return {\n    color: EMPTY_PIXEL,\n    layer: null,\n    index: -1,\n    picked: false,\n    x: pixel[0],\n    y: pixel[1],\n    pixel: pixel,\n    lngLat: viewport.unproject(pixel)\n  };\n} // Walk up the layer composite chain to populate the info object\n\n\nfunction getLayerPickingInfo(_ref7) {\n  var layer = _ref7.layer,\n      info = _ref7.info,\n      mode = _ref7.mode;\n\n  while (layer && info) {\n    // For a composite layer, sourceLayer will point to the sublayer\n    // where the event originates from.\n    // It provides additional context for the composite layer's\n    // getPickingInfo() method to populate the info object\n    var sourceLayer = info.layer || layer;\n    info.layer = layer; // layer.pickLayer() function requires a non-null ```layer.state```\n    // object to funtion properly. So the layer refereced here\n    // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n\n    info = layer.pickLayer({\n      info: info,\n      mode: mode,\n      sourceLayer: sourceLayer\n    });\n    layer = layer.parentLayer;\n  }\n\n  return info;\n}","map":null,"metadata":{},"sourceType":"module"}