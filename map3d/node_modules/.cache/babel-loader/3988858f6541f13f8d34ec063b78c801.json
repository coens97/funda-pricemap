{"ast":null,"code":"// TODO - formatGLSLCompilerError should not depend on this\nimport getShaderName, { getShaderTypeName } from './get-shader-name';\n/**\n * Parse a GLSL compiler error log into a string showing the source code around each error.\n * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)\n */\n\n/* eslint-disable no-continue, max-statements */\n\nexport function parseGLSLCompilerError(errLog, src, shaderType) {\n  var errorStrings = errLog.split(/\\r?\\n/);\n  var errors = {};\n  var warnings = {}; // Parse the error - note: browser and driver dependent\n\n  for (var i = 0; i < errorStrings.length; i++) {\n    var errorString = errorStrings[i];\n\n    if (errorString.length <= 1) {\n      continue;\n    }\n\n    var segments = errorString.split(':');\n    var _type = segments[0];\n    var line = parseInt(segments[2], 10);\n\n    if (isNaN(line)) {\n      throw new Error('Could not parse GLSL compiler error: ' + errLog);\n    }\n\n    if (_type !== 'WARNING') {\n      errors[line] = errorString;\n    } else {\n      warnings[line] = errorString;\n    }\n  } // Format the error inline with the code\n\n\n  var lines = addLineNumbers(src);\n  var name = getShaderName(src) || 'unknown name';\n  var type = getShaderTypeName(shaderType);\n  return {\n    shaderName: type + ' shader ' + name + '\\n',\n    errors: formatErrors(errors, lines),\n    warnings: formatErrors(warnings, lines)\n  };\n} // Formats GLSL compiler error log into single string\n\nexport default function formatGLSLCompilerError(errLog, src, shaderType) {\n  var _parseGLSLCompilerErr = parseGLSLCompilerError(errLog, src, shaderType),\n      shaderName = _parseGLSLCompilerErr.shaderName,\n      errors = _parseGLSLCompilerErr.errors,\n      warnings = _parseGLSLCompilerErr.warnings;\n\n  return 'GLSL compilation error in ' + shaderName + '\\n' + errors + '\\n' + warnings;\n} // helper function, outputs annotated errors or warnings\n\nfunction formatErrors(errors, lines) {\n  var message = '';\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n\n    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {\n      continue;\n    }\n\n    message += line + '\\n';\n\n    if (errors[i + 1]) {\n      var error = errors[i + 1];\n      var segments = error.split(':', 3);\n      var type = segments[0];\n      var column = parseInt(segments[1], 10) || 0;\n      var err = error.substr(segments.join(':').length + 1).trim();\n      message += padLeft('^^^ ' + type + ': ' + err + '\\n\\n', column);\n    }\n  }\n\n  return message;\n}\n/**\n * Prepends line numbers to each line of a string.\n * The line numbers will be left-padded with spaces to ensure an\n * aligned layout when rendered using monospace fonts.\n * @param {String} string - multi-line string to add line numbers to\n * @param {Number} start=1 - number of spaces to add\n * @param {String} delim =': ' - injected between line number and original line\n * @return {String[]} strings - array of string, one per line, with line numbers added\n */\n\n\nfunction addLineNumbers(string) {\n  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ': ';\n  var lines = string.split(/\\r?\\n/);\n  var maxDigits = String(lines.length + start - 1).length;\n  return lines.map(function (line, i) {\n    var lineNumber = i + start;\n    var digits = String(lineNumber).length;\n    var prefix = padLeft(lineNumber, maxDigits - digits);\n    return prefix + delim + line;\n  });\n}\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\n\n\nfunction padLeft(string, digits) {\n  var result = '';\n\n  for (var i = 0; i < digits; ++i) {\n    result += ' ';\n  }\n\n  return '' + result + string;\n}","map":null,"metadata":{},"sourceType":"module"}