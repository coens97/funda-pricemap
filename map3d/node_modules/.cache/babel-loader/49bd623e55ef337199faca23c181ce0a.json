{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Geometry from './geometry';\nimport { uid } from '../utils';\n\nvar SphereGeometry =\n/*#__PURE__*/\nfunction (_Geometry) {\n  _inherits(SphereGeometry, _Geometry);\n\n  function SphereGeometry() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SphereGeometry);\n\n    var _opts$nlat = opts.nlat,\n        nlat = _opts$nlat === void 0 ? 10 : _opts$nlat,\n        _opts$nlong = opts.nlong,\n        nlong = _opts$nlong === void 0 ? 10 : _opts$nlong,\n        _opts$radius = opts.radius,\n        radius = _opts$radius === void 0 ? 1 : _opts$radius,\n        _opts$id = opts.id,\n        id = _opts$id === void 0 ? uid('sphere-geometry') : _opts$id;\n    return _possibleConstructorReturn(this, _getPrototypeOf(SphereGeometry).call(this, Object.assign({}, opts, {\n      id: id,\n      attributes: getSphereAttributes(nlat, nlong, radius)\n    })));\n  }\n\n  return SphereGeometry;\n}(Geometry); // Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\n\n/* eslint-disable max-statements, complexity */\n\n\nexport { SphereGeometry as default };\n\nfunction getSphereAttributes(nlat, nlong, radius) {\n  var startLat = 0;\n  var endLat = Math.PI;\n  var latRange = endLat - startLat;\n  var startLong = 0;\n  var endLong = 2 * Math.PI;\n  var longRange = endLong - startLong;\n  var numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    var value = radius;\n\n    radius = function radius(n1, n2, n3, u, v) {\n      return value;\n    };\n  }\n\n  var positions = new Float32Array(numVertices * 3);\n  var normals = new Float32Array(numVertices * 3);\n  var texCoords = new Float32Array(numVertices * 2);\n  var indices = new Uint16Array(nlat * nlong * 6); // Create positions, normals and texCoords\n\n  for (var y = 0; y <= nlat; y++) {\n    for (var x = 0; x <= nlong; x++) {\n      var u = x / nlong;\n      var v = y / nlat;\n      var index = x + y * (nlong + 1);\n      var i2 = index * 2;\n      var i3 = index * 3;\n      var theta = longRange * u;\n      var phi = latRange * v;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta);\n      var sinPhi = Math.sin(phi);\n      var cosPhi = Math.cos(phi);\n      var ux = cosTheta * sinPhi;\n      var uy = cosPhi;\n      var uz = sinTheta * sinPhi;\n      var r = radius(ux, uy, uz, u, v);\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = v;\n    }\n  } // Create indices\n\n\n  var numVertsAround = nlat + 1;\n\n  for (var _x = 0; _x < nlat; _x++) {\n    for (var _y = 0; _y < nlong; _y++) {\n      var _index = (_x * nlong + _y) * 6;\n\n      indices[_index + 0] = _y * numVertsAround + _x;\n      indices[_index + 1] = _y * numVertsAround + _x + 1;\n      indices[_index + 2] = (_y + 1) * numVertsAround + _x;\n      indices[_index + 3] = (_y + 1) * numVertsAround + _x;\n      indices[_index + 4] = _y * numVertsAround + _x + 1;\n      indices[_index + 5] = (_y + 1) * numVertsAround + _x + 1;\n    }\n  }\n\n  return {\n    positions: positions,\n    indices: indices,\n    normals: normals,\n    texCoords: texCoords\n  };\n}","map":null,"metadata":{},"sourceType":"module"}