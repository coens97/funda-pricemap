{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _react = require('react');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _autobind = require('../utils/autobind');\n\nvar _autobind2 = _interopRequireDefault(_autobind);\n\nvar _accessToken = require('../utils/access-token');\n\nvar _styleUtils = require('../utils/style-utils');\n\nvar _diffStyles2 = require('../utils/diff-styles');\n\nvar _diffStyles3 = _interopRequireDefault(_diffStyles2);\n\nvar _immutable = require('immutable');\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _isBrowser = require('../utils/is-browser');\n\nvar _isBrowser2 = _interopRequireDefault(_isBrowser);\n\nvar _viewportMercatorProject = require('viewport-mercator-project');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar mapboxgl = null; // Copyright (c) 2015 Uber Technologies, Inc.\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nif (_isBrowser2.default) {\n  mapboxgl = require('mapbox-gl');\n}\n\nfunction noop() {}\n\nvar propTypes = {\n  /** Mapbox API access token for mapbox-gl-js. Required when using Mapbox vector tiles/styles. */\n  mapboxApiAccessToken: _propTypes2.default.string,\n\n  /** Mapbox WebGL context creation option. Useful when you want to export the canvas as a PNG. */\n  preserveDrawingBuffer: _propTypes2.default.bool,\n\n  /** Show attribution control or not. */\n  attributionControl: _propTypes2.default.bool,\n\n  /** The Mapbox style. A string url or a MapboxGL style Immutable.Map object. */\n  mapStyle: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.instanceOf(_immutable2.default.Map)]),\n\n  /** There are known issues with style diffing. As stopgap, add option to prevent style diffing. */\n  preventStyleDiffing: _propTypes2.default.bool,\n\n  /** Whether the map is visible */\n  visible: _propTypes2.default.bool,\n\n  /** The width of the map. */\n  width: _propTypes2.default.number.isRequired,\n\n  /** The height of the map. */\n  height: _propTypes2.default.number.isRequired,\n\n  /** The longitude of the center of the map. */\n  longitude: _propTypes2.default.number.isRequired,\n\n  /** The latitude of the center of the map. */\n  latitude: _propTypes2.default.number.isRequired,\n\n  /** The tile zoom level of the map. */\n  zoom: _propTypes2.default.number.isRequired,\n\n  /** Specify the bearing of the viewport */\n  bearing: _propTypes2.default.number,\n\n  /** Specify the pitch of the viewport */\n  pitch: _propTypes2.default.number,\n\n  /** Altitude of the viewport camera. Default 1.5 \"screen heights\" */\n  // Note: Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137\n  altitude: _propTypes2.default.number,\n\n  /** The onLoad callback for the map */\n  onLoad: _propTypes2.default.func\n};\nvar defaultProps = {\n  mapStyle: 'mapbox://styles/mapbox/light-v8',\n  mapboxApiAccessToken: (0, _accessToken.getAccessToken)(),\n  preserveDrawingBuffer: false,\n  attributionControl: true,\n  preventStyleDiffing: false,\n  visible: true,\n  bearing: 0,\n  pitch: 0,\n  altitude: 1.5,\n  onLoad: noop\n};\nvar childContextTypes = {\n  viewport: _propTypes2.default.instanceOf(_viewportMercatorProject.PerspectiveMercatorViewport)\n};\n\nvar StaticMap = function (_PureComponent) {\n  (0, _inherits3.default)(StaticMap, _PureComponent);\n  (0, _createClass3.default)(StaticMap, null, [{\n    key: 'supported',\n    value: function supported() {\n      return mapboxgl && mapboxgl.supported();\n    }\n  }]);\n\n  function StaticMap(props) {\n    (0, _classCallCheck3.default)(this, StaticMap);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (StaticMap.__proto__ || (0, _getPrototypeOf2.default)(StaticMap)).call(this, props));\n\n    _this._queryParams = {};\n\n    if (mapboxgl) {\n      mapboxgl.accessToken = props.mapboxApiAccessToken;\n    }\n\n    if (!StaticMap.supported()) {\n      _this.componentDidMount = noop;\n      _this.componentWillReceiveProps = noop;\n      _this.componentDidUpdate = noop;\n    }\n\n    (0, _autobind2.default)(_this);\n    return _this;\n  }\n\n  (0, _createClass3.default)(StaticMap, [{\n    key: 'getChildContext',\n    value: function getChildContext() {\n      return {\n        viewport: new _viewportMercatorProject.PerspectiveMercatorViewport(this.props)\n      };\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      if (!mapboxgl) {\n        return;\n      }\n\n      var mapStyle = _immutable2.default.Map.isMap(this.props.mapStyle) ? this.props.mapStyle.toJS() : this.props.mapStyle;\n      var map = new mapboxgl.Map({\n        container: this._mapboxMap,\n        center: [this.props.longitude, this.props.latitude],\n        zoom: this.props.zoom,\n        pitch: this.props.pitch,\n        bearing: this.props.bearing,\n        style: mapStyle,\n        interactive: false,\n        attributionControl: this.props.attributionControl,\n        preserveDrawingBuffer: this.props.preserveDrawingBuffer\n      }); // Disable outline style\n\n      var canvas = map.getCanvas();\n\n      if (canvas) {\n        canvas.style.outline = 'none';\n      } // Attach optional onLoad function\n\n\n      map.once('load', this.props.onLoad);\n      this._map = map;\n\n      this._updateMapViewport({}, this.props); // this._callOnChangeViewport(map.transform);\n\n\n      this._updateQueryParams(mapStyle);\n    }\n  }, {\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(newProps) {\n      if (!mapboxgl) {\n        return;\n      }\n\n      this._updateStateFromProps(this.props, newProps);\n\n      this._updateMapViewport(this.props, newProps);\n\n      this._updateMapStyle(this.props, newProps); // Save width/height so that we can check them in componentDidUpdate\n\n\n      this.setState({\n        width: this.props.width,\n        height: this.props.height\n      });\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      if (!mapboxgl) {\n        return;\n      } // Since Mapbox's map.resize() reads size from DOM\n      // we must wait to read size until after render (i.e. here in \"didUpdate\")\n\n\n      this._updateMapSize(this.state, this.props);\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      if (!mapboxgl) {\n        return;\n      }\n\n      if (this._map) {\n        this._map.remove();\n      }\n    } // External apps can access map this way\n\n  }, {\n    key: 'getMap',\n    value: function getMap() {\n      return this._map;\n    }\n    /** Uses Mapbox's\n      * queryRenderedFeatures API to find features at point or in a bounding box.\n      * https://www.mapbox.com/mapbox-gl-js/api/#Map#queryRenderedFeatures\n      * To query only some of the layers, set the `interactive` property in the\n      * layer style to `true`.\n      * @param {[Number, Number]|[[Number, Number], [Number, Number]]} geometry -\n      *   Point or an array of two points defining the bounding box\n      * @param {Object} parameters - query options\n      */\n\n  }, {\n    key: 'queryRenderedFeatures',\n    value: function queryRenderedFeatures(geometry, parameters) {\n      var queryParams = parameters || this._queryParams;\n\n      if (queryParams.layers && queryParams.layers.length === 0) {\n        return [];\n      }\n\n      return this._map.queryRenderedFeatures(geometry, queryParams);\n    }\n  }, {\n    key: '_updateStateFromProps',\n    value: function _updateStateFromProps(oldProps, newProps) {\n      if (mapboxgl) {\n        mapboxgl.accessToken = newProps.mapboxApiAccessToken;\n      }\n    } // Hover and click only query layers whose interactive property is true\n\n  }, {\n    key: '_updateQueryParams',\n    value: function _updateQueryParams(mapStyle) {\n      var interactiveLayerIds = (0, _styleUtils.getInteractiveLayerIds)(mapStyle);\n      this._queryParams = {\n        layers: interactiveLayerIds\n      };\n    } // Update a source in the map style\n\n  }, {\n    key: '_updateSource',\n    value: function _updateSource(map, update) {\n      var newSource = update.source.toJS();\n\n      if (newSource.type === 'geojson') {\n        var oldSource = map.getSource(update.id);\n\n        if (oldSource.type === 'geojson') {\n          // update data if no other GeoJSONSource options were changed\n          var oldOpts = oldSource.workerOptions;\n\n          if ((newSource.maxzoom === undefined || newSource.maxzoom === oldOpts.geojsonVtOptions.maxZoom) && (newSource.buffer === undefined || newSource.buffer === oldOpts.geojsonVtOptions.buffer) && (newSource.tolerance === undefined || newSource.tolerance === oldOpts.geojsonVtOptions.tolerance) && (newSource.cluster === undefined || newSource.cluster === oldOpts.cluster) && (newSource.clusterRadius === undefined || newSource.clusterRadius === oldOpts.superclusterOptions.radius) && (newSource.clusterMaxZoom === undefined || newSource.clusterMaxZoom === oldOpts.superclusterOptions.maxZoom)) {\n            oldSource.setData(newSource.data);\n            return;\n          }\n        }\n      }\n\n      map.removeSource(update.id);\n      map.addSource(update.id, newSource);\n    } // Individually update the maps source and layers that have changed if all\n    // other style props haven't changed. This prevents flicking of the map when\n    // styles only change sources or layers.\n\n    /* eslint-disable max-statements, complexity */\n\n  }, {\n    key: '_setDiffStyle',\n    value: function _setDiffStyle(prevStyle, nextStyle) {\n      var prevKeysMap = prevStyle && styleKeysMap(prevStyle) || {};\n      var nextKeysMap = styleKeysMap(nextStyle);\n\n      function styleKeysMap(style) {\n        return style.map(function () {\n          return true;\n        }).delete('layers').delete('sources').toJS();\n      }\n\n      function propsOtherThanLayersOrSourcesDiffer() {\n        var prevKeysList = (0, _keys2.default)(prevKeysMap);\n        var nextKeysList = (0, _keys2.default)(nextKeysMap);\n\n        if (prevKeysList.length !== nextKeysList.length) {\n          return true;\n        } // `nextStyle` and `prevStyle` should not have the same set of props.\n\n\n        if (nextKeysList.some(function (key) {\n          return prevStyle.get(key) !== nextStyle.get(key);\n        } // But the value of one of those props is different.\n        )) {\n          return true;\n        }\n\n        return false;\n      }\n\n      var map = this._map;\n\n      if (!prevStyle || propsOtherThanLayersOrSourcesDiffer()) {\n        map.setStyle(nextStyle.toJS());\n        return;\n      }\n\n      var _diffStyles = (0, _diffStyles3.default)(prevStyle, nextStyle),\n          sourcesDiff = _diffStyles.sourcesDiff,\n          layersDiff = _diffStyles.layersDiff; // TODO: It's rather difficult to determine style diffing in the presence\n      // of refs. For now, if any style update has a ref, fallback to no diffing.\n      // We can come back to this case if there's a solid usecase.\n\n\n      if (layersDiff.updates.some(function (node) {\n        return node.layer.get('ref');\n      })) {\n        map.setStyle(nextStyle.toJS());\n        return;\n      }\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (0, _getIterator3.default)(sourcesDiff.enter), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var enter = _step.value;\n          map.addSource(enter.id, enter.source.toJS());\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = (0, _getIterator3.default)(sourcesDiff.update), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var update = _step2.value;\n\n          this._updateSource(map, update);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = (0, _getIterator3.default)(sourcesDiff.exit), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var exit = _step3.value;\n          map.removeSource(exit.id);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = (0, _getIterator3.default)(layersDiff.exiting), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _exit = _step4.value;\n\n          if (map.style.getLayer(_exit.id)) {\n            map.removeLayer(_exit.id);\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = (0, _getIterator3.default)(layersDiff.updates), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _update = _step5.value;\n\n          if (!_update.enter) {\n            // This is an old layer that needs to be updated. Remove the old layer\n            // with the same id and add it back again.\n            map.removeLayer(_update.id);\n          }\n\n          map.addLayer(_update.layer.toJS(), _update.before);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    }\n    /* eslint-enable max-statements, complexity */\n\n  }, {\n    key: '_updateMapStyle',\n    value: function _updateMapStyle(oldProps, newProps) {\n      var mapStyle = newProps.mapStyle;\n      var oldMapStyle = oldProps.mapStyle;\n\n      if (mapStyle !== oldMapStyle) {\n        if (_immutable2.default.Map.isMap(mapStyle)) {\n          if (this.props.preventStyleDiffing) {\n            this._map.setStyle(mapStyle.toJS());\n          } else {\n            this._setDiffStyle(oldMapStyle, mapStyle);\n          }\n        } else {\n          this._map.setStyle(mapStyle);\n        }\n\n        this._updateQueryParams(mapStyle);\n      }\n    }\n  }, {\n    key: '_updateMapViewport',\n    value: function _updateMapViewport(oldProps, newProps) {\n      var viewportChanged = newProps.latitude !== oldProps.latitude || newProps.longitude !== oldProps.longitude || newProps.zoom !== oldProps.zoom || newProps.pitch !== oldProps.pitch || newProps.bearing !== oldProps.bearing || newProps.altitude !== oldProps.altitude;\n\n      if (viewportChanged) {\n        this._map.jumpTo({\n          center: [newProps.longitude, newProps.latitude],\n          zoom: newProps.zoom,\n          bearing: newProps.bearing,\n          pitch: newProps.pitch\n        }); // TODO - jumpTo doesn't handle altitude\n\n\n        if (newProps.altitude !== oldProps.altitude) {\n          this._map.transform.altitude = newProps.altitude;\n        }\n      }\n    } // Note: needs to be called after render (e.g. in componentDidUpdate)\n\n  }, {\n    key: '_updateMapSize',\n    value: function _updateMapSize(oldProps, newProps) {\n      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n\n      if (sizeChanged) {\n        this._map.resize(); // this._callOnChangeViewport(this._map.transform);\n\n      }\n    }\n  }, {\n    key: '_mapboxMapLoaded',\n    value: function _mapboxMapLoaded(ref) {\n      this._mapboxMap = ref;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props = this.props,\n          className = _props.className,\n          width = _props.width,\n          height = _props.height,\n          style = _props.style,\n          visible = _props.visible;\n      var mapContainerStyle = (0, _assign2.default)({}, style, {\n        width: width,\n        height: height,\n        position: 'relative'\n      });\n      var mapStyle = (0, _assign2.default)({}, style, {\n        width: width,\n        height: height,\n        visibility: visible ? 'visible' : 'hidden'\n      });\n      var overlayContainerStyle = {\n        position: 'absolute',\n        left: 0,\n        top: 0,\n        width: width,\n        height: height,\n        overflow: 'hidden'\n      }; // Note: a static map still handles clicks and hover events\n\n      return (0, _react.createElement)('div', {\n        key: 'map-container',\n        style: mapContainerStyle,\n        children: [(0, _react.createElement)('div', {\n          key: 'map-mapbox',\n          ref: this._mapboxMapLoaded,\n          style: mapStyle,\n          className: className\n        }), (0, _react.createElement)('div', {\n          key: 'map-overlays',\n          // Same as interactive map's overlay container\n          className: 'overlays',\n          style: overlayContainerStyle,\n          children: this.props.children\n        })]\n      });\n    }\n  }]);\n  return StaticMap;\n}(_react.PureComponent);\n\nexports.default = StaticMap;\nStaticMap.displayName = 'StaticMap';\nStaticMap.propTypes = propTypes;\nStaticMap.defaultProps = defaultProps;\nStaticMap.childContextTypes = childContextTypes;","map":null,"metadata":{},"sourceType":"script"}