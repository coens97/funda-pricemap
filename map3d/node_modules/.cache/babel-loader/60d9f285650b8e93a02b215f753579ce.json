{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { Layer } from '@deck.gl/core';\nimport GL from 'luma.gl/constants';\nimport { Model, Geometry, hasFeature, FEATURES } from 'luma.gl'; // Polygon geometry generation is managed by the polygon tesselator\n\nimport { PolygonTesselator } from './polygon-tesselator';\nimport vs from './solid-polygon-layer-vertex.glsl';\nimport fs from './solid-polygon-layer-fragment.glsl';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  filled: true,\n  // Whether to extrude\n  extruded: false,\n  // Whether to draw a GL.LINES wireframe of the polygon\n  wireframe: false,\n  fp64: false,\n  // elevation multiplier\n  elevationScale: 1,\n  // Accessor for polygon geometry\n  getPolygon: function getPolygon(f) {\n    return f.polygon;\n  },\n  // Accessor for extrusion height\n  getElevation: 1000,\n  // Accessor for colors\n  getFillColor: DEFAULT_COLOR,\n  getLineColor: DEFAULT_COLOR,\n  // Optional settings for 'lighting' shader module\n  lightSettings: {}\n};\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar SolidPolygonLayer =\n/*#__PURE__*/\nfunction (_Layer) {\n  _inherits(SolidPolygonLayer, _Layer);\n\n  function SolidPolygonLayer() {\n    _classCallCheck(this, SolidPolygonLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SolidPolygonLayer).apply(this, arguments));\n  }\n\n  _createClass(SolidPolygonLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [projectModule, 'lighting', 'picking']\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      this.setState({\n        numInstances: 0,\n        IndexType: hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n      });\n      var attributeManager = this.getAttributeManager();\n      var noAlloc = true;\n      attributeManager.remove(['instancePickingColors']);\n      /* eslint-disable max-len */\n\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: this.calculateIndices,\n          noAlloc: noAlloc\n        },\n        positions: {\n          size: 3,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPolygon',\n          update: this.calculatePositions,\n          noAlloc: noAlloc\n        },\n        positions64xyLow: {\n          size: 2,\n          update: this.calculatePositionsLow,\n          noAlloc: noAlloc\n        },\n        vertexValid: {\n          size: 1,\n          type: GL.UNSIGNED_BYTE,\n          update: this.calculateVertexValid,\n          noAlloc: noAlloc\n        },\n        elevations: {\n          size: 1,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getElevation',\n          update: this.calculateElevations,\n          noAlloc: noAlloc\n        },\n        fillColors: {\n          alias: 'colors',\n          size: 4,\n          type: GL.UNSIGNED_BYTE,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getFillColor',\n          update: this.calculateFillColors,\n          defaultValue: DEFAULT_COLOR,\n          noAlloc: noAlloc\n        },\n        lineColors: {\n          alias: 'colors',\n          size: 4,\n          type: GL.UNSIGNED_BYTE,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getLineColor',\n          update: this.calculateLineColors,\n          defaultValue: DEFAULT_COLOR,\n          noAlloc: noAlloc\n        },\n        pickingColors: {\n          size: 3,\n          type: GL.UNSIGNED_BYTE,\n          update: this.calculatePickingColors,\n          noAlloc: noAlloc\n        }\n      });\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref) {\n      var uniforms = _ref.uniforms;\n      var _this$props = this.props,\n          extruded = _this$props.extruded,\n          filled = _this$props.filled,\n          wireframe = _this$props.wireframe,\n          elevationScale = _this$props.elevationScale;\n      var _this$state = this.state,\n          topModel = _this$state.topModel,\n          sideModel = _this$state.sideModel;\n      var renderUniforms = Object.assign({}, uniforms, {\n        extruded: Boolean(extruded),\n        elevationScale: elevationScale\n      }); // Note: the order is important\n\n      if (sideModel) {\n        sideModel.setUniforms(renderUniforms);\n\n        if (wireframe) {\n          sideModel.setDrawMode(GL.LINE_STRIP);\n          sideModel.render({\n            isWireframe: true\n          });\n        }\n\n        if (filled) {\n          sideModel.setDrawMode(GL.TRIANGLE_FAN);\n          sideModel.render({\n            isWireframe: false\n          });\n        }\n      }\n\n      if (topModel) {\n        topModel.render(renderUniforms);\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(updateParams) {\n      _get(_getPrototypeOf(SolidPolygonLayer.prototype), \"updateState\", this).call(this, updateParams);\n\n      this.updateGeometry(updateParams);\n      var props = updateParams.props,\n          oldProps = updateParams.oldProps;\n      var attributeManager = this.getAttributeManager();\n      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n\n      if (regenerateModels) {\n        if (this.state.models) {\n          this.state.models.forEach(function (model) {\n            return model.delete();\n          });\n        }\n\n        this.setState(this._getModels(this.context.gl));\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(_ref2) {\n      var props = _ref2.props,\n          oldProps = _ref2.oldProps,\n          changeFlags = _ref2.changeFlags;\n      var geometryConfigChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon); // When the geometry config  or the data is changed,\n      // tessellator needs to be invoked\n\n      if (geometryConfigChanged) {\n        // TODO - avoid creating a temporary array here: let the tesselator iterate\n        var polygons = props.data.map(props.getPolygon);\n\n        var polygonTesselator = this._getPolygonTesselator(polygons, this.state.IndexType);\n\n        this.setState({\n          polygonTesselator: polygonTesselator,\n          numInstances: polygonTesselator.pointCount\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n\n      if (geometryConfigChanged || props.extruded !== oldProps.extruded || props.fp64 !== oldProps.fp64) {\n        this.state.polygonTesselator.updatePositions({\n          fp64: this.use64bitPositions(),\n          extruded: props.extruded\n        });\n      }\n    } // \"Experimental\" method indended to make it easier to support non-nested arrays in subclasses\n\n  }, {\n    key: \"_getPolygonTesselator\",\n    value: function _getPolygonTesselator(polygons, IndexType) {\n      return new PolygonTesselator({\n        polygons: polygons,\n        IndexType: this.state.IndexType\n      });\n    }\n  }, {\n    key: \"updateAttributes\",\n    value: function updateAttributes(props) {\n      _get(_getPrototypeOf(SolidPolygonLayer.prototype), \"updateAttributes\", this).call(this, props);\n\n      var attributes = this.getAttributeManager().getChangedAttributes({\n        clearChangedFlags: true\n      });\n      var _this$state2 = this.state,\n          topModel = _this$state2.topModel,\n          sideModel = _this$state2.sideModel,\n          vertexCount = _this$state2.vertexCount,\n          numInstances = _this$state2.numInstances;\n\n      if (topModel) {\n        topModel.setVertexCount(vertexCount);\n        topModel.setAttributes(attributes);\n      }\n\n      if (sideModel) {\n        // Remove one to account for the offset\n        sideModel.setInstanceCount(numInstances - 1);\n        var newAttributes = {};\n\n        for (var attributeName in attributes) {\n          var attribute = attributes[attributeName];\n\n          if (attributeName !== 'indices') {\n            // Apply layout override to the attribute.\n            newAttributes[attributeName] = Object.assign({}, attribute, {\n              isInstanced: true,\n              buffer: attribute.getBuffer()\n            });\n          }\n        }\n\n        if (newAttributes.positions) {\n          newAttributes.nextPositions = Object.assign({}, newAttributes.positions, {\n            id: 'nextPositions',\n            offset: 12 // 1 vertex * 3 floats * 4 bits\n\n          });\n        }\n\n        if (newAttributes.positions64xyLow) {\n          newAttributes.nextPositions64xyLow = Object.assign({}, newAttributes.positions64xyLow, {\n            id: 'nextPositions64xyLow',\n            offset: 8 // 1 vertex * 2 floats * 4 bits\n\n          });\n        }\n\n        sideModel.setAttributes(newAttributes);\n      }\n    }\n  }, {\n    key: \"_getModels\",\n    value: function _getModels(gl) {\n      var _this$props2 = this.props,\n          id = _this$props2.id,\n          filled = _this$props2.filled,\n          extruded = _this$props2.extruded;\n      var topModel;\n      var sideModel;\n\n      if (filled) {\n        topModel = new Model(gl, Object.assign({}, this.getShaders(), {\n          id: \"\".concat(id, \"-top\"),\n          geometry: new Geometry({\n            drawMode: GL.TRIANGLES,\n            attributes: {\n              vertexPositions: {\n                size: 2,\n                constant: true,\n                value: new Float32Array([0, 1])\n              },\n              nextPositions: {\n                size: 3,\n                constant: true,\n                value: new Float32Array(3)\n              },\n              nextPositions64xyLow: {\n                size: 2,\n                constant: true,\n                value: new Float32Array(2)\n              }\n            }\n          }),\n          uniforms: {\n            isWireframe: false,\n            isSideVertex: false\n          },\n          vertexCount: 0,\n          isIndexed: true,\n          shaderCache: this.context.shaderCache\n        }));\n      }\n\n      if (extruded) {\n        sideModel = new Model(gl, Object.assign({}, this.getShaders(), {\n          id: \"\".concat(id, \"-side\"),\n          geometry: new Geometry({\n            drawMode: GL.LINES,\n            vertexCount: 4,\n            attributes: {\n              // top right - top left - bootom left - bottom right\n              vertexPositions: {\n                size: 2,\n                value: new Float32Array([1, 1, 0, 1, 0, 0, 1, 0])\n              }\n            }\n          }),\n          uniforms: {\n            isSideVertex: true\n          },\n          isInstanced: 1,\n          shaderCache: this.context.shaderCache\n        }));\n      }\n\n      return {\n        models: [sideModel, topModel].filter(Boolean),\n        topModel: topModel,\n        sideModel: sideModel\n      };\n    }\n  }, {\n    key: \"calculateIndices\",\n    value: function calculateIndices(attribute) {\n      attribute.value = this.state.polygonTesselator.indices();\n      var vertexCount = attribute.value.length / attribute.size;\n      this.setState({\n        vertexCount: vertexCount\n      });\n    }\n  }, {\n    key: \"calculatePositions\",\n    value: function calculatePositions(attribute) {\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.bufferLayout = polygonTesselator.bufferLayout;\n      attribute.value = polygonTesselator.positions();\n    }\n  }, {\n    key: \"calculatePositionsLow\",\n    value: function calculatePositionsLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      attribute.value = this.state.polygonTesselator.positions64xyLow();\n    }\n  }, {\n    key: \"calculateVertexValid\",\n    value: function calculateVertexValid(attribute) {\n      attribute.value = this.state.polygonTesselator.vertexValid();\n    }\n  }, {\n    key: \"calculateElevations\",\n    value: function calculateElevations(attribute) {\n      var _this = this;\n\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.bufferLayout = polygonTesselator.bufferLayout;\n      var _this$props3 = this.props,\n          extruded = _this$props3.extruded,\n          _getElevation = _this$props3.getElevation;\n\n      if (extruded && typeof _getElevation === 'function') {\n        attribute.constant = false;\n        attribute.value = polygonTesselator.elevations({\n          getElevation: function getElevation(polygonIndex) {\n            return _getElevation(_this.props.data[polygonIndex]);\n          }\n        });\n      } else {\n        var elevation = extruded ? _getElevation : 0;\n        attribute.constant = true;\n        attribute.value = new Float32Array([elevation]);\n      }\n    }\n  }, {\n    key: \"calculateFillColors\",\n    value: function calculateFillColors(attribute) {\n      var _this2 = this;\n\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.bufferLayout = polygonTesselator.bufferLayout;\n      attribute.value = polygonTesselator.colors({\n        key: 'fillColors',\n        getColor: function getColor(polygonIndex) {\n          return _this2.props.getFillColor(_this2.props.data[polygonIndex]);\n        }\n      });\n    }\n  }, {\n    key: \"calculateLineColors\",\n    value: function calculateLineColors(attribute) {\n      var _this3 = this;\n\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.bufferLayout = polygonTesselator.bufferLayout;\n      attribute.value = polygonTesselator.colors({\n        key: 'lineColors',\n        getColor: function getColor(polygonIndex) {\n          return _this3.props.getLineColor(_this3.props.data[polygonIndex]);\n        }\n      });\n    } // Override the default picking colors calculation\n\n  }, {\n    key: \"calculatePickingColors\",\n    value: function calculatePickingColors(attribute) {\n      attribute.value = this.state.polygonTesselator.pickingColors();\n    }\n  }]);\n\n  return SolidPolygonLayer;\n}(Layer);\n\nexport { SolidPolygonLayer as default };\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nSolidPolygonLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}