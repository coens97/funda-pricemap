{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport log from '../utils/log';\nimport { transformVector, createMat4, extractCameraVectors } from '../utils/math-utils';\nimport { Matrix4, Vector3, equals as _equals } from 'math.gl';\nimport mat4_scale from 'gl-mat4/scale';\nimport mat4_translate from 'gl-mat4/translate';\nimport mat4_multiply from 'gl-mat4/multiply';\nimport mat4_invert from 'gl-mat4/invert';\nimport mat4_perspective from 'gl-mat4/perspective';\nimport vec2_lerp from 'gl-vec2/lerp';\nvar ZERO_VECTOR = [0, 0, 0];\nimport { getDistanceScales as _getDistanceScales, getWorldPosition, getMeterZoom } from 'viewport-mercator-project';\nimport assert from 'assert';\nvar IDENTITY = createMat4();\nvar DEFAULT_DISTANCE_SCALES = {\n  pixelsPerMeter: [1, 1, 1],\n  metersPerPixel: [1, 1, 1],\n  pixelsPerDegree: [1, 1, 1],\n  degreesPerPixel: [1, 1, 1]\n};\nvar DEFAULT_ZOOM = 0;\nvar ERR_ARGUMENT = 'Illegal argument to Viewport';\n\nvar Viewport = function () {\n  /**\n   * @classdesc\n   * Manages coordinate system transformations for deck.gl.\n   *\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n\n  /* eslint-disable complexity, max-statements */\n  function Viewport() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Viewport);\n\n    var _opts$id = opts.id,\n        id = _opts$id === undefined ? null : _opts$id,\n        _opts$x = opts.x,\n        x = _opts$x === undefined ? 0 : _opts$x,\n        _opts$y = opts.y,\n        y = _opts$y === undefined ? 0 : _opts$y,\n        _opts$width = opts.width,\n        width = _opts$width === undefined ? 1 : _opts$width,\n        _opts$height = opts.height,\n        height = _opts$height === undefined ? 1 : _opts$height,\n        _opts$viewMatrix = opts.viewMatrix,\n        viewMatrix = _opts$viewMatrix === undefined ? IDENTITY : _opts$viewMatrix,\n        _opts$projectionMatri = opts.projectionMatrix,\n        projectionMatrix = _opts$projectionMatri === undefined ? null : _opts$projectionMatri,\n        _opts$fovy = opts.fovy,\n        fovy = _opts$fovy === undefined ? 75 : _opts$fovy,\n        _opts$near = opts.near,\n        near = _opts$near === undefined ? 0.1 : _opts$near,\n        _opts$far = opts.far,\n        far = _opts$far === undefined ? 1000 : _opts$far,\n        _opts$longitude = opts.longitude,\n        longitude = _opts$longitude === undefined ? null : _opts$longitude,\n        _opts$latitude = opts.latitude,\n        latitude = _opts$latitude === undefined ? null : _opts$latitude,\n        _opts$zoom = opts.zoom,\n        zoom = _opts$zoom === undefined ? null : _opts$zoom,\n        _opts$position = opts.position,\n        position = _opts$position === undefined ? null : _opts$position,\n        _opts$modelMatrix = opts.modelMatrix,\n        modelMatrix = _opts$modelMatrix === undefined ? null : _opts$modelMatrix,\n        _opts$distanceScales = opts.distanceScales,\n        distanceScales = _opts$distanceScales === undefined ? null : _opts$distanceScales;\n    this.id = id || this.constructor.displayName || 'viewport'; // Check if we have a geospatial anchor\n\n    this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude); // Silently allow apps to send in w,h = 0,0\n\n    this.x = x;\n    this.y = y;\n    this.width = width || 1;\n    this.height = height || 1;\n    this.zoom = zoom;\n\n    if (!Number.isFinite(this.zoom)) {\n      this.zoom = this.isGeospatial ? getMeterZoom({\n        latitude: latitude\n      }) : DEFAULT_ZOOM;\n    }\n\n    this.scale = Math.pow(2, this.zoom); // Calculate distance scales if lng/lat/zoom are provided\n\n    this.distanceScales = this.isGeospatial ? _getDistanceScales({\n      latitude: latitude,\n      longitude: longitude,\n      scale: this.scale\n    }) : distanceScales || DEFAULT_DISTANCE_SCALES;\n    this.focalDistance = opts.focalDistance || 1;\n    this.distanceScales.metersPerPixel = new Vector3(this.distanceScales.metersPerPixel);\n    this.distanceScales.pixelsPerMeter = new Vector3(this.distanceScales.pixelsPerMeter);\n    this.position = ZERO_VECTOR;\n    this.meterOffset = ZERO_VECTOR;\n\n    if (position) {\n      // Apply model matrix if supplied\n      this.position = position;\n      this.modelMatrix = modelMatrix;\n      this.meterOffset = modelMatrix ? modelMatrix.transformVector(position) : position;\n    }\n\n    this.viewMatrixUncentered = viewMatrix;\n\n    if (this.isGeospatial) {\n      // Determine camera center\n      this.center = getWorldPosition({\n        longitude: longitude,\n        latitude: latitude,\n        zoom: this.zoom,\n        meterOffset: this.meterOffset\n      }); // Make a centered version of the matrix for projection modes without an offset\n\n      this.viewMatrix = new Matrix4() // Apply the uncentered view matrix\n      .multiplyRight(this.viewMatrixUncentered) // The Mercator world coordinate system is upper left,\n      // but GL expects lower left, so we flip it around the center after all transforms are done\n      .scale([1, -1, 1]) // And center it\n      .translate(new Vector3(this.center || ZERO_VECTOR).negate());\n    } else {\n      this.center = position;\n      this.viewMatrix = viewMatrix;\n    } // Create a projection matrix if not supplied\n\n\n    if (projectionMatrix) {\n      this.projectionMatrix = projectionMatrix;\n    } else {\n      assert(Number.isFinite(fovy));\n      var DEGREES_TO_RADIANS = Math.PI / 180;\n      var fovyRadians = fovy * DEGREES_TO_RADIANS;\n      var aspect = this.width / this.height;\n      this.projectionMatrix = mat4_perspective([], fovyRadians, aspect, near, far);\n    } // Init pixel matrices\n\n\n    this._initMatrices(); // Bind methods for easy access\n\n\n    this.equals = this.equals.bind(this);\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.projectFlat = this.projectFlat.bind(this);\n    this.unprojectFlat = this.unprojectFlat.bind(this);\n    this.getMatrices = this.getMatrices.bind(this);\n  }\n  /* eslint-enable complexity, max-statements */\n  // Two viewports are equal if width and height are identical, and if\n  // their view and projection matrices are (approximately) equal.\n\n\n  _createClass(Viewport, [{\n    key: 'equals',\n    value: function equals(viewport) {\n      if (!(viewport instanceof Viewport)) {\n        return false;\n      }\n\n      return viewport.width === this.width && viewport.height === this.height && _equals(viewport.projectionMatrix, this.projectionMatrix) && _equals(viewport.viewMatrix, this.viewMatrix); // TODO - check distance scales?\n    }\n    /**\n     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n     * using viewport projection parameters\n     * - [longitude, latitude] to [x, y]\n     * - [longitude, latitude, Z] => [x, y, z]\n     * Note: By default, returns top-left coordinates for canvas/SVG type render\n     *\n     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n     * @param {Object} opts - options\n     * @param {Object} opts.topLeft=true - Whether projected coords are top left\n     * @return {Array} - [x, y] or [x, y, z] in top left coords\n     */\n\n  }, {\n    key: 'project',\n    value: function project(xyz) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$topLeft = _ref.topLeft,\n          topLeft = _ref$topLeft === undefined ? true : _ref$topLeft;\n\n      var _xyz = _slicedToArray(xyz, 3),\n          x0 = _xyz[0],\n          y0 = _xyz[1],\n          _xyz$ = _xyz[2],\n          z0 = _xyz$ === undefined ? 0 : _xyz$;\n\n      assert(Number.isFinite(x0) && Number.isFinite(y0) && Number.isFinite(z0), ERR_ARGUMENT);\n\n      var _projectFlat2 = this.projectFlat([x0, y0]),\n          _projectFlat3 = _slicedToArray(_projectFlat2, 2),\n          X = _projectFlat3[0],\n          Y = _projectFlat3[1];\n\n      var v = transformVector(this.pixelProjectionMatrix, [X, Y, z0, 1]);\n\n      var _v = _slicedToArray(v, 2),\n          x = _v[0],\n          y = _v[1];\n\n      var y2 = topLeft ? y : this.height - y;\n      return xyz.length === 2 ? [x, y2] : [x, y2, 0];\n    }\n    /**\n     * Unproject pixel coordinates on screen onto world coordinates,\n     * (possibly [lon, lat]) on map.\n     * - [x, y] => [lng, lat]\n     * - [x, y, z] => [lng, lat, Z]\n     * @param {Array} xyz -\n     * @param {Object} opts - options\n     * @param {Object} opts.topLeft=true - Whether origin is top left\n     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n     */\n\n  }, {\n    key: 'unproject',\n    value: function unproject(xyz) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$topLeft = _ref2.topLeft,\n          topLeft = _ref2$topLeft === undefined ? true : _ref2$topLeft;\n\n      var _xyz2 = _slicedToArray(xyz, 3),\n          x = _xyz2[0],\n          y = _xyz2[1],\n          _xyz2$ = _xyz2[2],\n          targetZ = _xyz2$ === undefined ? 0 : _xyz2$;\n\n      var y2 = topLeft ? y : this.height - y; // since we don't know the correct projected z value for the point,\n      // unproject two points to get a line and then find the point on that line with z=0\n\n      var coord0 = transformVector(this.pixelUnprojectionMatrix, [x, y2, 0, 1]);\n      var coord1 = transformVector(this.pixelUnprojectionMatrix, [x, y2, 1, 1]);\n\n      if (!coord0 || !coord1) {\n        return null;\n      }\n\n      var z0 = coord0[2];\n      var z1 = coord1[2];\n      var t = z0 === z1 ? 0 : (targetZ - z0) / (z1 - z0);\n      var v = vec2_lerp([], coord0, coord1, t);\n      var vUnprojected = this.unprojectFlat(v);\n      return xyz.length === 2 ? vUnprojected : [vUnprojected[0], vUnprojected[1], 0];\n    } // NON_LINEAR PROJECTION HOOKS\n    // Used for web meractor projection\n\n    /**\n     * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n     * Performs the nonlinear part of the web mercator projection.\n     * Remaining projection is done with 4x4 matrices which also handles\n     * perspective.\n     * @param {Array} lngLat - [lng, lat] coordinates\n     *   Specifies a point on the sphere to project onto the map.\n     * @return {Array} [x,y] coordinates.\n     */\n\n  }, {\n    key: 'projectFlat',\n    value: function projectFlat(_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 2),\n          x = _ref4[0],\n          y = _ref4[1];\n\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return this._projectFlat.apply(this, arguments);\n    }\n    /**\n     * Unproject world point [x,y] on map onto {lat, lon} on sphere\n     * @param {object|Vector} xy - object with {x,y} members\n     *  representing point on projected map plane\n     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n     *   Has toArray method if you need a GeoJSON Array.\n     *   Per cartographic tradition, lat and lon are specified as degrees.\n     */\n\n  }, {\n    key: 'unprojectFlat',\n    value: function unprojectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return this._unprojectFlat.apply(this, arguments);\n    } // TODO - why do we need these?\n\n  }, {\n    key: '_projectFlat',\n    value: function _projectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return xyz;\n    }\n  }, {\n    key: '_unprojectFlat',\n    value: function _unprojectFlat(xyz) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return xyz;\n    }\n  }, {\n    key: 'getMercatorParams',\n    value: function getMercatorParams() {\n      var lngLat = this._addMetersToLngLat([this.longitude || 0, this.latitude || 0], this.meterOffset);\n\n      return {\n        longitude: lngLat[0],\n        latitude: lngLat[1]\n      };\n    }\n  }, {\n    key: 'isMapSynched',\n    value: function isMapSynched() {\n      return false;\n    }\n  }, {\n    key: 'getDistanceScales',\n    value: function getDistanceScales() {\n      var coordinateOrigin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (coordinateOrigin) {\n        return _getDistanceScales({\n          longitude: coordinateOrigin[0],\n          latitude: coordinateOrigin[1],\n          scale: this.scale,\n          highPrecision: true\n        });\n      }\n\n      return this.distanceScales;\n    }\n  }, {\n    key: 'getMatrices',\n    value: function getMatrices() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref5$modelMatrix = _ref5.modelMatrix,\n          modelMatrix = _ref5$modelMatrix === undefined ? null : _ref5$modelMatrix;\n\n      var modelViewProjectionMatrix = this.viewProjectionMatrix;\n      var pixelProjectionMatrix = this.pixelProjectionMatrix;\n      var pixelUnprojectionMatrix = this.pixelUnprojectionMatrix;\n\n      if (modelMatrix) {\n        modelViewProjectionMatrix = mat4_multiply([], this.viewProjectionMatrix, modelMatrix);\n        pixelProjectionMatrix = mat4_multiply([], this.pixelProjectionMatrix, modelMatrix);\n        pixelUnprojectionMatrix = mat4_invert([], pixelProjectionMatrix);\n      }\n\n      var matrices = Object.assign({\n        modelViewProjectionMatrix: modelViewProjectionMatrix,\n        viewProjectionMatrix: this.viewProjectionMatrix,\n        viewMatrix: this.viewMatrix,\n        projectionMatrix: this.projectionMatrix,\n        // project/unproject between pixels and world\n        pixelProjectionMatrix: pixelProjectionMatrix,\n        pixelUnprojectionMatrix: pixelUnprojectionMatrix,\n        width: this.width,\n        height: this.height,\n        scale: this.scale\n      });\n      return matrices;\n    } // EXPERIMENTAL METHODS\n\n  }, {\n    key: 'getCameraPosition',\n    value: function getCameraPosition() {\n      return this.cameraPosition;\n    }\n  }, {\n    key: 'getCameraDirection',\n    value: function getCameraDirection() {\n      return this.cameraDirection;\n    }\n  }, {\n    key: 'getCameraUp',\n    value: function getCameraUp() {\n      return this.cameraUp;\n    } // TODO - these are duplicating WebMercator methods\n\n  }, {\n    key: '_addMetersToLngLat',\n    value: function _addMetersToLngLat(lngLatZ, xyz) {\n      var _lngLatZ = _slicedToArray(lngLatZ, 3),\n          lng = _lngLatZ[0],\n          lat = _lngLatZ[1],\n          _lngLatZ$ = _lngLatZ[2],\n          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;\n\n      var _metersToLngLatDelta2 = this._metersToLngLatDelta(xyz),\n          _metersToLngLatDelta3 = _slicedToArray(_metersToLngLatDelta2, 3),\n          deltaLng = _metersToLngLatDelta3[0],\n          deltaLat = _metersToLngLatDelta3[1],\n          _metersToLngLatDelta4 = _metersToLngLatDelta3[2],\n          deltaZ = _metersToLngLatDelta4 === undefined ? 0 : _metersToLngLatDelta4;\n\n      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];\n    }\n  }, {\n    key: '_metersToLngLatDelta',\n    value: function _metersToLngLatDelta(xyz) {\n      var _xyz3 = _slicedToArray(xyz, 3),\n          x = _xyz3[0],\n          y = _xyz3[1],\n          _xyz3$ = _xyz3[2],\n          z = _xyz3$ === undefined ? 0 : _xyz3$;\n\n      assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);\n      var _distanceScales = this.distanceScales,\n          pixelsPerMeter = _distanceScales.pixelsPerMeter,\n          degreesPerPixel = _distanceScales.degreesPerPixel;\n      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];\n      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];\n      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];\n    } // INTERNAL METHODS\n\n  }, {\n    key: '_initMatrices',\n    value: function _initMatrices() {\n      // Note: As usual, matrix operations should be applied in \"reverse\" order\n      // since vectors will be multiplied in from the right during transformation\n      var vpm = createMat4();\n      mat4_multiply(vpm, vpm, this.projectionMatrix);\n      mat4_multiply(vpm, vpm, this.viewMatrix);\n      this.viewProjectionMatrix = vpm; // console.log('VPM', this.viewMatrix, this.projectionMatrix, this.viewProjectionMatrix);\n      // Calculate inverse view matrix\n\n      this.viewMatrixInverse = mat4_invert([], this.viewMatrix) || this.viewMatrix; // Decompose camera directions\n\n      var _extractCameraVectors = extractCameraVectors({\n        viewMatrix: this.viewMatrix,\n        viewMatrixInverse: this.viewMatrixInverse\n      }),\n          eye = _extractCameraVectors.eye,\n          direction = _extractCameraVectors.direction,\n          up = _extractCameraVectors.up;\n\n      this.cameraPosition = eye;\n      this.cameraDirection = direction;\n      this.cameraUp = up; // console.log(this.cameraPosition, this.cameraDirection, this.cameraUp);\n\n      /*\n       * Builds matrices that converts preprojected lngLats to screen pixels\n       * and vice versa.\n       * Note: Currently returns bottom-left coordinates!\n       * Note: Starts with the GL projection matrix and adds steps to the\n       *       scale and translate that matrix onto the window.\n       * Note: WebGL controls clip space to screen projection with gl.viewport\n       *       and does not need this step.\n       */\n      // matrix for conversion from world location to screen (pixel) coordinates\n\n      var m = createMat4();\n      mat4_scale(m, m, [this.width / 2, -this.height / 2, 1]);\n      mat4_translate(m, m, [1, -1, 0]);\n      mat4_multiply(m, m, this.viewProjectionMatrix);\n      this.pixelProjectionMatrix = m;\n      this.pixelUnprojectionMatrix = mat4_invert(createMat4(), this.pixelProjectionMatrix);\n\n      if (!this.pixelUnprojectionMatrix) {\n        log.warn('Pixel project matrix not invertible'); // throw new Error('Pixel project matrix not invertible');\n      }\n    }\n  }]);\n\n  return Viewport;\n}();\n\nexport default Viewport;\nViewport.displayName = 'Viewport';","map":null,"metadata":{},"sourceType":"module"}