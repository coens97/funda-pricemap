{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n/* eslint-disable complexity */\n\n\nimport assert from '../utils/assert';\nimport GL from 'luma.gl/constants';\nimport { Buffer, _Attribute as Attribute } from 'luma.gl';\nvar DEFAULT_STATE = {\n  isExternalBuffer: false,\n  needsUpdate: true,\n  needsRedraw: false,\n  allocedInstances: -1\n};\n\nvar LayerAttribute =\n/*#__PURE__*/\nfunction (_Attribute) {\n  _inherits(LayerAttribute, _Attribute);\n\n  function LayerAttribute(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, LayerAttribute);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LayerAttribute).call(this, gl, opts));\n    var _opts$transition = opts.transition,\n        transition = _opts$transition === void 0 ? false : _opts$transition,\n        _opts$noAlloc = opts.noAlloc,\n        noAlloc = _opts$noAlloc === void 0 ? false : _opts$noAlloc,\n        _opts$update = opts.update,\n        update = _opts$update === void 0 ? null : _opts$update,\n        _opts$accessor = opts.accessor,\n        accessor = _opts$accessor === void 0 ? null : _opts$accessor,\n        _opts$bufferLayout = opts.bufferLayout,\n        bufferLayout = _opts$bufferLayout === void 0 ? null : _opts$bufferLayout;\n    var _opts$defaultValue = opts.defaultValue,\n        defaultValue = _opts$defaultValue === void 0 ? [0, 0, 0, 0] : _opts$defaultValue;\n    defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n    Object.assign(_this.userData, DEFAULT_STATE, opts, {\n      transition: transition,\n      noAlloc: noAlloc,\n      update: update,\n      accessor: accessor,\n      defaultValue: defaultValue,\n      bufferLayout: bufferLayout\n    });\n    Object.seal(_this.userData); // Check all fields and generate helpful error messages\n\n    _this._validateAttributeUpdaters();\n\n    return _this;\n  }\n\n  _createClass(LayerAttribute, [{\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this.userData.needsUpdate;\n    }\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$clearChangedFlag = _ref.clearChangedFlags,\n          clearChangedFlags = _ref$clearChangedFlag === void 0 ? false : _ref$clearChangedFlag;\n\n      var needsRedraw = this.userData.needsRedraw;\n      this.userData.needsRedraw = this.userData.needsRedraw && !clearChangedFlags;\n      return needsRedraw;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.value !== null ? this.value.length / this.size : 0;\n    }\n  }, {\n    key: \"getUpdateTriggers\",\n    value: function getUpdateTriggers() {\n      var accessor = this.userData.accessor; // Backards compatibility: allow attribute name to be used as update trigger key\n\n      return [this.id].concat(accessor || []);\n    }\n  }, {\n    key: \"getAccessor\",\n    value: function getAccessor() {\n      return this.userData.accessor;\n    }\n  }, {\n    key: \"supportsTransition\",\n    value: function supportsTransition() {\n      return this.userData.transition;\n    } // Resolve transition settings object if transition is enabled, otherwise `null`\n\n  }, {\n    key: \"getTransitionSetting\",\n    value: function getTransitionSetting(opts) {\n      var _this$userData = this.userData,\n          transition = _this$userData.transition,\n          accessor = _this$userData.accessor;\n\n      if (!transition) {\n        return null;\n      }\n\n      var settings = Array.isArray(accessor) ? opts[accessor.find(function (a) {\n        return opts[a];\n      })] : opts[accessor]; // Shorthand: use duration instead of parameter object\n\n      if (Number.isFinite(settings)) {\n        settings = {\n          duration: settings\n        };\n      }\n\n      if (settings && settings.duration > 0) {\n        return Object.assign({}, transition, settings);\n      }\n\n      return null;\n    } // Checks that typed arrays for attributes are big enough\n    // sets alloc flag if not\n    // @return {Boolean} whether any updates are needed\n\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      this.userData.needsUpdate = this.userData.needsUpdate || reason;\n    }\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.id;\n      this.userData.needsRedraw = this.userData.needsRedraw || reason;\n    }\n  }, {\n    key: \"allocate\",\n    value: function allocate(numInstances) {\n      var state = this.userData;\n\n      if (state.isExternalBuffer || state.noAlloc) {\n        // Data is provided through a Buffer object.\n        return false;\n      } // Do we need to reallocate the attribute's typed array?\n\n\n      var instanceCount = this.getInstanceCount();\n      var needsAlloc = instanceCount === 0 || instanceCount < numInstances;\n\n      if (needsAlloc && (state.update || state.accessor)) {\n        assert(Number.isFinite(numInstances)); // Allocate at least one element to ensure a valid buffer\n\n        var allocCount = Math.max(numInstances, 1);\n        var ArrayType = glArrayFromType(this.type || GL.FLOAT);\n        this.constant = false;\n        this.value = new ArrayType(this.size * allocCount);\n        state.needsUpdate = true;\n        state.allocedInstances = allocCount;\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"updateBuffer\",\n    value: function updateBuffer(_ref2) {\n      var numInstances = _ref2.numInstances,\n          data = _ref2.data,\n          props = _ref2.props,\n          context = _ref2.context;\n\n      if (!this.needsUpdate()) {\n        return false;\n      }\n\n      var state = this.userData;\n      var update = state.update,\n          accessor = state.accessor;\n      var updated = true;\n\n      if (update) {\n        // Custom updater - typically for non-instanced layers\n        update.call(context, this, {\n          data: data,\n          props: props,\n          numInstances: numInstances\n        });\n        this.update({\n          value: this.value,\n          constant: this.constant\n        });\n\n        this._checkAttributeArray();\n      } else if (accessor) {\n        // Standard updater\n        this._updateBufferViaStandardAccessor(data, props);\n\n        this._checkAttributeArray();\n      } else {\n        updated = false;\n      }\n\n      state.needsUpdate = false;\n      state.needsRedraw = true;\n      return updated;\n    } // Use generic value\n    // Returns true if successful\n\n  }, {\n    key: \"setGenericValue\",\n    value: function setGenericValue(value) {\n      var state = this.userData;\n\n      if (value === undefined || typeof value === 'function') {\n        // ignore if this attribute has no accessor\n        // ignore if accessor is function, will be used in updateBuffer\n        state.isExternalBuffer = false;\n        return false;\n      }\n\n      value = this._normalizeValue(value);\n      var hasChanged = !this.constant || !this._areValuesEqual(value, this.value);\n\n      if (hasChanged) {\n        this.update({\n          constant: true,\n          value: value\n        });\n      }\n\n      state.needsRedraw = state.needsUpdate || hasChanged;\n      state.needsUpdate = false;\n      state.isExternalBuffer = true;\n      return true;\n    } // Use external buffer\n    // Returns true if successful\n\n  }, {\n    key: \"setExternalBuffer\",\n    value: function setExternalBuffer(buffer, numInstances) {\n      var state = this.userData;\n\n      if (buffer) {\n        state.isExternalBuffer = true;\n        state.needsUpdate = false;\n\n        if (buffer instanceof Buffer) {\n          if (this.externalBuffer !== buffer) {\n            this.update({\n              constant: false,\n              buffer: buffer\n            });\n            state.needsRedraw = true;\n          }\n        } else {\n          var ArrayType = glArrayFromType(this.type || GL.FLOAT);\n\n          if (!(buffer instanceof ArrayType)) {\n            throw new Error(\"Attribute \".concat(this.id, \" must be of type \").concat(ArrayType.name));\n          }\n\n          if (state.auto && buffer.length <= numInstances * this.size) {\n            throw new Error('Attribute prop array must match length and size');\n          }\n\n          if (this.value !== buffer) {\n            this.update({\n              constant: false,\n              value: buffer\n            });\n            state.needsRedraw = true;\n          }\n        }\n\n        return true;\n      }\n\n      state.isExternalBuffer = false;\n      return false;\n    } // PRIVATE HELPER METHODS\n\n    /* check user supplied values and apply fallback */\n\n  }, {\n    key: \"_normalizeValue\",\n    value: function _normalizeValue(value) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var defaultValue = this.userData.defaultValue;\n\n      if (!Array.isArray(value) && !ArrayBuffer.isView(value)) {\n        out[start] = Number.isFinite(value) ? value : defaultValue[0];\n        return out;\n      }\n      /* eslint-disable no-fallthrough, default-case */\n\n\n      switch (this.size) {\n        case 4:\n          out[start + 3] = Number.isFinite(value[3]) ? value[3] : defaultValue[3];\n\n        case 3:\n          out[start + 2] = Number.isFinite(value[2]) ? value[2] : defaultValue[2];\n\n        case 2:\n          out[start + 1] = Number.isFinite(value[1]) ? value[1] : defaultValue[1];\n\n        case 1:\n          out[start + 0] = Number.isFinite(value[0]) ? value[0] : defaultValue[0];\n      }\n\n      return out;\n    }\n  }, {\n    key: \"_areValuesEqual\",\n    value: function _areValuesEqual(value1, value2) {\n      var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.size;\n\n      for (var i = 0; i < size; i++) {\n        if (value1[i] !== value2[i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_updateBufferViaStandardAccessor\",\n    value: function _updateBufferViaStandardAccessor(data, props) {\n      var state = this.userData;\n      var accessor = state.accessor;\n      var value = this.value,\n          size = this.size;\n      var accessorFunc = props[accessor];\n      assert(typeof accessorFunc === 'function', \"accessor \\\"\".concat(accessor, \"\\\" is not a function\"));\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          var objectValue = accessorFunc(object);\n\n          this._normalizeValue(objectValue, value, i);\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.update({\n        value: value\n      });\n    } // Validate deck.gl level fields\n\n  }, {\n    key: \"_validateAttributeUpdaters\",\n    value: function _validateAttributeUpdaters() {\n      var state = this.userData; // Check that either 'accessor' or 'update' is a valid function\n\n      var hasUpdater = state.noAlloc || typeof state.update === 'function' || typeof state.accessor === 'string';\n\n      if (!hasUpdater) {\n        throw new Error(\"Attribute \".concat(this.id, \" missing update or accessor\"));\n      }\n    }\n  }, {\n    key: \"_checkAttributeArray\",\n    value: function _checkAttributeArray() {\n      var value = this.value;\n\n      if (value && value.length >= 4) {\n        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);\n\n        if (!valid) {\n          throw new Error(\"Illegal attribute generated for \".concat(this.id));\n        }\n      }\n    }\n  }, {\n    key: \"bufferLayout\",\n    get: function get() {\n      return this.userData.bufferLayout;\n    },\n    set: function set(layout) {\n      this.userData.bufferLayout = layout;\n    }\n  }]);\n\n  return LayerAttribute;\n}(Attribute);\n/* eslint-disable complexity */\n\n\nexport { LayerAttribute as default };\nexport function glArrayFromType(glType) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$clamped = _ref3.clamped,\n      clamped = _ref3$clamped === void 0 ? true : _ref3$clamped; // Sorted in some order of likelihood to reduce amount of comparisons\n\n\n  switch (glType) {\n    case GL.FLOAT:\n      return Float32Array;\n\n    case GL.UNSIGNED_SHORT:\n    case GL.UNSIGNED_SHORT_5_6_5:\n    case GL.UNSIGNED_SHORT_4_4_4_4:\n    case GL.UNSIGNED_SHORT_5_5_5_1:\n      return Uint16Array;\n\n    case GL.UNSIGNED_INT:\n      return Uint32Array;\n\n    case GL.UNSIGNED_BYTE:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n\n    case GL.BYTE:\n      return Int8Array;\n\n    case GL.SHORT:\n      return Int16Array;\n\n    case GL.INT:\n      return Int32Array;\n\n    default:\n      throw new Error('Failed to deduce type from array');\n  }\n}\n/* eslint-enable complexity */","map":null,"metadata":{},"sourceType":"module"}