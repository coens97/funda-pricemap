{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Attribute from './attribute';\nimport Object3D from './object-3d';\nimport { getDrawMode } from '../geometry/geometry';\nimport { Buffer, Query, Program, TransformFeedback, VertexArray, clear as _clear } from '../webgl';\nimport { isWebGL } from '../webgl-utils';\nimport { MODULAR_SHADERS } from '../shadertools/src/shaders';\nimport { assembleShaders } from '../shadertools/src';\nimport { addModel, removeModel, logModel, getOverrides } from '../debug/seer-integration';\nimport { getDebugTableForUniforms } from '../webgl-debug/debug-uniforms';\nimport { getDebugTableForVertexArray } from '../webgl-debug/debug-vertex-array';\nimport { getDebugTableForProgramConfiguration } from '../webgl-debug/debug-program-configuration';\nimport { log, isObjectEmpty } from '../utils';\nimport assert from '../utils/assert';\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';\nvar LOG_DRAW_PRIORITY = 2;\nvar LOG_DRAW_TIMEOUT = 10000; // These old picking uniforms should be avoided and we should use picking module\n// and set uniforms using Model class 'updateModuleSettings()'\n// TODO - move to shader modules\n\nvar DEPRECATED_PICKING_UNIFORMS = ['renderPickingBuffer', 'pickingEnabled']; // Model abstract O3D Class\n\nvar Model =\n/*#__PURE__*/\nfunction (_Object3D) {\n  _inherits(Model, _Object3D);\n\n  function Model(gl) {\n    var _this;\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Model);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Model).call(this, props));\n    assert(isWebGL(gl));\n    _this.gl = gl;\n    _this.lastLogTime = 0; // TODO - move to probe.gl\n\n    _this.initialize(props); // intended to be subclassed, do not seal\n\n\n    return _this;\n  }\n  /* eslint-disable max-statements  */\n\n  /* eslint-disable complexity  */\n\n\n  _createClass(Model, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.props = {};\n      this.program = this._createProgram(props); // Create a vertex array configured after this program\n\n      this.vertexArray = new VertexArray(this.gl, {\n        program: this.program\n      }); // Initialize state\n\n      this.userData = {};\n      this.needsRedraw = true; // Model manages auto Buffer creation from typed arrays\n\n      this._attributes = {}; // All attributes\n\n      this.attributes = {}; // User defined attributes\n      // Model manages uniform animation\n\n      this.animatedUniforms = {};\n      this.animated = false;\n      this.animationLoop = null; // if set, used as source for animationProps\n\n      this.timerQueryEnabled = false;\n      this.timeElapsedQuery = undefined;\n      this.lastQueryReturned = true;\n      this.stats = {\n        accumulatedFrameTime: 0,\n        averageFrameTime: 0,\n        profileFrameCount: 0\n      }; // picking options\n\n      this.pickable = true; // this.pick = pick || (() => false);\n\n      this.setProps(props); // Make sure we have some reasonable default uniforms in place\n\n      this.setUniforms(Object.assign({}, this.getModuleUniforms(), // Get all default uniforms\n      this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters\n      )); // Attributes and buffers\n      // geometry might have set drawMode and vertexCount\n\n      this.isInstanced = props.isInstanced || props.instanced;\n\n      this.onBeforeRender = props.onBeforeRender || function () {};\n\n      this.onAfterRender = props.onAfterRender || function () {}; // assert(program || program instanceof Program);\n\n\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      Object.assign(this.props, props); // params\n      // if ('drawMode' in props) {\n      //   this.drawMode = getDrawMode(props.drawMode);\n      // }\n      // if ('vertexCount' in props) {\n      //   this.vertexCount = props.vertexCount;\n      // }\n\n      if ('instanceCount' in props) {\n        this.instanceCount = props.instanceCount;\n      }\n\n      if ('geometry' in props) {\n        this.setGeometry(props.geometry);\n      } // webgl settings\n\n\n      if ('attributes' in props) {\n        this.setAttributes(props.attributes);\n      }\n\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms, props.samplers);\n      }\n\n      if ('pickable' in props) {\n        this.pickable = props.pickable;\n      } // Experimental props\n\n\n      if ('timerQueryEnabled' in props) {\n        this.timerQueryEnabled = props.timerQueryEnabled && Query.isSupported(this.gl, ['timers']);\n\n        if (props.timerQueryEnabled && !this.timerQueryEnabled) {\n          log.warn('GPU timer not supported')();\n        }\n      }\n\n      if ('_feedbackBuffers' in props) {\n        this._setFeedbackBuffers(props._feedbackBuffers);\n      }\n\n      if ('_animationProps' in props) {\n        this._setAnimationProps(props._animationProps);\n      }\n\n      if ('_animationLoop' in props) {\n        this.animationLoop = props._animationLoop;\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      // delete all attributes created by this model\n      // TODO - should buffer deletes be handled by vertex array?\n      for (var key in this._attributes) {\n        if (this._attributes[key] !== this.attributes[key]) {\n          this._attributes[key].delete();\n        }\n      }\n\n      this.program.delete();\n      this.vertexArray.delete();\n      removeModel(this.id);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.delete();\n    } // GETTERS\n\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$clearRedrawFlags = _ref.clearRedrawFlags,\n          clearRedrawFlags = _ref$clearRedrawFlags === void 0 ? false : _ref$clearRedrawFlags;\n\n      var redraw = false;\n      redraw = redraw || this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n\n      if (this.geometry) {\n        redraw = redraw || this.geometry.getNeedsRedraw({\n          clearRedrawFlags: clearRedrawFlags\n        });\n      }\n\n      if (this.animated) {\n        redraw = redraw || \"animated model \".concat(this.id);\n      }\n\n      return redraw;\n    }\n  }, {\n    key: \"getDrawMode\",\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: \"getInstanceCount\",\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: \"getProgram\",\n    value: function getProgram() {\n      return this.program;\n    }\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getUniforms\",\n    value: function getUniforms() {\n      return this.program.getUniforms;\n    } // SETTERS\n\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = redraw;\n      return this;\n    }\n  }, {\n    key: \"setDrawMode\",\n    value: function setDrawMode(drawMode) {\n      this.props.drawMode = getDrawMode(drawMode);\n      return this;\n    }\n  }, {\n    key: \"setVertexCount\",\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.props.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: \"setInstanceCount\",\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    } // TODO - just set attributes, don't hold on to geometry\n\n  }, {\n    key: \"setGeometry\",\n    value: function setGeometry(geometry) {\n      this.geometry = geometry;\n\n      var buffers = this._createBuffersFromAttributeDescriptors(this.geometry.getAttributes());\n\n      this.vertexArray.setAttributes(buffers);\n      this.setNeedsRedraw();\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Avoid setting needsRedraw if no attributes\n\n      if (isObjectEmpty(attributes)) {\n        return this;\n      }\n\n      Object.assign(this.attributes, attributes);\n\n      var buffers = this._createBuffersFromAttributeDescriptors(attributes); // Object.assign(this.attributes, buffers);\n\n\n      this.vertexArray.setAttributes(buffers);\n      this.setNeedsRedraw();\n      return this;\n    } // TODO - should actually set the uniforms\n\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var _this2 = this;\n\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var samplers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Let Seer override edited uniforms\n\n      uniforms = Object.assign({}, uniforms);\n      getOverrides(this.id, uniforms); // Resolve any animated uniforms so that we have an initial value\n\n      uniforms = this._extractAnimatedUniforms(uniforms);\n      this.program.setUniforms(uniforms, samplers, function () {\n        // if something changed\n        _this2._checkForDeprecatedUniforms(uniforms);\n\n        _this2.setNeedsRedraw();\n      });\n    } // Updates (evaluates) all function valued uniforms based on a new set of animationProps\n    // experimental\n\n  }, {\n    key: \"_setAnimationProps\",\n    value: function _setAnimationProps(animationProps) {\n      var _this3 = this;\n\n      if (this.animated) {\n        assert(animationProps, 'Model.draw(): animated uniforms but no animationProps');\n\n        var animatedUniforms = this._evaluateAnimateUniforms(animationProps);\n\n        this.program.setUniforms(animatedUniforms, {}, function () {\n          // if something changed\n          _this3._checkForDeprecatedUniforms(animatedUniforms);\n\n          _this3.setNeedsRedraw();\n        });\n      }\n    }\n  }, {\n    key: \"updateModuleSettings\",\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts || {});\n      return this.setUniforms(uniforms);\n    } // DRAW CALLS\n\n  }, {\n    key: \"clear\",\n    value: function clear(opts) {\n      _clear(this.program.gl, opts);\n\n      return this;\n    }\n    /* eslint-disable max-statements  */\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$moduleSettings = opts.moduleSettings,\n          moduleSettings = _opts$moduleSettings === void 0 ? null : _opts$moduleSettings,\n          framebuffer = opts.framebuffer,\n          _opts$uniforms = opts.uniforms,\n          uniforms = _opts$uniforms === void 0 ? {} : _opts$uniforms,\n          _opts$attributes = opts.attributes,\n          attributes = _opts$attributes === void 0 ? {} : _opts$attributes,\n          _opts$samplers = opts.samplers,\n          samplers = _opts$samplers === void 0 ? {} : _opts$samplers,\n          _opts$transformFeedba = opts.transformFeedback,\n          transformFeedback = _opts$transformFeedba === void 0 ? this.transformFeedback : _opts$transformFeedba,\n          _opts$parameters = opts.parameters,\n          parameters = _opts$parameters === void 0 ? {} : _opts$parameters,\n          _opts$vertexArray = opts.vertexArray,\n          vertexArray = _opts$vertexArray === void 0 ? this.vertexArray : _opts$vertexArray,\n          animationProps = opts.animationProps; // Update module settings\n\n      addModel(this); // Update model with any just provided attributes, settings or uniforms\n\n      this.setAttributes(attributes);\n      this.updateModuleSettings(moduleSettings);\n      this.setUniforms(uniforms, samplers); // Animate any function valued uniforms\n\n      this._refreshAnimationProps(animationProps);\n\n      var logPriority = this._logDrawCallStart(2);\n\n      var drawParams = this.vertexArray.getDrawParams(this.props);\n\n      if (drawParams.isInstanced && !this.isInstanced) {\n        log.warn('Found instanced attributes on non-instanced model', this.id)();\n      }\n\n      var isIndexed = drawParams.isIndexed,\n          indexType = drawParams.indexType;\n      var isInstanced = this.isInstanced,\n          instanceCount = this.instanceCount;\n      this.onBeforeRender();\n\n      this._timerQueryStart();\n\n      this.program.draw(Object.assign({}, opts, {\n        logPriority: logPriority,\n        uniforms: null,\n        // Already set (may contain \"function values\" not understood by Program)\n        framebuffer: framebuffer,\n        parameters: parameters,\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        vertexArray: vertexArray,\n        transformFeedback: transformFeedback,\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount\n      }));\n\n      this._timerQueryEnd();\n\n      this.onAfterRender();\n      this.setNeedsRedraw(false);\n\n      this._logDrawCallEnd(logPriority, vertexArray, framebuffer);\n\n      return this;\n    }\n    /* eslint-enable max-statements  */\n    // Draw call for transform feedback\n\n  }, {\n    key: \"transform\",\n    value: function transform() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$discard = opts.discard,\n          discard = _opts$discard === void 0 ? true : _opts$discard,\n          feedbackBuffers = opts.feedbackBuffers,\n          _opts$unbindModels = opts.unbindModels,\n          unbindModels = _opts$unbindModels === void 0 ? [] : _opts$unbindModels;\n      var parameters = opts.parameters;\n\n      if (feedbackBuffers) {\n        this._setFeedbackBuffers(feedbackBuffers);\n      }\n\n      if (discard) {\n        parameters = Object.assign({}, parameters, _defineProperty({}, 35977, discard));\n      }\n\n      unbindModels.forEach(function (model) {\n        return model.vertexArray.unbindBuffers();\n      });\n\n      try {\n        this.draw(Object.assign({}, opts, {\n          parameters: parameters\n        }));\n      } finally {\n        unbindModels.forEach(function (model) {\n          return model.vertexArray.bindBuffers();\n        });\n      }\n\n      return this;\n    } // DEPRECATED METHODS\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      assert(arguments.length <= 1); // log.deprecated('Model.render()', 'Model.draw()')();\n\n      return this.draw({\n        uniforms: uniforms\n      });\n    } // PRIVATE METHODS\n\n  }, {\n    key: \"_createProgram\",\n    value: function _createProgram(_ref2) {\n      var _ref2$vs = _ref2.vs,\n          vs = _ref2$vs === void 0 ? null : _ref2$vs,\n          _ref2$fs = _ref2.fs,\n          fs = _ref2$fs === void 0 ? null : _ref2$fs,\n          _ref2$modules = _ref2.modules,\n          modules = _ref2$modules === void 0 ? null : _ref2$modules,\n          _ref2$defines = _ref2.defines,\n          defines = _ref2$defines === void 0 ? {} : _ref2$defines,\n          _ref2$inject = _ref2.inject,\n          inject = _ref2$inject === void 0 ? {} : _ref2$inject,\n          _ref2$shaderCache = _ref2.shaderCache,\n          shaderCache = _ref2$shaderCache === void 0 ? null : _ref2$shaderCache,\n          _ref2$varyings = _ref2.varyings,\n          varyings = _ref2$varyings === void 0 ? null : _ref2$varyings,\n          _ref2$bufferMode = _ref2.bufferMode,\n          bufferMode = _ref2$bufferMode === void 0 ? 35981 : _ref2$bufferMode,\n          _ref2$program = _ref2.program,\n          program = _ref2$program === void 0 ? null : _ref2$program;\n\n      this.getModuleUniforms = function (x) {};\n\n      var id = this.id;\n\n      if (!program) {\n        // Assign default shaders if none are provided\n        vs = vs || MODULAR_SHADERS.vs;\n        fs = fs || MODULAR_SHADERS.fs;\n        var assembleResult = assembleShaders(this.gl, {\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          inject: inject,\n          defines: defines,\n          log: log\n        });\n        vs = assembleResult.vs;\n        fs = assembleResult.fs;\n\n        if (shaderCache) {\n          program = shaderCache.getProgram(this.gl, {\n            id: id,\n            vs: vs,\n            fs: fs\n          });\n        } else {\n          program = new Program(this.gl, {\n            id: id,\n            vs: vs,\n            fs: fs,\n            varyings: varyings,\n            bufferMode: bufferMode\n          });\n        }\n\n        this.getModuleUniforms = assembleResult.getUniforms || function (x) {};\n      }\n\n      assert(program instanceof Program, 'Model needs a program');\n      return program;\n    }\n    /* eslint-enable complexity */\n    // Uniforms\n\n  }, {\n    key: \"_checkForDeprecatedUniforms\",\n    value: function _checkForDeprecatedUniforms(uniforms) {\n      // deprecated picking uniforms\n      DEPRECATED_PICKING_UNIFORMS.forEach(function (uniform) {\n        if (uniform in uniforms) {\n          log.deprecated(uniform, 'use picking shader module and Model class updateModuleSettings()')();\n        }\n      });\n    } // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered\n\n  }, {\n    key: \"_refreshAnimationProps\",\n    value: function _refreshAnimationProps(animationProps) {\n      // Try to read animationProps\n      animationProps = animationProps || this.animationLoop && this.animationLoop.animationProps;\n\n      if (animationProps) {\n        this._setAnimationProps(animationProps);\n      }\n    } // Calculate new values for any function uniforms based on supplied animationProps\n\n  }, {\n    key: \"_evaluateAnimateUniforms\",\n    value: function _evaluateAnimateUniforms(animationProps) {\n      if (!this.animated) {\n        return {};\n      }\n\n      var animatedUniforms = {};\n\n      for (var uniformName in this.animatedUniforms) {\n        var valueFunction = this.animatedUniforms[uniformName];\n        animatedUniforms[uniformName] = valueFunction(animationProps);\n      }\n\n      return animatedUniforms;\n    } // Extracts a list of function valued uniforms, so we can update them before each draw call\n    // Also removes such uniforms from the returned list\n\n  }, {\n    key: \"_extractAnimatedUniforms\",\n    value: function _extractAnimatedUniforms(uniforms) {\n      var foundAnimated = false; // Keep our animatedUniforms map up-to-date\n\n      for (var uniformName in uniforms) {\n        var newValue = uniforms[uniformName];\n\n        if (typeof newValue === 'function') {\n          this.animatedUniforms[uniformName] = newValue;\n          foundAnimated = true;\n        } else {\n          delete this.animatedUniforms[uniformName];\n        }\n      } // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)\n\n\n      this.animated = !isObjectEmpty(this.animatedUniforms);\n\n      if (!foundAnimated) {\n        return uniforms;\n      } // If animated uniforms were found, remove them from ordinary uniform list\n      // `Program` class can't (and shouldn't) handle function valued uniforms\n\n\n      var staticUniforms = {};\n\n      for (var _uniformName in uniforms) {\n        if (!this.animatedUniforms[_uniformName]) {\n          staticUniforms[_uniformName] = uniforms[_uniformName];\n        }\n      }\n\n      return staticUniforms;\n    } // Transform Feedback\n\n  }, {\n    key: \"_setFeedbackBuffers\",\n    value: function _setFeedbackBuffers() {\n      var feedbackBuffers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Avoid setting needsRedraw if no feedbackBuffers\n\n      if (isObjectEmpty(feedbackBuffers)) {\n        return this;\n      }\n\n      var gl = this.program.gl;\n      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {\n        program: this.program\n      });\n      this.transformFeedback.setBuffers(feedbackBuffers);\n      this.setNeedsRedraw();\n      return this;\n    } // Timer Queries\n\n  }, {\n    key: \"_timerQueryStart\",\n    value: function _timerQueryStart() {\n      if (this.timerQueryEnabled === true) {\n        if (!this.timeElapsedQuery) {\n          this.timeElapsedQuery = new Query(this.gl);\n        }\n\n        if (this.lastQueryReturned) {\n          this.lastQueryReturned = false;\n          this.timeElapsedQuery.beginTimeElapsedQuery();\n        }\n      }\n    }\n  }, {\n    key: \"_timerQueryEnd\",\n    value: function _timerQueryEnd() {\n      if (this.timerQueryEnabled === true) {\n        this.timeElapsedQuery.end(); // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n        // should this be incorporated into Query object?\n\n        if (this.timeElapsedQuery.isResultAvailable()) {\n          this.lastQueryReturned = true;\n          var elapsedTime = this.timeElapsedQuery.getResult(); // Update stats (e.g. for seer)\n\n          this.stats.lastFrameTime = elapsedTime;\n          this.stats.accumulatedFrameTime += elapsedTime;\n          this.stats.profileFrameCount++;\n          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount; // Log stats\n\n          log.log(LOG_DRAW_PRIORITY, \"GPU time \".concat(this.program.id, \": \").concat(this.stats.lastFrameTime, \"ms average \").concat(this.stats.averageFrameTime, \"ms accumulated: \").concat(this.stats.accumulatedFrameTime, \"ms count: \").concat(this.stats.profileFrameCount))();\n        }\n      }\n    } // Makes sure buffers are created for all attributes\n    // and that the program is updated with those buffers\n    // TODO - do we need the separation between \"attributes\" and \"buffers\"\n    // couldn't apps just create buffers directly?\n\n  }, {\n    key: \"_createBuffersFromAttributeDescriptors\",\n    value: function _createBuffersFromAttributeDescriptors(attributes) {\n      var gl = this.program.gl; // const attributes = {};\n\n      var buffers = {};\n\n      for (var attributeName in attributes) {\n        var descriptor = attributes[attributeName];\n        var attribute = this._attributes[attributeName];\n\n        if (descriptor instanceof Attribute) {\n          attribute = descriptor;\n        } else if (descriptor instanceof Buffer) {\n          attribute = attribute || new Attribute(gl, Object.assign({}, descriptor, descriptor.layout, {\n            id: attributeName\n          }));\n          attribute.update({\n            buffer: descriptor\n          });\n        } else if (attribute) {\n          attribute.update(descriptor);\n        } else {\n          attribute = new Attribute(gl, Object.assign({}, descriptor, {\n            id: attributeName\n          }));\n        }\n\n        this._attributes[attributeName] = attribute;\n        buffers[attributeName] = attribute.getValue();\n      }\n\n      return buffers;\n    }\n  }, {\n    key: \"_logDrawCallStart\",\n    value: function _logDrawCallStart(priority) {\n      var logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;\n\n      if (log.priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {\n        return undefined;\n      }\n\n      this.lastLogTime = Date.now();\n      log.group(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id), {\n        collapsed: log.priority <= 2\n      })();\n      return priority;\n    }\n  }, {\n    key: \"_logDrawCallEnd\",\n    value: function _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {\n      // HACK: priority === undefined means logDrawCallStart didn't run\n      if (priority === undefined) {\n        return;\n      }\n\n      var attributeTable = getDebugTableForVertexArray({\n        vertexArray: vertexArray,\n        header: \"\".concat(this.id, \" attributes\"),\n        attributes: this._attributes\n      });\n\n      var _getDebugTableForUnif = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms)\n      }),\n          uniformTable = _getDebugTableForUnif.table,\n          unusedTable = _getDebugTableForUnif.unusedTable,\n          unusedCount = _getDebugTableForUnif.unusedCount; // log missing uniforms\n\n\n      var _getDebugTableForUnif2 = getDebugTableForUniforms({\n        header: \"\".concat(this.id, \" uniforms\"),\n        program: this.program,\n        uniforms: Object.assign({}, this.program.uniforms, uniforms),\n        undefinedOnly: true\n      }),\n          missingTable = _getDebugTableForUnif2.table,\n          missingCount = _getDebugTableForUnif2.count;\n\n      if (missingCount > 0) {\n        log.log('MISSING UNIFORMS', Object.keys(missingTable))(); // log.table(priority, missingTable)();\n      }\n\n      if (unusedCount > 0) {\n        log.log('UNUSED UNIFORMS', Object.keys(unusedTable))(); // log.log(priority, 'Unused uniforms ', unusedTable)();\n      }\n\n      var configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);\n      log.table(priority, attributeTable)();\n      log.table(priority, uniformTable)();\n      log.table(priority + 1, configTable)();\n      logModel(this, uniforms);\n\n      if (framebuffer) {\n        framebuffer.log({\n          priority: LOG_DRAW_PRIORITY,\n          message: \"Rendered to \".concat(framebuffer.id)\n        });\n      }\n\n      log.groupEnd(LOG_DRAW_PRIORITY, \">>> DRAWING MODEL \".concat(this.id))();\n    }\n  }, {\n    key: \"vertexCount\",\n    get: function get() {\n      if (Number.isFinite(this.props.vertexCount)) {\n        return this.props.vertexCount;\n      }\n\n      return this.geometry && this.geometry.getVertexCount();\n    }\n  }, {\n    key: \"drawMode\",\n    get: function get() {\n      if (Number.isFinite(this.props.drawMode)) {\n        return this.props.drawMode;\n      }\n\n      return this.geometry && this.geometry.drawMode;\n    }\n  }]);\n\n  return Model;\n}(Object3D);\n\nexport { Model as default };","map":null,"metadata":{},"sourceType":"module"}