{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\n\n\nimport { COORDINATE_SYSTEM, LIFECYCLE } from './constants';\nimport AttributeManager from './attribute-manager';\nimport Stats from './stats';\nimport { getDefaultProps, diffProps as _diffProps } from './props';\nimport { count } from '../utils/count';\nimport log from '../utils/log';\nimport { applyPropOverrides, removeLayerInSeer } from './seer-integration';\nimport { GL, withParameters } from 'luma.gl';\nimport assert from 'assert';\nvar LOG_PRIORITY_UPDATE = 1;\nvar EMPTY_ARRAY = [];\nvar EMPTY_PROPS = {};\nObject.freeze(EMPTY_PROPS);\n\nvar noop = function noop() {};\n\nvar defaultProps = {\n  // data: Special handling for null, see below\n  dataComparator: null,\n  updateTriggers: {},\n  // Update triggers: a core change detection mechanism in deck.gl\n  numInstances: undefined,\n  visible: true,\n  pickable: false,\n  opacity: 0.8,\n  onHover: noop,\n  onClick: noop,\n  coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\n  coordinateOrigin: [0, 0, 0],\n  parameters: {},\n  uniforms: {},\n  framebuffer: null,\n  animation: null,\n  // Passed prop animation functions to evaluate props\n  // Offset depth based on layer index to avoid z-fighting.\n  // Negative values pull layer towards the camera\n  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm\n  getPolygonOffset: function getPolygonOffset(_ref) {\n    var layerIndex = _ref.layerIndex;\n    return [0, -layerIndex * 100];\n  },\n  // Selection/Highlighting\n  highlightedObjectIndex: null,\n  autoHighlight: false,\n  highlightColor: [0, 0, 128, 128]\n};\nvar counter = 0;\n\nvar Layer = function () {\n  function Layer(props) {\n    _classCallCheck(this, Layer); // Call a helper function to merge the incoming props with defaults and freeze them.\n\n\n    this.props = this._normalizeProps(props); // Define all members before layer is sealed\n\n    this.id = this.props.id; // The layer's id, used for matching with layers from last render cycle\n\n    this.oldProps = EMPTY_PROPS; // Props from last render used for change detection\n\n    this.count = counter++; // Keep track of how many layer instances you are generating\n\n    this.lifecycle = LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers\n\n    this.state = null; // Will be set to the shared layer state object during layer matching\n\n    this.context = null; // Will reference layer manager's context, contains state shared by layers\n\n    this.parentLayer = null; // reference to the composite layer parent that rendered this layer\n    // CompositeLayer members, need to be defined here because of the `Object.seal`\n\n    this.internalState = null; // Seal the layer\n\n    Object.seal(this);\n  }\n\n  _createClass(Layer, [{\n    key: 'toString',\n    value: function toString() {\n      var className = this.constructor.layerName || this.constructor.name;\n      return className + '({id: \\'' + this.props.id + '\\'})';\n    }\n  }, {\n    key: 'needsUpdate',\n    value: function needsUpdate() {\n      // Call subclass lifecycle method\n      return this.shouldUpdateState(this._getUpdateParams()); // End lifecycle method\n    } // Checks state of attributes and model\n\n  }, {\n    key: 'getNeedsRedraw',\n    value: function getNeedsRedraw() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,\n          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? false : _ref2$clearRedrawFlag;\n\n      return this._getNeedsRedraw(clearRedrawFlags);\n    } // //////////////////////////////////////////////////\n    // LIFECYCLE METHODS, overridden by the layer subclasses\n    // Called once to set up the initial state\n    // App can create WebGL resources\n\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      throw new Error('Layer ' + this + ' has not defined initializeState');\n    } // Let's layer control if updateState should be called\n\n  }, {\n    key: 'shouldUpdateState',\n    value: function shouldUpdateState(_ref3) {\n      var oldProps = _ref3.oldProps,\n          props = _ref3.props,\n          oldContext = _ref3.oldContext,\n          context = _ref3.context,\n          changeFlags = _ref3.changeFlags;\n      return changeFlags.propsOrDataChanged;\n    } // Default implementation, all attributes will be invalidated and updated\n    // when data changes\n\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref4) {\n      var oldProps = _ref4.oldProps,\n          props = _ref4.props,\n          oldContext = _ref4.oldContext,\n          context = _ref4.context,\n          changeFlags = _ref4.changeFlags;\n      var attributeManager = this.state.attributeManager;\n\n      if (changeFlags.dataChanged && attributeManager) {\n        attributeManager.invalidateAll();\n      }\n    } // Called once when layer is no longer matched and state will be discarded\n    // App can destroy WebGL resources here\n\n  }, {\n    key: 'finalizeState',\n    value: function finalizeState() {} // If state has a model, draw it with supplied uniforms\n\n  }, {\n    key: 'draw',\n    value: function draw(opts) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.getModels()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var model = _step.value;\n          model.draw(opts);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } // called to populate the info object that is passed to the event handler\n    // @return null to cancel event\n\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(_ref5) {\n      var info = _ref5.info,\n          mode = _ref5.mode;\n      var index = info.index;\n\n      if (index >= 0) {\n        // If props.data is an indexable array, get the object\n        if (Array.isArray(this.props.data)) {\n          info.object = this.props.data[index];\n        }\n      }\n\n      return info;\n    } // END LIFECYCLE METHODS\n    // //////////////////////////////////////////////////\n    // Returns true if the layer is pickable and visible.\n\n  }, {\n    key: 'isPickable',\n    value: function isPickable() {\n      return this.props.pickable && this.props.visible;\n    } // Default implementation of attribute invalidation, can be redefined\n\n  }, {\n    key: 'invalidateAttribute',\n    value: function invalidateAttribute() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';\n      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var attributeManager = this.state.attributeManager;\n\n      if (!attributeManager) {\n        return;\n      }\n\n      if (name === 'all') {\n        log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);\n        attributeManager.invalidateAll();\n      } else {\n        log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + name + ': ' + diffReason);\n        attributeManager.invalidate(name);\n      }\n    } // Calls attribute manager to update any WebGL attributes, can be redefined\n\n  }, {\n    key: 'updateAttributes',\n    value: function updateAttributes(props) {\n      var attributeManager = this.state.attributeManager;\n\n      if (!attributeManager) {\n        return;\n      } // Figure out data length\n\n\n      var numInstances = this.getNumInstances(props);\n      attributeManager.update({\n        data: props.data,\n        numInstances: numInstances,\n        props: props,\n        buffers: props,\n        context: this,\n        // Don't worry about non-attribute props\n        ignoreUnknownAttributes: true\n      }); // TODO - Use getModels?\n\n      var model = this.state.model;\n\n      if (model) {\n        var changedAttributes = attributeManager.getChangedAttributes({\n          clearChangedFlags: true\n        });\n        model.setAttributes(changedAttributes);\n      }\n    } // Public API\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: 'setState',\n    value: function setState(updateObject) {\n      Object.assign(this.state, updateObject);\n      this.state.needsRedraw = true;\n    } // Sets the redraw flag for this layer, will trigger a redraw next animation frame\n\n  }, {\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.state) {\n        this.state.needsRedraw = redraw;\n      }\n    } // Return an array of models used by this layer, can be overriden by layer subclass\n\n  }, {\n    key: 'getModels',\n    value: function getModels() {\n      return this.state.models || (this.state.model ? [this.state.model] : []);\n    } // PROJECTION METHODS\n\n    /**\n     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)\n     *\n     * Note: Position conversion is done in shader, so in many cases there is no need\n     * for this function\n     * @param {Array|TypedArray} lngLat - long and lat values\n     * @return {Array|TypedArray} - x, y coordinates\n     */\n\n  }, {\n    key: 'project',\n    value: function project(lngLat) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n      return viewport.project(lngLat);\n    }\n  }, {\n    key: 'unproject',\n    value: function unproject(xy) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n      return viewport.unproject(xy);\n    }\n  }, {\n    key: 'projectFlat',\n    value: function projectFlat(lngLat) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n      return viewport.projectFlat(lngLat);\n    }\n  }, {\n    key: 'unprojectFlat',\n    value: function unprojectFlat(xy) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n      return viewport.unprojectFlat(xy);\n    } // TODO - needs to refer to context\n\n  }, {\n    key: 'screenToDevicePixels',\n    value: function screenToDevicePixels(screenPixels) {\n      log.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion');\n      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n      return screenPixels * devicePixelRatio;\n    }\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @return {Array} - a black color\n     */\n\n  }, {\n    key: 'nullPickingColor',\n    value: function nullPickingColor() {\n      return [0, 0, 0];\n    }\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @param {int} i - index to be decoded\n     * @return {Array} - the decoded color\n     */\n\n  }, {\n    key: 'encodePickingColor',\n    value: function encodePickingColor(i) {\n      assert((i + 1 >> 24 & 255) === 0, 'index out of picking color range');\n      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];\n    }\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @param {Uint8Array} color - color array to be decoded\n     * @return {Array} - the decoded picking color\n     */\n\n  }, {\n    key: 'decodePickingColor',\n    value: function decodePickingColor(color) {\n      assert(color instanceof Uint8Array);\n\n      var _color = _slicedToArray(color, 3),\n          i1 = _color[0],\n          i2 = _color[1],\n          i3 = _color[2]; // 1 was added to seperate from no selection\n\n\n      var index = i1 + i2 * 256 + i3 * 65536 - 1;\n      return index;\n    }\n  }, {\n    key: 'calculateInstancePickingColors',\n    value: function calculateInstancePickingColors(attribute, _ref6) {\n      var numInstances = _ref6.numInstances;\n      var value = attribute.value,\n          size = attribute.size; // add 1 to index to seperate from no selection\n\n      for (var i = 0; i < numInstances; i++) {\n        var pickingColor = this.encodePickingColor(i);\n        value[i * size + 0] = pickingColor[0];\n        value[i * size + 1] = pickingColor[1];\n        value[i * size + 2] = pickingColor[2];\n      }\n    } // DATA ACCESS API\n    // Data can use iterators and may not be random access\n    // Use iteration (the only required capability on data) to get first element\n\n  }, {\n    key: 'getFirstObject',\n    value: function getFirstObject() {\n      var data = this.props.data;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n          return object;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    } // INTERNAL METHODS\n    // Deduces numer of instances. Intention is to support:\n    // - Explicit setting of numInstances\n    // - Auto-deduction for ES6 containers that define a size member\n    // - Auto-deduction for Classic Arrays via the built-in length attribute\n    // - Auto-deduction via arrays\n\n  }, {\n    key: 'getNumInstances',\n    value: function getNumInstances(props) {\n      props = props || this.props; // First check if the layer has set its own value\n\n      if (this.state && this.state.numInstances !== undefined) {\n        return this.state.numInstances;\n      } // Check if app has provided an explicit value\n\n\n      if (props.numInstances !== undefined) {\n        return props.numInstances;\n      } // Use container library to get a count for any ES6 container or object\n\n\n      var _props = props,\n          data = _props.data;\n      return count(data);\n    } // clone this layer with modified props\n\n  }, {\n    key: 'clone',\n    value: function clone(newProps) {\n      return new this.constructor(Object.assign({}, this.props, newProps));\n    } // LAYER MANAGER API\n    // Should only be called by the deck.gl LayerManager class\n    // Called by layer manager when a new layer is found\n\n    /* eslint-disable max-statements */\n\n  }, {\n    key: '_initialize',\n    value: function _initialize() {\n      assert(arguments.length === 0);\n      assert(this.context.gl);\n      assert(!this.state);\n      var attributeManager = new AttributeManager({\n        id: this.props.id\n      }); // All instanced layers get instancePickingColors attribute by default\n      // Their shaders can use it to render a picking scene\n      // TODO - this slightly slows down non instanced layers\n\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          update: this.calculateInstancePickingColors\n        }\n      });\n      this.internalState = {\n        subLayers: null,\n        // reference to sublayers rendered in a previous cycle\n        stats: new Stats({\n          id: 'draw'\n        }) // animatedProps: null, // Computing animated props requires layer manager state\n        // TODO - move these fields here (risks breaking layers)\n        // attributeManager,\n        // needsRedraw: true,\n\n      };\n      this.state = {\n        attributeManager: attributeManager,\n        model: null,\n        needsRedraw: true\n      }; // Call subclass lifecycle methods\n\n      this.initializeState(this.context); // End subclass lifecycle methods\n      // initializeState callback tends to clear state\n\n      this.setChangeFlags({\n        dataChanged: true,\n        propsChanged: true,\n        viewportChanged: true\n      });\n\n      this._updateState(this._getUpdateParams());\n\n      if (this.isComposite) {\n        this._renderLayers(true);\n      }\n\n      var model = this.state.model;\n\n      if (model) {\n        model.id = this.props.id;\n        model.program.id = this.props.id + '-program';\n        model.geometry.id = this.props.id + '-geometry';\n        model.setAttributes(attributeManager.getAttributes());\n      } // Last but not least, update any sublayers\n\n\n      if (this.isComposite) {\n        this._renderLayers();\n      }\n\n      this.clearChangeFlags();\n    } // Called by layer manager\n    // if this layer is new (not matched with an existing layer) oldProps will be empty object\n\n  }, {\n    key: '_update',\n    value: function _update() {\n      assert(arguments.length === 0); // Call subclass lifecycle method\n\n      var stateNeedsUpdate = this.needsUpdate(); // End lifecycle method\n\n      var updateParams = {\n        props: this.props,\n        oldProps: this.oldProps,\n        context: this.context,\n        oldContext: this.oldContext,\n        changeFlags: this.internalState.changeFlags\n      };\n\n      if (stateNeedsUpdate) {\n        this._updateState(updateParams);\n      } // Render or update previously rendered sublayers\n\n\n      if (this.isComposite) {\n        this._renderLayers(stateNeedsUpdate);\n      }\n\n      this.clearChangeFlags();\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: '_updateState',\n    value: function _updateState(updateParams) {\n      // Call subclass lifecycle methods\n      this.updateState(updateParams); // End subclass lifecycle methods\n      // Add any subclass attributes\n\n      this.updateAttributes(this.props);\n\n      this._updateBaseUniforms();\n\n      this._updateModuleSettings(); // Note: Automatic instance count update only works for single layers\n\n\n      if (this.state.model) {\n        this.state.model.setInstanceCount(this.getNumInstances());\n      }\n    } // Called by manager when layer is about to be disposed\n    // Note: not guaranteed to be called on application shutdown\n\n  }, {\n    key: '_finalize',\n    value: function _finalize() {\n      assert(arguments.length === 0); // Call subclass lifecycle method\n\n      this.finalizeState(this.context); // End lifecycle method\n\n      removeLayerInSeer(this.id);\n    } // Calculates uniforms\n\n  }, {\n    key: 'drawLayer',\n    value: function drawLayer(_ref7) {\n      var _this = this;\n\n      var _ref7$moduleParameter = _ref7.moduleParameters,\n          moduleParameters = _ref7$moduleParameter === undefined ? null : _ref7$moduleParameter,\n          _ref7$uniforms = _ref7.uniforms,\n          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms,\n          _ref7$parameters = _ref7.parameters,\n          parameters = _ref7$parameters === undefined ? {} : _ref7$parameters; // TODO/ib - hack move to luma Model.draw\n\n      if (moduleParameters) {\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var model = _step3.value;\n            model.updateModuleSettings(moduleParameters);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      } // Apply polygon offset to avoid z-fighting\n      // TODO - move to draw-layers\n\n\n      var getPolygonOffset = this.props.getPolygonOffset;\n      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];\n      parameters.polygonOffset = offsets; // Call subclass lifecycle method\n\n      withParameters(this.context.gl, parameters, function () {\n        _this.draw({\n          moduleParameters: moduleParameters,\n          uniforms: uniforms,\n          parameters: parameters,\n          context: _this.context\n        });\n      }); // End lifecycle method\n    } // {uniforms = {}, ...opts}\n\n  }, {\n    key: 'pickLayer',\n    value: function pickLayer(opts) {\n      // Call subclass lifecycle method\n      return this.getPickingInfo(opts); // End lifecycle method\n    } // Helper methods\n\n  }, {\n    key: 'getChangeFlags',\n    value: function getChangeFlags() {\n      return this.internalState.changeFlags;\n    } // Dirty some change flags, will be handled by updateLayer\n\n    /* eslint-disable complexity */\n\n  }, {\n    key: 'setChangeFlags',\n    value: function setChangeFlags(flags) {\n      var _this2 = this;\n\n      this.internalState.changeFlags = this.internalState.changeFlags || {};\n      var changeFlags = this.internalState.changeFlags; // Update primary flags\n\n      if (flags.dataChanged && !changeFlags.dataChanged) {\n        changeFlags.dataChanged = flags.dataChanged;\n        log.log(LOG_PRIORITY_UPDATE + 1, function () {\n          return 'dataChanged: ' + flags.dataChanged + ' in ' + _this2.id;\n        });\n      }\n\n      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {\n        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;\n        log.log(LOG_PRIORITY_UPDATE + 1, function () {\n          return 'updateTriggersChanged: ' + (Object.keys(flags.updateTriggersChanged).join(', ') + ' in ' + _this2.id);\n        });\n      }\n\n      if (flags.propsChanged && !changeFlags.propsChanged) {\n        changeFlags.propsChanged = flags.propsChanged;\n        log.log(LOG_PRIORITY_UPDATE + 1, function () {\n          return 'propsChanged: ' + flags.propsChanged + ' in ' + _this2.id;\n        });\n      }\n\n      if (flags.viewportChanged && !changeFlags.viewportChanged) {\n        changeFlags.viewportChanged = flags.viewportChanged;\n        log.log(LOG_PRIORITY_UPDATE + 2, function () {\n          return 'viewportChanged: ' + flags.viewportChanged + ' in ' + _this2.id;\n        });\n      } // Update composite flags\n\n\n      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;\n      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;\n      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged;\n    }\n    /* eslint-enable complexity */\n    // Clear all changeFlags, typically after an update\n\n  }, {\n    key: 'clearChangeFlags',\n    value: function clearChangeFlags() {\n      this.internalState.changeFlags = {\n        // Primary changeFlags, can be strings stating reason for change\n        dataChanged: false,\n        propsChanged: false,\n        updateTriggersChanged: false,\n        viewportChanged: false,\n        // Derived changeFlags\n        propsOrDataChanged: false,\n        somethingChanged: false\n      };\n    }\n  }, {\n    key: 'printChangeFlags',\n    value: function printChangeFlags() {\n      var flags = this.internalState.changeFlags;\n      return '' + (flags.dataChanged ? 'data ' : '') + (flags.propsChanged ? 'props ' : '') + (flags.updateTriggersChanged ? 'triggers ' : '') + (flags.viewportChanged ? 'viewport' : '');\n    } // Compares the layers props with old props from a matched older layer\n    // and extracts change flags that describe what has change so that state\n    // can be update correctly with minimal effort\n    // TODO - arguments for testing only\n\n  }, {\n    key: 'diffProps',\n    value: function diffProps() {\n      var newProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.props;\n      var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.oldProps;\n\n      var changeFlags = _diffProps(newProps, oldProps); // iterate over changedTriggers\n\n\n      if (changeFlags.updateTriggersChanged) {\n        for (var key in changeFlags.updateTriggersChanged) {\n          if (changeFlags.updateTriggersChanged[key]) {\n            this._activeUpdateTrigger(key);\n          }\n        }\n      }\n\n      return this.setChangeFlags(changeFlags);\n    } // PRIVATE METHODS\n\n  }, {\n    key: '_getUpdateParams',\n    value: function _getUpdateParams() {\n      return {\n        props: this.props,\n        oldProps: this.oldProps,\n        context: this.context,\n        oldContext: this.oldContext || {},\n        changeFlags: this.internalState.changeFlags\n      };\n    } // Checks state of attributes and model\n\n  }, {\n    key: '_getNeedsRedraw',\n    value: function _getNeedsRedraw(clearRedrawFlags) {\n      // this method may be called by the render loop as soon a the layer\n      // has been created, so guard against uninitialized state\n      if (!this.state) {\n        return false;\n      }\n\n      var redraw = false;\n      redraw = redraw || this.state.needsRedraw && this.id;\n      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags; // TODO - is attribute manager needed? - Model should be enough.\n\n      var attributeManager = this.state.attributeManager;\n      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw({\n        clearRedrawFlags: clearRedrawFlags\n      });\n      redraw = redraw || attributeManagerNeedsRedraw;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var model = _step4.value;\n          var modelNeedsRedraw = model.getNeedsRedraw({\n            clearRedrawFlags: clearRedrawFlags\n          });\n\n          if (modelNeedsRedraw && typeof modelNeedsRedraw !== 'string') {\n            modelNeedsRedraw = 'model ' + model.id;\n          }\n\n          redraw = redraw || modelNeedsRedraw;\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return redraw;\n    } // Helper for constructor, merges props with default props and freezes them\n\n  }, {\n    key: '_normalizeProps',\n    value: function _normalizeProps(props) {\n      // If sublayer has static defaultProps member, getDefaultProps will return it\n      var mergedDefaultProps = getDefaultProps(this); // Merge supplied props with pre-merged default props\n\n      props = Object.assign({}, mergedDefaultProps, props); // Accept null as data - otherwise apps and layers need to add ugly checks\n      // Use constant fallback so that data change is not triggered\n\n      props.data = props.data || EMPTY_ARRAY; // Apply any overrides from the seer debug extension if it is active\n\n      applyPropOverrides(props); // Props are immutable\n\n      Object.freeze(props);\n      return props;\n    } // Called by layer manager to transfer state from an old layer\n\n  }, {\n    key: '_transferState',\n    value: function _transferState(oldLayer) {\n      var state = oldLayer.state,\n          internalState = oldLayer.internalState,\n          props = oldLayer.props;\n      assert(state && internalState); // Move state\n\n      state.layer = this;\n      this.state = state;\n      this.internalState = internalState; // Note: We keep the state ref on old layers to support async actions\n      // oldLayer.state = null;\n      // Keep a temporary ref to the old props, for prop comparison\n\n      this.oldProps = props; // Update model layer reference\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var model = _step5.value;\n          model.userData.layer = this;\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      this.diffProps();\n    } // Operate on each changed triggers, will be called when an updateTrigger changes\n\n  }, {\n    key: '_activeUpdateTrigger',\n    value: function _activeUpdateTrigger(propName) {\n      this.invalidateAttribute(propName);\n    } //  Helper to check that required props are supplied\n\n  }, {\n    key: '_checkRequiredProp',\n    value: function _checkRequiredProp(propertyName, condition) {\n      var value = this.props[propertyName];\n\n      if (value === undefined) {\n        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);\n      }\n\n      if (condition && !condition(value)) {\n        throw new Error('Bad property ' + propertyName + ' in layer ' + this);\n      }\n    }\n  }, {\n    key: '_updateBaseUniforms',\n    value: function _updateBaseUniforms() {\n      var uniforms = {\n        // apply gamma to opacity to make it visually \"linear\"\n        opacity: Math.pow(this.props.opacity, 1 / 2.2),\n        ONE: 1.0\n      };\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var model = _step6.value;\n          model.setUniforms(uniforms);\n        } // TODO - set needsRedraw on the model(s)?\n\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      this.state.needsRedraw = true;\n    }\n  }, {\n    key: '_updateModuleSettings',\n    value: function _updateModuleSettings() {\n      var settings = {\n        pickingHighlightColor: this.props.highlightColor\n      };\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var model = _step7.value;\n          model.updateModuleSettings(settings);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n    } // DEPRECATED METHODS\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: 'setUniforms',\n    value: function setUniforms(uniformMap) {\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var model = _step8.value;\n          model.setUniforms(uniformMap);\n        } // TODO - set needsRedraw on the model(s)?\n\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      this.state.needsRedraw = true;\n      log.deprecated('layer.setUniforms', 'model.setUniforms');\n    }\n  }, {\n    key: 'stats',\n    get: function get() {\n      return this.internalState.stats;\n    }\n  }]);\n\n  return Layer;\n}();\n\nexport default Layer;\nLayer.layerName = 'Layer';\nLayer.propTypes = defaultProps;\nLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}