{"ast":null,"code":"import { applyPropOverrides } from '../lib/seer-integration';\nimport log from '../utils/log';\nimport { parsePropTypes } from './prop-types'; // Create a property object\n\nexport function createProps() {\n  var component = this; // eslint-disable-line\n  // Get default prop object (a prototype chain for now)\n\n  var propsPrototype = getPropsPrototypeAndTypes(component.constructor).defaultProps; // Create a new prop object with default props object in prototype chain\n\n  var propsInstance = Object.create(propsPrototype, {\n    // Props need a back pointer to the owning component\n    _component: {\n      enumerable: false,\n      value: component\n    },\n    // The supplied (original) values for those async props that are set to url strings or Promises.\n    // In this case, the actual (i.e. resolved) values are looked up from component.internalState\n    _asyncPropOriginalValues: {\n      enumerable: false,\n      value: {}\n    },\n    // Note: the actual (resolved) values for props that are NOT set to urls or Promises.\n    // in this case the values are served directly from this map\n    _asyncPropResolvedValues: {\n      enumerable: false,\n      value: {}\n    }\n  }); // \"Copy\" all sync props\n\n  for (var i = 0; i < arguments.length; ++i) {\n    Object.assign(propsInstance, arguments[i]);\n  } // SEER: Apply any overrides from the seer debug extension if it is active\n\n\n  applyPropOverrides(propsInstance); // Props must be immutable\n\n  Object.freeze(propsInstance);\n  return propsInstance;\n} // Return precalculated defaultProps and propType objects if available\n// build them if needed\n\nfunction getPropsPrototypeAndTypes(componentClass) {\n  var props = getOwnProperty(componentClass, '_mergedDefaultProps');\n\n  if (props) {\n    return {\n      defaultProps: props,\n      propTypes: getOwnProperty(componentClass, '_propTypes')\n    };\n  }\n\n  return createPropsPrototypeAndTypes(componentClass);\n} // Build defaultProps and propType objects by walking component prototype chain\n\n\nfunction createPropsPrototypeAndTypes(componentClass) {\n  var parent = componentClass.prototype;\n\n  if (!parent) {\n    return {\n      defaultProps: {}\n    };\n  }\n\n  var parentClass = Object.getPrototypeOf(componentClass);\n  var parentPropDefs = parent && getPropsPrototypeAndTypes(parentClass) || null; // Parse propTypes from Component.defaultProps\n\n  var componentDefaultProps = getOwnProperty(componentClass, 'defaultProps') || {};\n  var componentPropDefs = parsePropTypes(componentDefaultProps); // Create a merged type object\n\n  var propTypes = Object.assign({}, parentPropDefs && parentPropDefs.propTypes, componentPropDefs.propTypes); // Create any necessary property descriptors and create the default prop object\n  // Assign merged default props\n\n  var defaultProps = createPropsPrototype(componentPropDefs.defaultProps, parentPropDefs && parentPropDefs.defaultProps, propTypes, componentClass); // Store the precalculated props\n\n  componentClass._mergedDefaultProps = defaultProps;\n  componentClass._propTypes = propTypes;\n  return {\n    propTypes: propTypes,\n    defaultProps: defaultProps\n  };\n} // Builds a pre-merged default props object that component props can inherit from\n\n\nfunction createPropsPrototype(props, parentProps, propTypes, componentClass) {\n  var defaultProps = Object.create(null);\n  Object.assign(defaultProps, parentProps, props); // Avoid freezing `id` prop\n\n  var id = getComponentName(componentClass);\n  delete props.id; // Add getters/setters for async prop properties\n\n  Object.defineProperties(defaultProps, {\n    // `id` is treated specially because layer might need to override it\n    id: {\n      configurable: false,\n      writable: true,\n      value: id\n    }\n  }); // Add getters/setters for async prop properties\n\n  addAsyncPropsToPropPrototype(defaultProps, propTypes);\n  return defaultProps;\n} // Create descriptors for overridable props\n\n\nfunction addAsyncPropsToPropPrototype(defaultProps, propTypes) {\n  var defaultValues = {};\n  var descriptors = {\n    // Default \"resolved\" values for async props, returned if value not yet resolved/set.\n    _asyncPropDefaultValues: {\n      enumerable: false,\n      value: defaultValues\n    },\n    // Shadowed object, just to make sure \"early indexing\" into the instance does not fail\n    _asyncPropOriginalValues: {\n      enumerable: false,\n      value: {}\n    }\n  }; // Move async props into shadow values\n\n  for (var propName in propTypes) {\n    var propType = propTypes[propName];\n    var name = propType.name,\n        value = propType.value; // Note: async is ES7 keyword, can't destructure\n\n    if (propType.async) {\n      defaultValues[name] = value;\n      descriptors[name] = getDescriptorForAsyncProp(name, value);\n    }\n  }\n\n  Object.defineProperties(defaultProps, descriptors);\n} // Helper: Configures getter and setter for one async prop\n\n\nfunction getDescriptorForAsyncProp(name) {\n  return {\n    configurable: false,\n    enumerable: true,\n    // Save the provided value for async props in a special map\n    set: function set(newValue) {\n      if (typeof newValue === 'string' || newValue instanceof Promise) {\n        this._asyncPropOriginalValues[name] = newValue;\n      } else {\n        this._asyncPropResolvedValues[name] = newValue;\n      }\n    },\n    // Only the component's state knows the true value of async prop\n    get: function get() {\n      if (this._asyncPropResolvedValues) {\n        // Prop value isn't async, so just return it\n        if (name in this._asyncPropResolvedValues) {\n          var value = this._asyncPropResolvedValues[name]; // Special handling - components expect null `data` prop expects to be replaced with `[]`\n\n          if (name === 'data') {\n            return value || this._asyncPropDefaultValues[name];\n          }\n\n          return value;\n        } // It's an async prop value: look into component state\n\n\n        var state = this._component && this._component.internalState;\n\n        if (state && state.hasAsyncProp(name)) {\n          return state.getAsyncProp(name);\n        }\n      } // component not yet initialized/matched, return the component's default value for the prop\n\n\n      return this._asyncPropDefaultValues[name];\n    }\n  };\n} // HELPER METHODS\n// Constructors have their super class constructors as prototypes\n\n\nfunction getOwnProperty(object, prop) {\n  return Object.prototype.hasOwnProperty.call(object, prop) && object[prop];\n}\n\nfunction getComponentName(componentClass) {\n  var componentName = getOwnProperty(componentClass, 'layerName') || getOwnProperty(componentClass, 'componentName');\n\n  if (!componentName) {\n    log.once(0, \"\".concat(componentClass.name, \".componentName not specified\"));\n  }\n\n  return componentName || componentClass.name;\n}","map":null,"metadata":{},"sourceType":"module"}