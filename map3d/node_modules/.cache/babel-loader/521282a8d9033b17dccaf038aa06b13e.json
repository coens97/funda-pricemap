{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _core = require(\"@deck.gl/core\");\n\nvar _extractJsxLayers = _interopRequireDefault(require(\"./utils/extract-jsx-layers\"));\n\nvar _inheritsFrom = require(\"./utils/inherits-from\");\n\nvar _evaluateChildren = _interopRequireDefault(require(\"./utils/evaluate-children\"));\n\nvar _autobind = _interopRequireDefault(require(\"./utils/autobind\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar propTypes = _core.Deck.getPropTypes(_propTypes.default);\n\nvar defaultProps = _core.Deck.defaultProps;\n\nvar DeckGL =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(DeckGL, _React$PureComponent);\n\n  function DeckGL(props) {\n    var _this;\n\n    _classCallCheck(this, DeckGL);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeckGL).call(this, props));\n    _this.state = {\n      width: 0,\n      height: 0,\n      viewState: props.initialViewState\n    };\n    _this.children = [];\n    (0, _autobind.default)(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(DeckGL, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Allows a subclass of Deck to be used\n      // TODO - update propTypes / defaultProps?\n      var DeckClass = this.props.Deck || _core.Deck; // DEVTOOLS can cause this to be called twice\n\n      this.deck = this.deck || new DeckClass(Object.assign({}, this.props, {\n        initialViewState: null,\n        canvas: this.deckCanvas,\n        viewState: this._getViewState(this.props),\n        // Note: If Deck event handling change size or view state, it calls onResize to update\n        onViewStateChange: this._onViewStateChange,\n        onResize: this._onResize\n      }));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.deck.finalize();\n    } // Public API\n\n  }, {\n    key: \"pickObject\",\n    value: function pickObject(_ref) {\n      var x = _ref.x,\n          y = _ref.y,\n          _ref$radius = _ref.radius,\n          radius = _ref$radius === void 0 ? 0 : _ref$radius,\n          _ref$layerIds = _ref.layerIds,\n          layerIds = _ref$layerIds === void 0 ? null : _ref$layerIds;\n      return this.deck.pickObject({\n        x: x,\n        y: y,\n        radius: radius,\n        layerIds: layerIds\n      });\n    }\n  }, {\n    key: \"pickMultipleObjects\",\n    value: function pickMultipleObjects(_ref2) {\n      var x = _ref2.x,\n          y = _ref2.y,\n          _ref2$radius = _ref2.radius,\n          radius = _ref2$radius === void 0 ? 0 : _ref2$radius,\n          _ref2$layerIds = _ref2.layerIds,\n          layerIds = _ref2$layerIds === void 0 ? null : _ref2$layerIds,\n          _ref2$depth = _ref2.depth,\n          depth = _ref2$depth === void 0 ? 10 : _ref2$depth;\n      return this.deck.pickMultipleObjects({\n        x: x,\n        y: y,\n        radius: radius,\n        layerIds: layerIds,\n        depth: depth\n      });\n    }\n  }, {\n    key: \"pickObjects\",\n    value: function pickObjects(_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          _ref3$width = _ref3.width,\n          width = _ref3$width === void 0 ? 1 : _ref3$width,\n          _ref3$height = _ref3.height,\n          height = _ref3$height === void 0 ? 1 : _ref3$height,\n          _ref3$layerIds = _ref3.layerIds,\n          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds;\n      return this.deck.pickObjects({\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        layerIds: layerIds\n      });\n    }\n  }, {\n    key: \"queryObject\",\n    value: function queryObject(opts) {\n      _core.log.removed('queryObject', 'pickObject')();\n    }\n  }, {\n    key: \"queryVisibleObjects\",\n    value: function queryVisibleObjects(opts) {\n      _core.log.removed('queryVisibleObjects', 'pickObjects')();\n    } // Callbacks\n    // Forward callback and then call forceUpdate to guarantee that sub components update\n\n  }, {\n    key: \"_onResize\",\n    value: function _onResize(params) {\n      this.setState(params);\n      this.props.onResize(params);\n    } // Forward callback and then call forceUpdate to guarantee that sub components update\n\n  }, {\n    key: \"_onViewStateChange\",\n    value: function _onViewStateChange(params) {\n      // Let app know that view state is changing, and give it a chance to change it\n      var viewState = this.props.onViewStateChange(params) || params.viewState; // If initialViewState was set on creation, auto track position\n\n      if (this.state.viewState) {\n        this.setState({\n          viewState: Object.assign({}, this.state.viewState, _defineProperty({}, params.viewId, viewState))\n        });\n      }\n    } // Private Helpers\n    // 1. Extract any JSX layers from the react children\n    // 2. Handle any backwards compatiblity props for React layer\n    // Needs to be called both from initial mount, and when new props arrive\n\n  }, {\n    key: \"_updateFromProps\",\n    value: function _updateFromProps(nextProps) {\n      if (!this.deck) {\n        return;\n      }\n\n      if (nextProps.viewports || nextProps.viewport) {\n        _core.log.removed('DeckGL.viewport(s)', 'DeckGL.views')();\n      } // extract any deck.gl layers masquerading as react elements from props.children\n\n\n      var _extractJSXLayers = (0, _extractJsxLayers.default)(nextProps),\n          layers = _extractJSXLayers.layers,\n          views = _extractJSXLayers.views,\n          children = _extractJSXLayers.children;\n\n      var deckProps = Object.assign({}, nextProps, {\n        onViewStateChange: this._onViewStateChange,\n        onResize: this._onResize,\n        layers: layers,\n        views: views\n      });\n\n      var viewState = this._getViewState(nextProps);\n\n      if (viewState) {\n        deckProps.viewState = viewState;\n      }\n\n      this.deck.setProps(deckProps);\n      this.children = children;\n    } // Supports old \"geospatial view state as separate props\" style (React only!)\n\n  }, {\n    key: \"_getViewState\",\n    value: function _getViewState(props) {\n      if (!props.viewState && 'latitude' in props && 'longitude' in props && 'zoom' in props) {\n        if ('maxZoom' in props || 'minZoom' in props) {\n          _core.log.removed('maxZoom/minZoom', 'viewState');\n        }\n\n        var latitude = props.latitude,\n            longitude = props.longitude,\n            zoom = props.zoom,\n            _props$pitch = props.pitch,\n            pitch = _props$pitch === void 0 ? 0 : _props$pitch,\n            _props$bearing = props.bearing,\n            bearing = _props$bearing === void 0 ? 0 : _props$bearing;\n        return {\n          latitude: latitude,\n          longitude: longitude,\n          zoom: zoom,\n          pitch: pitch,\n          bearing: bearing\n        };\n      }\n\n      return props.viewState || this.state.viewState;\n    } // Iterate over views and reposition children associated with views\n    // TODO - Can we supply a similar function for the non-React case?\n\n  }, {\n    key: \"_positionChildrenUnderViews\",\n    value: function _positionChildrenUnderViews(children) {\n      var _ref4 = this.deck || {},\n          viewManager = _ref4.viewManager;\n\n      if (!viewManager || !viewManager.views.length) {\n        return [];\n      }\n\n      var defaultViewId = viewManager.views[0].id;\n      return children.map(function (child, i) {\n        if (child.props.viewportId) {\n          _core.log.removed('viewportId', '<View>')();\n        }\n\n        if (child.props.viewId) {\n          _core.log.removed('viewId', '<View>')();\n        } // Unless child is a View, position / render as part of the default view\n\n\n        var viewId = defaultViewId;\n        var viewChildren = child;\n\n        if ((0, _inheritsFrom.inheritsFrom)(child.type, _core.View)) {\n          viewId = child.props.id || defaultViewId;\n          viewChildren = child.props.children;\n        }\n\n        var viewport = viewManager.getViewport(viewId);\n        var viewState = viewManager.getViewState(viewId); // Drop (auto-hide) elements with viewId that are not matched by any current view\n\n        if (!viewport) {\n          return null;\n        } // Resolve potentially relative dimensions using the deck.gl container size\n\n\n        var x = viewport.x,\n            y = viewport.y,\n            width = viewport.width,\n            height = viewport.height;\n        viewChildren = (0, _evaluateChildren.default)(viewChildren, {\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n          viewport: viewport,\n          viewState: viewState\n        });\n        var style = {\n          position: 'absolute',\n          left: x,\n          top: y,\n          width: width,\n          height: height\n        };\n        var key = \"view-child-\".concat(viewId, \"-\").concat(i);\n        return (0, _react.createElement)('div', {\n          key: key,\n          id: key,\n          style: style\n        }, viewChildren);\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this; // TODO - expensive to update on every render?\n\n\n      this._updateFromProps(this.props); // Render the background elements (typically react-map-gl instances)\n      // using the view descriptors\n\n\n      var children = this._positionChildrenUnderViews(this.children); // TODO - this styling is enforced for correct positioning with children\n      // It can override the styling set by `Deck`, this should be consolidated.\n      // Note that width and height are handled by deck.gl\n\n\n      var style = Object.assign({}, {\n        position: 'absolute',\n        left: 0,\n        top: 0\n      }, this.props.style);\n      var canvas = (0, _react.createElement)('canvas', {\n        ref: function ref(c) {\n          return _this2.deckCanvas = c;\n        },\n        key: 'deck-canvas',\n        id: this.props.id,\n        style: style\n      }); // Render deck.gl as last child\n\n      children.push(canvas);\n      return (0, _react.createElement)('div', {\n        id: 'deckgl-wrapper'\n      }, children);\n    }\n  }]);\n\n  return DeckGL;\n}(_react.default.PureComponent);\n\nexports.default = DeckGL;\nDeckGL.propTypes = propTypes;\nDeckGL.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"script"}