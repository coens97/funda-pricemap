{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\"; //\n// A pass that renders a given texture into screen space\n//\n\nimport Pass from './pass';\nimport CompositePass from './composite-pass';\nimport ClipSpace from '../models/clip-space';\nimport { normalizeShaderModule } from '../shadertools/src/lib/filters/normalize-module';\n\nvar ShaderModuleSinglePass =\n/*#__PURE__*/\nfunction (_Pass) {\n  _inherits(ShaderModuleSinglePass, _Pass);\n\n  function ShaderModuleSinglePass(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ShaderModuleSinglePass);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ShaderModuleSinglePass).call(this, gl, Object.assign({\n      swap: true\n    }, props)));\n  }\n\n  _createClass(ShaderModuleSinglePass, [{\n    key: \"_renderPass\",\n    value: function _renderPass(_ref) {\n      var inputBuffer = _ref.inputBuffer,\n          swapBuffers = _ref.swapBuffers;\n      this.props.model.setUniforms(this.props); // swapBuffers();\n\n      this.props.model.draw({\n        uniforms: {\n          texture: inputBuffer,\n          texSize: [inputBuffer.width, inputBuffer.height]\n        },\n        parameters: {\n          depthWrite: false,\n          depthTest: false\n        }\n      });\n    }\n  }]);\n\n  return ShaderModuleSinglePass;\n}(Pass);\n\nvar ShaderModulePass =\n/*#__PURE__*/\nfunction (_CompositePass) {\n  _inherits(ShaderModulePass, _CompositePass);\n\n  function ShaderModulePass(gl, module) {\n    var _this;\n\n    var props = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, ShaderModulePass);\n\n    var id = \"\".concat(module.name, \"-pass\");\n    normalizeShaderModule(module);\n    var passes = normalizePasses(gl, module, id, props);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ShaderModulePass).call(this, gl, Object.assign({\n      id: id,\n      passes: passes\n    }, props)));\n    _this.module = module;\n    return _this;\n  }\n\n  _createClass(ShaderModulePass, [{\n    key: \"_renderPass\",\n    value: function _renderPass(_ref2) {\n      var inputBuffer = _ref2.inputBuffer,\n          swapBuffers = _ref2.swapBuffers;\n      var first = true;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.module.passes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var pass = _step.value;\n\n          if (!first) {\n            swapBuffers();\n          }\n\n          first = false;\n\n          if (pass.uniforms) {\n            pass.model.setUniforms(pass.uniforms);\n          } // swapBuffers();\n\n\n          pass.model.draw({\n            uniforms: {\n              texture: inputBuffer,\n              texSize: [inputBuffer.width, inputBuffer.height]\n            },\n            parameters: {\n              depthWrite: false,\n              depthTest: false\n            }\n          });\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ShaderModulePass;\n}(CompositePass);\n\nexport { ShaderModulePass as default };\n\nfunction normalizePasses(gl, module, id, props) {\n  if (module.filter || module.sampler) {\n    var fs = getFragmentShaderForRenderPass(module);\n    var pass = new ShaderModuleSinglePass(gl, {\n      id: id,\n      model: getModel(gl, module, fs, id, props),\n      uniforms: null\n    });\n    return [pass];\n  }\n\n  var passes = module.passes || [];\n  return passes.map(function (pass) {\n    var fs = getFragmentShaderForRenderPass(module, pass);\n    var idn = \"\".concat(id, \"-\").concat(passes.length + 1);\n    return new ShaderModuleSinglePass(gl, Object.assign({\n      id: idn,\n      model: getModel(gl, module, fs, idn, props),\n      uniforms: pass.uniforms\n    }, props));\n  });\n}\n\nfunction getModel(gl, module, fs, id, props) {\n  var model = new ClipSpace(gl, {\n    id: id,\n    fs: fs,\n    modules: [module]\n  });\n  var uniforms = Object.assign(module.getUniforms(), module.getUniforms(props));\n  model.setUniforms(uniforms);\n  return model;\n}\n\nvar FILTER_FS_TEMPLATE = function FILTER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = texture2D(texture, texCoord);\\n  gl_FragColor = \".concat(func, \"(gl_FragColor, texSize, texCoord);\\n}\\n\");\n};\n\nvar SAMPLER_FS_TEMPLATE = function SAMPLER_FS_TEMPLATE(func) {\n  return \"uniform sampler2D texture;\\nuniform vec2 texSize;\\n\\nvarying vec2 position;\\nvarying vec2 coordinate;\\nvarying vec2 uv;\\n\\nvoid main() {\\n  vec2 texCoord = coordinate;\\n\\n  gl_FragColor = \".concat(func, \"(texture, texSize, texCoord);\\n}\\n\");\n};\n\nfunction getFragmentShaderForRenderPass(module) {\n  var pass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : module;\n\n  if (pass.filter) {\n    var func = typeof pass.filter === 'string' ? pass.filter : \"\".concat(module.name, \"_filterColor\");\n    return FILTER_FS_TEMPLATE(func);\n  }\n\n  if (pass.sampler) {\n    var _func = typeof pass.sampler === 'string' ? pass.sampler : \"\".concat(module.name, \"_sampleColor\");\n\n    return SAMPLER_FS_TEMPLATE(_func);\n  } // console.error(`${module.name} no fragment shader generated`);\n\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}