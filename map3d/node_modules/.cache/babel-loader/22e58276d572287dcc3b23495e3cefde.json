{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport ShaderModule from './shader-module';\nimport assert from '../utils/assert';\n\nvar ShaderModuleRegistry =\n/*#__PURE__*/\nfunction () {\n  function ShaderModuleRegistry() {\n    _classCallCheck(this, ShaderModuleRegistry);\n\n    this.shaderModules = {};\n    this.defaultShaderModules = [];\n  }\n\n  _createClass(ShaderModuleRegistry, [{\n    key: \"setDefaultShaderModules\",\n    value: function setDefaultShaderModules(modules) {\n      this.defaultShaderModules = this.resolveModules(modules);\n    }\n  }, {\n    key: \"registerShaderModules\",\n    value: function registerShaderModules(shaderModuleList) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$ignoreMultipleRe = _ref.ignoreMultipleRegistrations,\n          ignoreMultipleRegistrations = _ref$ignoreMultipleRe === void 0 ? false : _ref$ignoreMultipleRe;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = shaderModuleList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var shaderModule = _step.value;\n\n          this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"getShaderModule\",\n    value: function getShaderModule(moduleOrName) {\n      // Check if \"inline\" module, return it\n      if (moduleOrName instanceof ShaderModule) {\n        return moduleOrName;\n      } // Check if module descriptor\n\n\n      if (typeof moduleOrName !== 'string') {\n        return this._registerShaderModule(moduleOrName, true);\n      } // Module name - Look up module\n\n\n      var module = this.shaderModules[moduleOrName];\n\n      if (!module) {\n        assert(false, \"Unknown shader module \".concat(moduleOrName));\n      }\n\n      return module;\n    } // registers any supplied modules, resolves any names into modules\n    // returns a list of modules\n\n  }, {\n    key: \"resolveModules\",\n    value: function resolveModules(modules) {\n      var _this = this;\n\n      return modules.map(function (moduleOrName) {\n        return _this.getShaderModule(moduleOrName);\n      });\n    } // PRIVATE API\n\n  }, {\n    key: \"_registerShaderModule\",\n    value: function _registerShaderModule(module) {\n      var ignoreMultipleRegistrations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; // Check if \"inline\" module, return it\n\n      if (module instanceof ShaderModule) {\n        return module;\n      }\n\n      assert(module.name, 'shader module has no name');\n\n      if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {\n        // if ignoreMultipleRegistrations = true, we allow module to be re-registered\n        module = new ShaderModule(module);\n        module.dependencies = this.resolveModules(module.dependencies);\n        this.shaderModules[module.name] = module;\n      } else {\n        // TODO - instead verify that definition is not changing...\n        throw new Error(\"shader module \".concat(module.name, \" already registered\"));\n      }\n\n      return this.shaderModules[module.name];\n    }\n  }]);\n\n  return ShaderModuleRegistry;\n}();\n\nexport { ShaderModuleRegistry as default };","map":null,"metadata":{},"sourceType":"module"}