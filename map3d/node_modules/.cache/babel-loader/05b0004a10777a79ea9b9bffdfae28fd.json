{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport Viewport from '../viewports/viewport';\nimport { parsePosition, getPosition } from '../utils/positions';\nimport { deepEqual } from '../utils/deep-equal';\nimport assert from '../utils/assert';\n\nvar View =\n/*#__PURE__*/\nfunction () {\n  function View() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, View);\n\n    var _props$id = props.id,\n        id = _props$id === void 0 ? null : _props$id,\n        _props$x = props.x,\n        x = _props$x === void 0 ? 0 : _props$x,\n        _props$y = props.y,\n        y = _props$y === void 0 ? 0 : _props$y,\n        _props$width = props.width,\n        width = _props$width === void 0 ? '100%' : _props$width,\n        _props$height = props.height,\n        height = _props$height === void 0 ? '100%' : _props$height,\n        _props$projectionMatr = props.projectionMatrix,\n        projectionMatrix = _props$projectionMatr === void 0 ? null : _props$projectionMatr,\n        _props$fovy = props.fovy,\n        fovy = _props$fovy === void 0 ? 75 : _props$fovy,\n        _props$near = props.near,\n        near = _props$near === void 0 ? 0.1 : _props$near,\n        _props$far = props.far,\n        far = _props$far === void 0 ? 1000 : _props$far,\n        _props$modelMatrix = props.modelMatrix,\n        modelMatrix = _props$modelMatrix === void 0 ? null : _props$modelMatrix,\n        _props$viewportInstan = props.viewportInstance,\n        viewportInstance = _props$viewportInstan === void 0 ? null : _props$viewportInstan,\n        _props$type = props.type,\n        type = _props$type === void 0 ? Viewport : _props$type;\n    assert(!viewportInstance || viewportInstance instanceof Viewport);\n    this.viewportInstance = viewportInstance; // Id\n\n    this.id = id || this.constructor.displayName || 'view';\n    this.type = type;\n    this.props = Object.assign({}, props, {\n      projectionMatrix: projectionMatrix,\n      fovy: fovy,\n      near: near,\n      far: far,\n      modelMatrix: modelMatrix\n    }); // Extents\n\n    this._parseDimensions({\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }); // Bind methods for easy access\n\n\n    this.equals = this.equals.bind(this);\n    Object.seal(this);\n  }\n\n  _createClass(View, [{\n    key: \"equals\",\n    value: function equals(view) {\n      if (this === view) {\n        return true;\n      } // if `viewportInstance` is set, it is the only prop that is used\n      // Delegate to `Viewport.equals`\n\n\n      if (this.viewportInstance) {\n        return view.viewportInstance && this.viewportInstance.equals(view.viewportInstance);\n      }\n\n      var viewChanged = deepEqual(this.props, view.props);\n      return viewChanged;\n    } // Build a `Viewport` from a view descriptor\n    // TODO - add support for autosizing viewports using width and height\n\n  }, {\n    key: \"makeViewport\",\n    value: function makeViewport(_ref) {\n      var width = _ref.width,\n          height = _ref.height,\n          viewState = _ref.viewState;\n\n      if (this.viewportInstance) {\n        return this.viewportInstance;\n      }\n\n      viewState = this.filterViewState(viewState); // Resolve relative viewport dimensions\n\n      var viewportDimensions = this.getDimensions({\n        width: width,\n        height: height\n      });\n      var props = Object.assign({\n        viewState: viewState\n      }, viewState, this.props, viewportDimensions);\n      return this._getViewport(props);\n    }\n  }, {\n    key: \"getViewStateId\",\n    value: function getViewStateId() {\n      switch (_typeof(this.props.viewState)) {\n        case 'string':\n          // if View.viewState is a string, return it\n          return this.props.viewState;\n\n        case 'object':\n          // If it is an object, return its id component\n          return this.props.viewState && this.props.viewState.id;\n\n        default:\n          return this.id;\n      }\n    } // Allows view to override (or completely define) viewState\n\n  }, {\n    key: \"filterViewState\",\n    value: function filterViewState(viewState) {\n      if (this.props.viewState && _typeof(this.props.viewState) === 'object') {\n        // If we have specified an id, then intent is to override,\n        // If not, completely specify the view state\n        if (!this.props.viewState.id) {\n          return this.props.viewState;\n        } // Merge in all props from View's viewState, except id\n\n\n        var newViewState = Object.assign({}, viewState);\n\n        for (var key in this.props.viewState) {\n          if (key !== 'id') {\n            newViewState[key] = this.props.viewState[key];\n          }\n        }\n\n        return newViewState;\n      }\n\n      return viewState;\n    } // Resolve relative viewport dimensions into actual dimensions (y='50%', width=800 => y=400)\n\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions(_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height;\n      return {\n        x: getPosition(this._x, width),\n        y: getPosition(this._y, height),\n        width: getPosition(this._width, width),\n        height: getPosition(this._height, height)\n      };\n    } // Used by sub classes to resolve controller props\n\n  }, {\n    key: \"_getControllerProps\",\n    value: function _getControllerProps(defaultOpts) {\n      var opts = this.props.controller;\n\n      if (!opts) {\n        return null;\n      }\n\n      if (opts === true) {\n        return defaultOpts;\n      }\n\n      if (typeof opts === 'function') {\n        opts = {\n          type: opts\n        };\n      }\n\n      return Object.assign({}, defaultOpts, opts);\n    } // Overridable method\n\n  }, {\n    key: \"_getViewport\",\n    value: function _getViewport(props) {\n      // Get the type of the viewport\n      var ViewportType = this.type;\n      return new ViewportType(props);\n    } // Parse relative viewport dimension descriptors (e.g {y: '50%', height: '50%'})\n\n  }, {\n    key: \"_parseDimensions\",\n    value: function _parseDimensions(_ref3) {\n      var x = _ref3.x,\n          y = _ref3.y,\n          width = _ref3.width,\n          height = _ref3.height;\n      this._x = parsePosition(x);\n      this._y = parsePosition(y);\n      this._width = parsePosition(width);\n      this._height = parsePosition(height);\n    }\n  }]);\n\n  return View;\n}();\n\nexport { View as default };","map":null,"metadata":{},"sourceType":"module"}