{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _globals = require('../globals');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ua = typeof _globals.window.navigator !== 'undefined' ? _globals.window.navigator.userAgent.toLowerCase() : '';\nvar firefox = ua.indexOf('firefox') !== -1;\nvar WHEEL_EVENTS = [// Chrome, Safari\n'wheel', // IE\n'mousewheel', // legacy Firefox\n'DOMMouseScroll'];\nvar EVENT_TYPE = 'wheel'; // Constants for normalizing input delta\n\nvar WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;\nvar WHEEL_DELTA_PER_LINE = 40;\nvar TRACKPAD_MAX_DELTA = 4;\nvar TRACKPAD_MAX_DELTA_PER_TIME = 200; // Slow down zoom if shift key is held for more precise zooming\n\nvar SHIFT_MULTIPLIER = 0.25;\n\nvar WheelInput = function () {\n  function WheelInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck3.default)(this, WheelInput);\n    this.element = element;\n    this.callback = callback;\n    var events = WHEEL_EVENTS.concat(options.events || []);\n    this.options = (0, _assign2.default)({\n      enable: true\n    }, options, {\n      events: events\n    });\n    this.time = 0;\n    this.wheelPosition = null;\n    this.type = null;\n    this.timeout = null;\n    this.lastValue = 0;\n    this.handleEvent = this.handleEvent.bind(this);\n    this.options.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n  }\n\n  (0, _createClass3.default)(WheelInput, [{\n    key: 'destroy',\n    value: function destroy() {\n      var _this2 = this;\n\n      this.options.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: 'set',\n    value: function set(options) {\n      (0, _assign2.default)(this.options, options);\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n\n  }, {\n    key: 'toggleIfEventSupported',\n    value: function toggleIfEventSupported(eventType, enabled) {\n      if (eventType === EVENT_TYPE) {\n        this.options.enable = enabled;\n      }\n    }\n    /* eslint-disable complexity, max-statements */\n\n  }, {\n    key: 'handleEvent',\n    value: function handleEvent(event) {\n      if (!this.options.enable) {\n        return;\n      }\n\n      event.preventDefault();\n      var value = event.deltaY;\n\n      if (_globals.window.WheelEvent) {\n        // Firefox doubles the values on retina screens...\n        if (firefox && event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_PIXEL) {\n          value /= _globals.window.devicePixelRatio;\n        }\n\n        if (event.deltaMode === _globals.window.WheelEvent.DOM_DELTA_LINE) {\n          value *= WHEEL_DELTA_PER_LINE;\n        }\n      }\n\n      var type = this.type,\n          timeout = this.timeout,\n          lastValue = this.lastValue,\n          time = this.time;\n      var now = (_globals.window && _globals.window.performance || Date).now();\n      var timeDelta = now - (time || 0);\n      this.wheelPosition = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      time = now;\n\n      if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {\n        // This one is definitely a mouse wheel event.\n        type = 'wheel'; // Normalize this value to match trackpad.\n\n        value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);\n      } else if (value !== 0 && Math.abs(value) < TRACKPAD_MAX_DELTA) {\n        // This one is definitely a trackpad event because it is so small.\n        type = 'trackpad';\n      } else if (timeDelta > 400) {\n        // This is likely a new scroll action.\n        type = null;\n        lastValue = value; // Start a timeout in case this was a singular event,\n        // and delay it by up to 40ms.\n\n        timeout = _globals.window.setTimeout(function setTimeout() {\n          this._onWheel(event, -lastValue, this.wheelPosition);\n\n          type = 'wheel';\n        }.bind(this), 40);\n      } else if (!type) {\n        // This is a repeating event, but we don't know the type of event just yet.\n        // If the delta per time is small, we assume it's a fast trackpad;\n        // otherwise we switch into wheel mode.\n        type = Math.abs(timeDelta * value) < TRACKPAD_MAX_DELTA_PER_TIME ? 'trackpad' : 'wheel'; // Make sure our delayed event isn't fired again, because we accumulate\n        // the previous event (which was less than 40ms ago) into this event.\n\n        if (timeout) {\n          _globals.window.clearTimeout(timeout);\n\n          timeout = null;\n          value += lastValue;\n        }\n      }\n\n      if (event.shiftKey && value) {\n        value = value * SHIFT_MULTIPLIER;\n      } // Only fire the callback if we actually know\n      // what type of scrolling device the user uses.\n\n\n      if (type) {\n        this._onWheel(event, -value, this.wheelPosition);\n      }\n    }\n  }, {\n    key: '_onWheel',\n    value: function _onWheel(srcEvent, delta, position) {\n      this.callback({\n        type: EVENT_TYPE,\n        center: position,\n        delta: delta,\n        srcEvent: srcEvent,\n        pointerType: 'mouse',\n        target: srcEvent.target\n      });\n    }\n  }]);\n  return WheelInput;\n}();\n\nexports.default = WheelInput;","map":null,"metadata":{},"sourceType":"script"}