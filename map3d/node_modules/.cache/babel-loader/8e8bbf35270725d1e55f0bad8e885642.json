{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _SRC_TEX_PARAMETER_OV;\n\nimport Model from './model';\nimport Buffer from '../webgl/buffer';\nimport Framebuffer from '../webgl/framebuffer';\nimport Texture2D from '../webgl/texture-2d';\nimport TransformFeedback from '../webgl/transform-feedback';\nimport { _transform as transform, getPassthroughFS, typeToChannelCount } from '../shadertools/src';\nimport { isWebGL2, assertWebGL2Context, getShaderVersion, cloneTextureFrom } from '../webgl-utils';\nimport assert from '../utils/assert';\nimport { log, isObjectEmpty } from '../utils';\nimport { updateForTextures } from './transform-shader-utils'; // Texture parameters needed so sample can precisely pick pixel for given element id.\n\nvar SRC_TEX_PARAMETER_OVERRIDES = (_SRC_TEX_PARAMETER_OV = {}, _defineProperty(_SRC_TEX_PARAMETER_OV, 10241, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10240, 9728), _defineProperty(_SRC_TEX_PARAMETER_OV, 10242, 33071), _defineProperty(_SRC_TEX_PARAMETER_OV, 10243, 33071), _SRC_TEX_PARAMETER_OV);\nvar FS_OUTPUT_VARIABLE = 'transform_output';\n\nvar Transform =\n/*#__PURE__*/\nfunction () {\n  _createClass(Transform, null, [{\n    key: \"isSupported\",\n    value: function isSupported(gl) {\n      // For now WebGL2 only\n      return isWebGL2(gl);\n    }\n  }]);\n\n  function Transform(gl) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Transform);\n\n    assertWebGL2Context(gl);\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.currentIndex = 0; // Source and destination resources are stored in two element Arrays for easier swapping when\n    // 'feedbackMap' is provided. If not only the first array elment is used.\n    // Each array element is an object with attribute name as Key and Buffer object as value.\n\n    this.sourceBuffers = new Array(2); // Each array element is an object with attribute name as Key and Texture object as value.\n\n    this.sourceTextures = new Array(2); // Each array element is an object with varying name as Key and Buffer object as value.\n\n    this.feedbackBuffers = new Array(2); // Each array element is a Texture object used as color attachment for framebuffer.\n\n    this.targetTextures = new Array(2); // Each array element is a TransformFeedback object.\n\n    this.transformFeedbacks = new Array(2); // Each array element is a Framebuffer object.\n\n    this.framebuffers = new Array(2);\n    this._createdBuffers = {};\n    this.elementIDBuffer = null;\n\n    this._initialize(props);\n\n    Object.seal(this);\n  } // Delete owned resources.\n\n\n  _createClass(Transform, [{\n    key: \"delete\",\n    value: function _delete() {\n      for (var name in this._createdBuffers) {\n        this._createdBuffers[name].delete();\n      }\n\n      this.model.delete();\n    } // Return Buffer object for given varying name.\n\n  }, {\n    key: \"getBuffer\",\n    value: function getBuffer() {\n      var varyingName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      assert(varyingName && this.feedbackBuffers[this.currentIndex][varyingName]);\n      return this.feedbackBuffers[this.currentIndex][varyingName];\n    } // Returns the color attachment textuer from current framebuffer target\n\n  }, {\n    key: \"_getTargetTexture\",\n    value: function _getTargetTexture() {\n      if (this.framebuffers[this.currentIndex]) {\n        return this.framebuffers[this.currentIndex].attachments[36064];\n      }\n\n      return null;\n    } // Return data either from Buffer or from Texture\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$varyingName = _ref.varyingName,\n          varyingName = _ref$varyingName === void 0 ? null : _ref$varyingName,\n          _ref$packed = _ref.packed,\n          packed = _ref$packed === void 0 ? false : _ref$packed; // Either there should be specified feedbackBuffer or we should be rendering to a texture\n\n\n      if (varyingName && this.feedbackBuffers[this.currentIndex][varyingName]) {\n        return this.feedbackBuffers[this.currentIndex][varyingName].getData();\n      } // When varyingName is not provided return data from framebuffer object.\n\n\n      assert(!varyingName || varyingName === this.targetTextureVarying);\n      var pixels = this.framebuffers[this.currentIndex].readPixels();\n\n      if (!packed) {\n        return pixels;\n      } // readPixels returns 4 elements for each pixel, pack the elements when requested\n\n\n      var ArrayType = pixels.constructor;\n      var channelCount = typeToChannelCount(this.targetTextureType);\n      var packedPixels = new ArrayType(pixels.length * channelCount / 4);\n      var packCount = 0;\n\n      for (var i = 0; i < pixels.length; i += 4) {\n        for (var j = 0; j < channelCount; j++) {\n          packedPixels[packCount++] = pixels[i + j];\n        }\n      }\n\n      return packedPixels;\n    }\n  }, {\n    key: \"_getInputs\",\n    value: function _getInputs() {\n      var samplerUniforms = {};\n      var current = this.currentIndex; // Buffer inputs\n\n      var attributes = Object.assign({}, this.sourceBuffers[current]); // Texture inputs\n\n      if (this.hasSourceTextures || this.targetTextureVarying) {\n        // TODO: add option not generate position using element id.\n        attributes.transform_elementID = this.elementIDBuffer;\n\n        for (var sampler in this.samplerTextureMap) {\n          var textureName = this.samplerTextureMap[sampler];\n          samplerUniforms[sampler] = this.sourceTextures[current][textureName];\n        }\n\n        this._setSourceTextureParameters();\n      }\n\n      return {\n        attributes: attributes,\n        samplerUniforms: samplerUniforms\n      };\n    } // Run one transform feedback loop.\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _this$_getInputs = this._getInputs(),\n          attributes = _this$_getInputs.attributes,\n          samplerUniforms = _this$_getInputs.samplerUniforms;\n\n      var uniforms = Object.assign({}, samplerUniforms, opts.uniforms);\n      ;\n      var parameters = Object.assign({}, opts.parameters);\n      var _opts$clearRenderTarg = opts.clearRenderTarget,\n          clearRenderTarget = _opts$clearRenderTarg === void 0 ? true : _opts$clearRenderTarg;\n      var framebuffer = null;\n      var discard = true;\n\n      if (this.renderingToTexture) {\n        discard = false;\n        framebuffer = this.framebuffers[this.currentIndex];\n        assert(framebuffer);\n        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n\n        if (clearRenderTarget) {\n          this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        }\n      }\n\n      this.model.setAttributes(attributes);\n      this.model.transform(Object.assign({}, opts, {\n        transformFeedback: this.transformFeedbacks[this.currentIndex],\n        uniforms: uniforms,\n        discard: discard,\n        framebuffer: framebuffer,\n        parameters: parameters\n      }));\n    } // Swap source and destination buffers and textures.\n\n  }, {\n    key: \"swapBuffers\",\n    value: function swapBuffers() {\n      log.deprecated('swapBuffers()', 'swap()');\n      this.swap();\n    } // Swap source and destination buffers and textures.\n\n  }, {\n    key: \"swap\",\n    value: function swap() {\n      assert(this.feedbackMap || this._swapTexture);\n      this.currentIndex = (this.currentIndex + 1) % 2;\n    } // Update some or all buffer bindings.\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (opts.elementCount) {\n        this._setElementCount(opts.elementCount);\n      }\n\n      var _opts$sourceBuffers = opts.sourceBuffers,\n          sourceBuffers = _opts$sourceBuffers === void 0 ? null : _opts$sourceBuffers,\n          _opts$feedbackBuffers = opts.feedbackBuffers,\n          feedbackBuffers = _opts$feedbackBuffers === void 0 ? null : _opts$feedbackBuffers;\n      var currentIndex = this.currentIndex;\n\n      if (sourceBuffers || feedbackBuffers) {\n        for (var bufferName in feedbackBuffers) {\n          assert(feedbackBuffers[bufferName] instanceof Buffer);\n        }\n\n        Object.assign(this.sourceBuffers[currentIndex], sourceBuffers);\n        Object.assign(this.feedbackBuffers[currentIndex], feedbackBuffers);\n\n        this._createFeedbackBuffers({\n          feedbackBuffers: feedbackBuffers\n        });\n\n        if (this.transformFeedbacks[currentIndex]) {\n          this.transformFeedbacks[currentIndex].setBuffers(this.feedbackBuffers[currentIndex]);\n        } // Buffers have changed, need to re-setup swap buffers.\n\n\n        this._setupSwapBuffers();\n      }\n\n      var _sourceTextures = opts._sourceTextures,\n          _targetTexture = opts._targetTexture;\n\n      if (_sourceTextures || _targetTexture) {\n        Object.assign(this.sourceTextures[currentIndex], _sourceTextures);\n\n        var targetTexture = this._getDestinationTexture(_targetTexture);\n\n        if (targetTexture) {\n          this.targetTextures[currentIndex] = this._getDestinationTexture(_targetTexture);\n          this.framebuffers[currentIndex].update(_defineProperty({}, 36064, this.targetTextures[currentIndex]));\n        } // textures have changed, need to re-setup swap textures.\n\n\n        this._setupSwapTextures();\n      }\n    } // set texture filtering parameters on source textures.\n\n  }, {\n    key: \"_setSourceTextureParameters\",\n    value: function _setSourceTextureParameters() {\n      var index = this.currentIndex;\n\n      for (var name in this.sourceTextures[index]) {\n        this.sourceTextures[index][name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n      }\n    } // set element count and updated elementID buffer if needed.\n\n  }, {\n    key: \"_setElementCount\",\n    value: function _setElementCount(elementCount) {\n      if (this.elementCount === elementCount) {\n        return;\n      }\n\n      if (this.elementCount < elementCount) {\n        this._updateElementIDBuffer(elementCount);\n      }\n\n      this.model.setVertexCount(elementCount);\n      this.elementCount = elementCount;\n    } // Private\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _this$_validateProps = this._validateProps(props),\n          feedbackBuffers = _this$_validateProps.feedbackBuffers,\n          feedbackMap = _this$_validateProps.feedbackMap;\n\n      var sourceBuffers = props.sourceBuffers,\n          varyings = props.varyings,\n          _targetTexture = props._targetTexture,\n          _targetTextureVarying = props._targetTextureVarying,\n          _swapTexture = props._swapTexture;\n      var varyingsArray = varyings;\n\n      if (feedbackMap && !Array.isArray(varyings)) {\n        varyingsArray = Object.values(feedbackMap);\n      }\n\n      this.varyingsArray = varyingsArray;\n      this.feedbackMap = feedbackMap;\n      this._swapTexture = _swapTexture;\n\n      if (_targetTexture) {\n        this.targetTextureVarying = _targetTextureVarying;\n        this.renderingToTexture = true;\n        assert(this.targetTextureVarying);\n      }\n\n      this._setupBuffers({\n        sourceBuffers: sourceBuffers,\n        feedbackBuffers: feedbackBuffers\n      });\n\n      this._setupTextures(props);\n\n      this._setupSwapBuffers();\n\n      this._setupSwapTextures();\n\n      this._buildModel(Object.assign({}, props, {\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || 0,\n        varyings: varyingsArray\n      }));\n    } // assert on required parameters\n\n    /* eslint-disable complexity */\n\n  }, {\n    key: \"_validateProps\",\n    value: function _validateProps(props) {\n      var feedbackBuffers = props.feedbackBuffers,\n          feedbackMap = props.feedbackMap; // backward compitability\n\n      var destinationBuffers = props.destinationBuffers,\n          sourceDestinationMap = props.sourceDestinationMap;\n\n      if (destinationBuffers) {\n        log.deprecated('destinationBuffers', 'feedbackBuffers')();\n        feedbackBuffers = feedbackBuffers || destinationBuffers;\n      }\n\n      if (sourceDestinationMap) {\n        log.deprecated('sourceDestinationMap', 'feedbackMap')();\n        feedbackMap = feedbackMap || sourceDestinationMap;\n      } // assert on required parameters\n\n\n      var vs = props.vs,\n          elementCount = props.elementCount,\n          varyings = props.varyings;\n      var _sourceTextures = props._sourceTextures,\n          _targetTexture = props._targetTexture,\n          _targetTextureVarying = props._targetTextureVarying,\n          _swapTexture = props._swapTexture;\n      assert(vs && ( // destinations are provided\n      varyings || feedbackMap || _targetTexture) && // when only writting to textures auto-duduce from texture dimenstions\n      elementCount);\n\n      for (var bufferName in feedbackBuffers || {}) {\n        assert(feedbackBuffers[bufferName] instanceof Buffer);\n      }\n\n      for (var textureName in _sourceTextures || {}) {\n        assert(_sourceTextures[textureName] instanceof Texture2D);\n      } // If rendering to texture , varying is provided\n\n\n      assert(!_targetTexture || _targetTextureVarying); // swap texture must be a valid source texture\n\n      assert(!_swapTexture || _sourceTextures[_swapTexture]);\n      return {\n        feedbackBuffers: feedbackBuffers,\n        feedbackMap: feedbackMap\n      };\n    }\n    /* eslint-enable complexity */\n    // setup source and destination buffers\n\n  }, {\n    key: \"_setupBuffers\",\n    value: function _setupBuffers(_ref2) {\n      var _ref2$sourceBuffers = _ref2.sourceBuffers,\n          sourceBuffers = _ref2$sourceBuffers === void 0 ? null : _ref2$sourceBuffers,\n          _ref2$feedbackBuffers = _ref2.feedbackBuffers,\n          feedbackBuffers = _ref2$feedbackBuffers === void 0 ? null : _ref2$feedbackBuffers;\n      this.sourceBuffers[0] = Object.assign({}, sourceBuffers);\n      this.feedbackBuffers[0] = Object.assign({}, feedbackBuffers);\n\n      this._createFeedbackBuffers({\n        feedbackBuffers: feedbackBuffers\n      });\n\n      this.sourceBuffers[1] = {};\n      this.feedbackBuffers[1] = {};\n    } // setup source and destination textures\n\n  }, {\n    key: \"_setupTextures\",\n    value: function _setupTextures() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _sourceTextures = props._sourceTextures,\n          _targetTexture = props._targetTexture; // Setup source texture\n\n      this.sourceTextures[0] = Object.assign({}, _sourceTextures);\n      this.sourceTextures[1] = {};\n      this.hasSourceTextures = Object.keys(this.sourceTextures[0]).length > 0;\n\n      if (this.targetTextureVarying) {\n        var texture = this._getDestinationTexture(_targetTexture); // Either a texture or refAttribute must be provided\n\n\n        assert(texture);\n        this.targetTextures[0] = texture;\n        this.targetTextures[1] = null;\n      }\n    }\n  }, {\n    key: \"_getDestinationTexture\",\n    value: function _getDestinationTexture(textureOrAttribute) {\n      var _parameters;\n\n      if (textureOrAttribute instanceof Texture2D) {\n        return textureOrAttribute;\n      }\n\n      var refTexture = this.sourceTextures[0][textureOrAttribute];\n\n      if (!refTexture) {\n        return null;\n      }\n\n      return cloneTextureFrom(refTexture, {\n        parameters: (_parameters = {}, _defineProperty(_parameters, 10241, 9728), _defineProperty(_parameters, 10240, 9728), _defineProperty(_parameters, 10242, 33071), _defineProperty(_parameters, 10243, 33071), _parameters),\n        pixelStore: _defineProperty({}, 37440, false)\n      });\n    } // auto create any feedback buffers\n\n  }, {\n    key: \"_createFeedbackBuffers\",\n    value: function _createFeedbackBuffers(_ref3) {\n      var feedbackBuffers = _ref3.feedbackBuffers;\n\n      if (!this.feedbackMap) {\n        // feedbackMap required to auto create buffers.\n        return;\n      }\n\n      var current = this.currentIndex;\n\n      for (var sourceBufferName in this.feedbackMap) {\n        var feedbackBufferName = this.feedbackMap[sourceBufferName];\n\n        if (feedbackBufferName !== this.targetTextureVarying && (!feedbackBuffers || !feedbackBuffers[feedbackBufferName])) {\n          // Create new buffer with same layout and settings as source buffer\n          var sourceBuffer = this.sourceBuffers[current][sourceBufferName];\n          var bytes = sourceBuffer.bytes,\n              type = sourceBuffer.type,\n              usage = sourceBuffer.usage,\n              accessor = sourceBuffer.accessor;\n          var buffer = new Buffer(this.gl, {\n            bytes: bytes,\n            type: type,\n            usage: usage,\n            accessor: accessor\n          });\n\n          if (this._createdBuffers[feedbackBufferName]) {\n            this._createdBuffers[feedbackBufferName].delete();\n          }\n\n          this._createdBuffers[feedbackBufferName] = buffer;\n          this.feedbackBuffers[current][feedbackBufferName] = buffer;\n        }\n      }\n    } // Create a buffer and add to list of buffers to be deleted.\n\n  }, {\n    key: \"_createNewBuffer\",\n    value: function _createNewBuffer(name, opts) {\n      var buffer = new Buffer(this.gl, opts);\n\n      if (this._createdBuffers[name]) {\n        this._createdBuffers[name].delete();\n\n        this._createdBuffers[name] = buffer;\n      }\n\n      return buffer;\n    } // setup buffers for swapping.\n    // Second set of source and feedback objects are setup to point\n    // to corresponding feedback and source buffers.\n\n  }, {\n    key: \"_setupSwapBuffers\",\n    value: function _setupSwapBuffers() {\n      if (!this.feedbackMap) {\n        // feedbackMap required set up swap buffers.\n        return;\n      }\n\n      var current = this.currentIndex;\n      var next = (current + 1) % 2; // Copy all buffers/textures so un-mapped sources will remain same\n\n      Object.assign(this.sourceBuffers[next], this.sourceBuffers[current]);\n      Object.assign(this.feedbackBuffers[next], this.feedbackBuffers[current]);\n\n      for (var srcName in this.feedbackMap) {\n        var dstName = this.feedbackMap[srcName]; // TODO: add textureMap and remove this if loop\n\n        if (dstName !== this.targetTextureVarying) {\n          this.sourceBuffers[next][srcName] = this.feedbackBuffers[current][dstName];\n          this.feedbackBuffers[next][dstName] = this.sourceBuffers[current][srcName]; // make sure the new destination buffer is a Buffer object\n\n          assert(this.feedbackBuffers[next][dstName] instanceof Buffer);\n        }\n      } // When triggered by `update()` TranformFeedback objects are already set up,\n      // if so update buffers\n\n\n      if (this.transformFeedbacks[next]) {\n        this.transformFeedbacks[next].setBuffers(this.feedbackBuffers[next]);\n      } // TODO: add swap support for targetTexture and framebuffers\n\n    } // setup textures for swapping.\n\n  }, {\n    key: \"_setupSwapTextures\",\n    value: function _setupSwapTextures() {\n      if (!this._swapTexture || !this.targetTextureVarying) {\n        // Must be rendering to a texture and _swapTexture is provided\n        return;\n      }\n\n      var current = this.currentIndex;\n      var next = (current + 1) % 2;\n      Object.assign(this.sourceTextures[next], this.sourceTextures[current]);\n      this.sourceTextures[next][this._swapTexture] = this.targetTextures[current];\n      this.targetTextures[next] = this.sourceTextures[current][this._swapTexture]; // When triggered by `update()` Framebuffer objects are already set up,\n      // if so update buffers\n\n      if (this.framebuffers[next]) {\n        this.framebuffers[next].update(_defineProperty({}, 36064, this.targetTextures[next]));\n      }\n    } // build Model and TransformFeedback objects\n\n  }, {\n    key: \"_buildModel\",\n    value: function _buildModel() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _this$_getShaders = this._getShaders(props),\n          vs = _this$_getShaders.vs,\n          fs = _this$_getShaders.fs,\n          modules = _this$_getShaders.modules,\n          uniforms = _this$_getShaders.uniforms,\n          inject = _this$_getShaders.inject,\n          samplerTextureMap = _this$_getShaders.samplerTextureMap;\n\n      this.model = new Model(this.gl, Object.assign({}, props, {\n        vs: vs,\n        fs: fs,\n        vertexCount: props.elementCount,\n        modules: modules,\n        uniforms: uniforms,\n        inject: inject\n      }));\n      this.samplerTextureMap = samplerTextureMap; // setup TF to capture varyings.\n\n      this._setupTransformFeedback(); // setup Framebuffer object for rendering to Texture.\n\n\n      this._setupFramebuffers(); // create buffer to access source texture pixesl.\n\n\n      this._setElementCount(props.elementCount);\n    } // setup TransformFeedback objects to capture the results\n\n  }, {\n    key: \"_setupTransformFeedback\",\n    value: function _setupTransformFeedback() {\n      if (isObjectEmpty(this.feedbackBuffers[0])) {\n        return;\n      }\n\n      this.transformFeedbacks[0] = new TransformFeedback(this.gl, {\n        program: this.model.program,\n        buffers: this.feedbackBuffers[0]\n      }); // If buffers are swappable setup second transform feedback object.\n\n      if (this.feedbackMap) {\n        this.transformFeedbacks[1] = new TransformFeedback(this.gl, {\n          program: this.model.program,\n          buffers: this.feedbackBuffers[1]\n        });\n      }\n    } // setup framebuffers with texture attachments, to which results are rendered\n\n  }, {\n    key: \"_setupFramebuffers\",\n    value: function _setupFramebuffers() {\n      if (!this.renderingToTexture) {\n        return;\n      }\n\n      var _this$targetTextures$ = this.targetTextures[0],\n          width = _this$targetTextures$.width,\n          height = _this$targetTextures$.height;\n      this.framebuffers[0] = new Framebuffer(this.gl, {\n        id: \"\".concat(this.id || 'transform', \"-framebuffer-0\"),\n        width: width,\n        height: height,\n        attachments: _defineProperty({}, 36064, this.targetTextures[0])\n      });\n\n      if (this._swapTexture) {\n        var _this$targetTextures$2 = this.targetTextures[1];\n        width = _this$targetTextures$2.width;\n        height = _this$targetTextures$2.height;\n        this.framebuffers[1] = new Framebuffer(this.gl, {\n          id: \"\".concat(this.id || 'transform', \"-framebuffer-1\"),\n          width: width,\n          height: height,\n          attachments: _defineProperty({}, 36064, this.targetTextures[1])\n        });\n      }\n    } // create/update buffer to access source texture's individual pixels.\n\n  }, {\n    key: \"_updateElementIDBuffer\",\n    value: function _updateElementIDBuffer(elementCount) {\n      if (!this.hasSourceTextures && !this.targetTextureVarying) {\n        return;\n      } // NOTE: using float so this will work with GLSL 1.0 shaders.\n\n\n      var elementIds = new Float32Array(elementCount);\n      elementIds.forEach(function (_, index, array) {\n        array[index] = index;\n      });\n\n      if (!this.elementIDBuffer) {\n        this.elementIDBuffer = new Buffer(this.gl, {\n          data: elementIds,\n          size: 1\n        });\n      } else {\n        this.elementIDBuffer.setData({\n          data: elementIds\n        });\n      }\n    } // build and return shader releated parameters\n\n  }, {\n    key: \"_getShaders\",\n    value: function _getShaders() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var _this$_processVertexS = this._processVertexShader(props.vs),\n          vs = _this$_processVertexS.vs,\n          uniforms = _this$_processVertexS.uniforms,\n          targetTextureType = _this$_processVertexS.targetTextureType,\n          inject = _this$_processVertexS.inject,\n          samplerTextureMap = _this$_processVertexS.samplerTextureMap;\n\n      this.targetTextureType = targetTextureType;\n      var fs = getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n      var modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;\n      return {\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        uniforms: uniforms,\n        inject: inject,\n        samplerTextureMap: samplerTextureMap\n      };\n    } // scan and update vertex shader for texture atrributes.\n\n  }, {\n    key: \"_processVertexShader\",\n    value: function _processVertexShader(vs) {\n      return updateForTextures({\n        vs: vs,\n        sourceTextureMap: this.sourceTextures[this.currentIndex],\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture: this.targetTextures[this.currentIndex]\n      });\n    }\n  }]);\n\n  return Transform;\n}();\n\nexport { Transform as default };","map":null,"metadata":{},"sourceType":"module"}