{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\n\n\nimport React, { createElement } from 'react';\nimport PropTypes from 'prop-types';\nimport autobind from './autobind';\nimport { createGLContext, setParameters } from 'luma.gl';\n/* global requestAnimationFrame, cancelAnimationFrame */\n\nvar propTypes = {\n  id: PropTypes.string.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  useDevicePixelRatio: PropTypes.bool.isRequired,\n  style: PropTypes.object,\n  events: PropTypes.object,\n  gl: PropTypes.object,\n  glOptions: PropTypes.object,\n  debug: PropTypes.bool,\n  onInitializationFailed: PropTypes.func,\n  onRendererInitialized: PropTypes.func.isRequired,\n  onRenderFrame: PropTypes.func\n};\nvar defaultProps = {\n  style: {},\n  gl: null,\n  glOptions: {\n    preserveDrawingBuffer: true\n  },\n  debug: false,\n  onInitializationFailed: function onInitializationFailed(error) {\n    throw error;\n  },\n  onRendererInitialized: function onRendererInitialized() {},\n  onRenderFrame: function onRenderFrame() {}\n};\n\nvar WebGLRenderer = function (_React$Component) {\n  _inherits(WebGLRenderer, _React$Component);\n  /**\n   * @classdesc\n   * Small react component that uses Luma.GL to initialize a WebGL context.\n   *\n   * Returns a canvas, creates a basic WebGL context\n   * sets up a renderloop, and registers some basic event handlers\n   *\n   * @class\n   * @param {Object} props - see propTypes documentation\n   */\n\n\n  function WebGLRenderer(props) {\n    _classCallCheck(this, WebGLRenderer);\n\n    var _this = _possibleConstructorReturn(this, (WebGLRenderer.__proto__ || Object.getPrototypeOf(WebGLRenderer)).call(this, props));\n\n    _this.state = {};\n    _this._animationFrame = null;\n    _this.gl = null;\n    autobind(_this);\n    return _this;\n  }\n\n  _createClass(WebGLRenderer, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var canvas = this.refs.overlay;\n\n      this._initWebGL(canvas);\n\n      this._animationLoop();\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this._cancelAnimationLoop();\n    }\n    /**\n     * Initialize LumaGL library and through it WebGL\n     * @param {string} canvas\n     */\n\n  }, {\n    key: '_initWebGL',\n    value: function _initWebGL(canvas) {\n      var _props = this.props,\n          debug = _props.debug,\n          glOptions = _props.glOptions; // Create context if not supplied\n\n      var gl = this.props.gl;\n\n      if (!gl) {\n        try {\n          gl = createGLContext(Object.assign({\n            canvas: canvas,\n            debug: debug\n          }, glOptions));\n        } catch (error) {\n          this.props.onInitializationFailed(error);\n          return;\n        }\n      }\n\n      this.gl = gl; // Call callback last, in case it throws\n\n      this.props.onRendererInitialized({\n        canvas: canvas,\n        gl: gl\n      });\n    }\n    /**\n     * Main WebGL animation loop\n     */\n\n  }, {\n    key: '_animationLoop',\n    value: function _animationLoop() {\n      this._renderFrame(); // Keep registering ourselves for the next animation frame\n\n\n      if (typeof window !== 'undefined') {\n        this._animationFrame = requestAnimationFrame(this._animationLoop);\n      }\n    }\n  }, {\n    key: '_cancelAnimationLoop',\n    value: function _cancelAnimationLoop() {\n      if (this._animationFrame) {\n        cancelAnimationFrame(this._animationFrame);\n      }\n    } // Calculate the drawing buffer size that would cover current canvas size and device pixel ratio\n    // Intention is that every pixel in the drawing buffer will have a 1-to-1 mapping with\n    // actual device pixels in the hardware framebuffer, allowing us to render at the full\n    // resolution of the device.\n\n  }, {\n    key: '_calculateDrawingBufferSize',\n    value: function _calculateDrawingBufferSize(canvas, _ref) {\n      var _ref$useDevicePixelRa = _ref.useDevicePixelRatio,\n          useDevicePixelRatio = _ref$useDevicePixelRa === undefined ? true : _ref$useDevicePixelRa;\n      var cssToDevicePixels = useDevicePixelRatio ? window.devicePixelRatio || 1 : 1; // Lookup the size the browser is displaying the canvas in CSS pixels\n      // and compute a size needed to make our drawingbuffer match it in\n      // device pixels.\n      // We have set the canvas width and hieht from props, use props instead of accessing\n      // canvas.clientWidth/clientHeight for performance reasons.\n\n      var _props2 = this.props,\n          width = _props2.width,\n          height = _props2.height;\n      return {\n        width: Math.floor(width * cssToDevicePixels),\n        height: Math.floor(height * cssToDevicePixels),\n        devicePixelRatio: cssToDevicePixels\n      };\n    } // Resizes canvas width and height to match with device drawing buffer\n\n  }, {\n    key: '_resizeDrawingBuffer',\n    value: function _resizeDrawingBuffer(canvas, _ref2) {\n      var _ref2$useDevicePixelR = _ref2.useDevicePixelRatio,\n          useDevicePixelRatio = _ref2$useDevicePixelR === undefined ? true : _ref2$useDevicePixelR; // Resize the render buffer of the canvas to match canvas client size\n      // multiplying with dpr (Optionally can be turned off)\n\n      var newBufferSize = this._calculateDrawingBufferSize(canvas, {\n        useDevicePixelRatio: useDevicePixelRatio\n      }); // Only update if the canvas size has not changed\n\n\n      if (newBufferSize.width !== canvas.width || newBufferSize.height !== canvas.height) {\n        // Note: canvas.width, canvas.height control the size of backing drawing buffer\n        // and can be set indepently of canvas.clientWidth and canvas.clientHeight\n        // which confusingly reflect canvas.style.width, canvas.style.height\n        canvas.width = newBufferSize.width;\n        canvas.height = newBufferSize.height;\n      }\n    }\n  }, {\n    key: '_renderFrame',\n    value: function _renderFrame() {\n      var _props3 = this.props,\n          width = _props3.width,\n          height = _props3.height,\n          useDevicePixelRatio = _props3.useDevicePixelRatio;\n      var gl = this.gl; // Check for reasons not to draw\n\n      if (!gl || !(width > 0) || !(height > 0)) {\n        return;\n      }\n\n      this._resizeDrawingBuffer(gl.canvas, {\n        useDevicePixelRatio: useDevicePixelRatio\n      }); // Updates WebGL viewport to latest props\n\n\n      setParameters(gl, {\n        viewport: [0, 0, gl.canvas.width, gl.canvas.height]\n      }); // Call render callback\n\n      this.props.onRenderFrame({\n        gl: gl\n      });\n      this.props.onAfterRender(this.refs.overlay);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props4 = this.props,\n          id = _props4.id,\n          width = _props4.width,\n          height = _props4.height,\n          style = _props4.style;\n      return createElement('canvas', {\n        ref: 'overlay',\n        key: 'overlay',\n        id: id,\n        style: Object.assign({}, style, {\n          width: width,\n          height: height\n        })\n      });\n    }\n  }]);\n\n  return WebGLRenderer;\n}(React.Component);\n\nexport default WebGLRenderer;\nWebGLRenderer.propTypes = propTypes;\nWebGLRenderer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}