{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\"; // VertexArray class\n\nimport Accessor from './accessor';\nimport Buffer from './buffer';\nimport VertexArrayObject from './vertex-array-object';\nimport { log, assert } from '../utils';\nimport { stubRemovedMethods } from '../utils';\nvar ERR_ATTRIBUTE_TYPE = 'VertexArray: attributes must be Buffers or constants (i.e. typed array)';\n\nvar VertexArray =\n/*#__PURE__*/\nfunction () {\n  function VertexArray(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, VertexArray); // Use program's id if program is supplied but no id is supplied\n\n\n    var id = opts.id || opts.program && opts.program.id; // super(gl, Object.assign({}, opts, {id}));\n\n    this.id = id;\n    this.gl = gl;\n    this.configuration = null; // Extracted information\n\n    this.elements = null;\n    this.values = null;\n    this.accessors = null;\n    this.unused = null;\n    this.drawParams = null;\n    this.buffer = null; // For attribute 0 on desktops, and created when unbinding buffers\n\n    this.vertexArrayObject = VertexArrayObject.isSupported(gl) ? new VertexArrayObject(gl) : VertexArrayObject.getDefaultArray(gl); // Issue errors when using removed methods\n\n    stubRemovedMethods(this, 'VertexArray', 'v6.0', ['setBuffers', 'setGeneric', 'clearBindings', 'setLocations', 'setGenericValues', 'setDivisor', 'enable', 'disable']);\n    this.initialize(opts);\n    Object.seal(this);\n  }\n\n  _createClass(VertexArray, [{\n    key: \"delete\",\n    value: function _delete() {\n      if (this.buffer) {\n        this.buffer.delete();\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.reset();\n      this.configuration = null;\n      this.bindOnUse = false;\n      return this.setProps(props);\n    } // Resets all attributes (to default valued constants)\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      // this.vertexArrayObject.reset();\n      this.elements = null;\n      var MAX_ATTRIBUTES = this.vertexArrayObject.MAX_ATTRIBUTES;\n      this.values = new Array(MAX_ATTRIBUTES).fill(null);\n      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);\n      this.unused = {}; // Auto detects draw params\n\n      this.drawParams = null;\n      return this;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('program' in props) {\n        this.configuration = props.program && props.program.configuration;\n      }\n\n      if ('configuration' in props) {\n        this.configuration = props.configuration;\n      }\n\n      if ('attributes' in props) {\n        this.setAttributes(props.attributes);\n      }\n\n      if ('elements' in props) {\n        this.setElementBuffer(props.elements);\n      }\n\n      if ('bindOnUse' in props) {\n        props = props.bindOnUse;\n      }\n\n      return this;\n    } // Automatically called if buffers changed through VertexArray API\n\n  }, {\n    key: \"clearDrawParams\",\n    value: function clearDrawParams() {\n      this.drawParams = null;\n    }\n  }, {\n    key: \"getDrawParams\",\n    value: function getDrawParams(appParameters) {\n      // Auto deduced draw parameters\n      this.drawParams = this.drawParams || this._updateDrawParams(); // Override with any application supplied draw parameters\n\n      return Object.assign({}, this.drawParams, appParameters);\n    } // Set (bind) an array or map of vertex array buffers, either in numbered or named locations.\n    // For names that are not present in `location`, the supplied buffers will be ignored.\n    // if a single buffer of type GL.ELEMENT_ARRAY_BUFFER is present, it will be set as elements\n    //   Signatures:\n    //     {attributeName: buffer}\n    //     {attributeName: [buffer, accessor]}\n    //     {attributeName: (typed) array} => constant\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attributes) {\n      var _this = this;\n\n      this.vertexArrayObject.bind(function () {\n        for (var locationOrName in attributes) {\n          var value = attributes[locationOrName];\n\n          if (value instanceof Buffer) {\n            //  Signature: attributeName: buffer\n            _this.setBuffer(locationOrName, value);\n          } else if (Array.isArray(value) && value.length && value[0] instanceof Buffer) {\n            // Signature: attributeName: [buffer, accessor]\n            var buffer = value[0];\n            var accessor = value[1];\n\n            _this.setBuffer(locationOrName, buffer, accessor);\n          } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {\n            //  Signature: attributeName: (short) (typed) array => constant\n            _this.setConstant(locationOrName, value);\n          } else {\n            throw new Error(ERR_ATTRIBUTE_TYPE);\n          }\n        } // Make sure we don't leave any bindings\n\n\n        _this.gl.bindBuffer(34962, null);\n      });\n      return this;\n    } // Set (bind) an elements buffer, for indexed rendering.\n    // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER. Constants not supported\n\n  }, {\n    key: \"setElementBuffer\",\n    value: function setElementBuffer() {\n      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.elements = elementBuffer; // Save value for debugging\n\n      this.clearDrawParams(); // Update vertexArray immediately if we have our own array\n\n      if (!this.vertexArrayObject.isDefaultArray) {\n        this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);\n      }\n\n      return this;\n    } // Set a location in vertex attributes array to a buffer\n\n  }, {\n    key: \"setBuffer\",\n    value: function setBuffer(locationOrName, buffer) {\n      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Check target\n\n      if (buffer.target === 34963) {\n        return this.setElementBuffer(buffer);\n      }\n\n      var _this$_resolveLocatio = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor),\n          location = _this$_resolveLocatio.location,\n          accessor = _this$_resolveLocatio.accessor;\n\n      if (location >= 0) {\n        this.values[location] = buffer;\n        this.accessors[location] = accessor;\n        this.clearDrawParams(); // Update vertexArray immediately if we have our own array\n\n        if (!this.vertexArrayObject.isDefaultArray) {\n          this.vertexArrayObject.setBuffer(location, buffer, accessor);\n        }\n      }\n\n      return this;\n    } // Set attribute to constant value (small typed array corresponding to one vertex' worth of data)\n\n  }, {\n    key: \"setConstant\",\n    value: function setConstant(locationOrName, arrayValue) {\n      var appAccessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var _this$_resolveLocatio2 = this._resolveLocationAndAccessor(locationOrName, arrayValue, appAccessor),\n          location = _this$_resolveLocatio2.location,\n          accessor = _this$_resolveLocatio2.accessor;\n\n      if (location >= 0) {\n        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue, accessor);\n        this.values[location] = arrayValue;\n        this.accessors[location] = accessor;\n        this.clearDrawParams(); // Update vertexArray immediately if we have our own array\n        // NOTE: We set the actual constant value later on bind. We can't set the value now since\n        // constants are global and affect all other VertexArrays that have disabled attributes\n        // in the same location.\n        // We do disable the attribute which makes it use the global constant value at that location\n\n        if (!this.vertexArrayObject.isDefaultArray) {\n          this.vertexArrayObject.enable(location, false);\n        }\n      }\n\n      return this;\n    } // Workaround for Chrome TransformFeedback binding issue\n    // If required, unbind temporarily to avoid conflicting with TransformFeedback\n\n  }, {\n    key: \"unbindBuffers\",\n    value: function unbindBuffers() {\n      var _this2 = this;\n\n      this.vertexArrayObject.bind(function () {\n        if (_this2.elements) {\n          _this2.setElementBuffer(null);\n        } // Chrome does not like buffers that are bound to several binding points,\n        // so we need to offer and unbind facility\n        // WebGL offers disabling, but no clear way to set a VertexArray buffer to `null`\n        // So we just bind all the attributes to the dummy \"attribute zero\" buffer\n\n\n        _this2.buffer = _this2.buffer || new Buffer(_this2.gl, {\n          size: 4\n        });\n\n        for (var location = 0; location < _this2.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n          if (_this2.values[location] instanceof Buffer) {\n            _this2.gl.disableVertexAttribArray(location);\n\n            _this2.gl.bindBuffer(34962, _this2.buffer.handle);\n\n            _this2.gl.vertexAttribPointer(location, 1, 5126, false, 0, 0);\n          }\n        }\n      });\n      return this;\n    } // Workaround for Chrome TransformFeedback binding issue\n    // If required, rebind rebind after temporary unbind\n\n  }, {\n    key: \"bindBuffers\",\n    value: function bindBuffers() {\n      var _this3 = this;\n\n      this.vertexArrayObject.bind(function () {\n        if (_this3.elements) {\n          _this3.setElementBuffer(_this3.elements);\n        }\n\n        for (var location = 0; location < _this3.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n          var buffer = _this3.values[location];\n\n          if (buffer instanceof Buffer) {\n            _this3.setBuffer(location, buffer);\n          }\n        }\n      });\n      return this;\n    } // Bind for use\n    // When a vertex array is about to be used, we must:\n    // - Set constant attributes (since these are stored on the context and reset on bind)\n    // - Check if we need to initialize the buffer\n\n  }, {\n    key: \"bindForDraw\",\n    value: function bindForDraw(vertexCount, instanceCount, func) {\n      var _this4 = this;\n\n      var value;\n      this.vertexArrayObject.bind(function () {\n        // Make sure that any constant attributes are updated (stored on the context, not the VAO)\n        // Also handles attribute 0\n        _this4._setConstantAttributes(vertexCount, instanceCount);\n\n        if (!_this4.vertexArrayObject.hasVertexArrays) {\n          _this4.bindBuffers();\n        }\n\n        value = func();\n\n        if (!_this4.vertexArrayObject.hasVertexArrays) {\n          _this4.unbindBuffers();\n        }\n      });\n      return value;\n    } // PRIVATE\n    // Resolve locations and accessors\n\n  }, {\n    key: \"_resolveLocationAndAccessor\",\n    value: function _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {\n      var _this5 = this;\n\n      var location = this._getAttributeIndex(locationOrName);\n\n      if (!Number.isFinite(location) || location < 0) {\n        this.unused[locationOrName] = value;\n        log.once(3, function () {\n          return \"unused value \".concat(locationOrName, \" in \").concat(_this5.id);\n        })();\n        return this;\n      }\n\n      var accessInfo = this._getAttributeInfo(locationOrName); // Resolve the partial accessors into a final accessor\n\n\n      var accessor = Accessor.resolve(accessInfo.accessor, valueAccessor, appAccessor);\n      var size = accessor.size,\n          type = accessor.type;\n      assert(Number.isFinite(size) && Number.isFinite(type));\n      return {\n        location: location,\n        accessor: accessor\n      };\n    }\n  }, {\n    key: \"_getAttributeInfo\",\n    value: function _getAttributeInfo(attributeName) {\n      return this.configuration && this.configuration.getAttributeInfo(attributeName);\n    }\n  }, {\n    key: \"_getAttributeIndex\",\n    value: function _getAttributeIndex(locationOrName) {\n      if (this.configuration) {\n        return this.configuration.getAttributeLocation(locationOrName);\n      }\n\n      var location = Number(locationOrName);\n\n      if (Number.isFinite(location)) {\n        return location;\n      }\n\n      return -1;\n    } // Updates all constant attribute values (constants are used when vertex attributes are disabled).\n    // This needs to be done repeatedly since in contrast to buffer bindings,\n    // constants are stored on the WebGL context, not the VAO\n\n  }, {\n    key: \"_setConstantAttributes\",\n    value: function _setConstantAttributes(vertexCount, instanceCount) {\n      // TODO - use accessor to determine what length to use\n      var elementCount = Math.max(vertexCount | 0, instanceCount | 0);\n      var constant = this.values[0];\n\n      if (ArrayBuffer.isView(constant)) {\n        this._setConstantAttributeZero(constant, elementCount);\n      }\n\n      for (var location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n        constant = this.values[location];\n\n        if (ArrayBuffer.isView(constant)) {\n          this._setConstantAttribute(location, constant);\n        }\n      }\n    }\n  }, {\n    key: \"_setConstantAttributeZero\",\n    value: function _setConstantAttributeZero(constant, elementCount) {\n      if (VertexArrayObject.isSupported(this.gl, {\n        constantAttributeZero: true\n      })) {\n        this._setConstantAttribute(0, constant);\n\n        return;\n      } // Get a dummy buffer populated with repeated constants\n\n\n      var buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant); // Set the buffer on location 0\n\n      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);\n    }\n  }, {\n    key: \"_setConstantAttribute\",\n    value: function _setConstantAttribute(location, constant) {\n      VertexArrayObject.setConstant(this.gl, location, constant); // If we are using the global VertexArrayObject, we need to disable the attribute now\n\n      if (this.vertexArrayObject.isDefault) {\n        this.vertexArrayObject.enable(location, false);\n      }\n    } // Walks the buffers and updates draw parameters\n\n  }, {\n    key: \"_updateDrawParams\",\n    value: function _updateDrawParams() {\n      var drawParams = {\n        isIndexed: false,\n        isInstanced: false,\n        indexCount: Infinity,\n        vertexCount: Infinity,\n        instanceCount: Infinity\n      };\n\n      for (var location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {\n        this._updateDrawParamsForLocation(drawParams, location);\n      }\n\n      if (this.elements) {\n        // indexing is autodetected - buffer with target GL.ELEMENT_ARRAY_BUFFER\n        // index type is saved for drawElement calls\n        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);\n        drawParams.isIndexed = true;\n        drawParams.indexType = this.elements.accessor.type;\n      } // Post-calculation checks\n\n\n      if (drawParams.indexCount === Infinity) {\n        drawParams.indexCount = 0;\n      }\n\n      if (drawParams.vertexCount === Infinity) {\n        drawParams.vertexCount = 0;\n      }\n\n      if (drawParams.instanceCount === Infinity) {\n        drawParams.instanceCount = 0;\n      }\n\n      return drawParams;\n    }\n  }, {\n    key: \"_updateDrawParamsForLocation\",\n    value: function _updateDrawParamsForLocation(drawParams, location) {\n      var value = this.values[location];\n      var accessor = this.accessors[location];\n\n      if (!value) {\n        return;\n      } // Check if instanced (whether buffer or constant)\n\n\n      var divisor = accessor.divisor;\n      var isInstanced = divisor > 0;\n      drawParams.isInstanced = drawParams.isInstanced || isInstanced;\n\n      if (value instanceof Buffer) {\n        var buffer = value;\n\n        if (isInstanced) {\n          // instance attribute\n          var instanceCount = buffer.getVertexCount(accessor);\n          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);\n        } else {\n          // normal attribute\n          var vertexCount = buffer.getVertexCount(accessor);\n          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);\n        }\n      }\n    } // DEPRECATED\n\n  }, {\n    key: \"setElements\",\n    value: function setElements() {\n      var elementBuffer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var accessor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      log.deprecated('setElements', 'setElementBuffer');\n      return this.setElementBuffer(elementBuffer, accessor);\n    }\n  }]);\n\n  return VertexArray;\n}();\n\nexport { VertexArray as default };","map":null,"metadata":{},"sourceType":"module"}