{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Object3D from './object-3d';\nimport { Matrix4 } from 'math.gl';\nimport assert from '../utils/assert';\n\nvar Group =\n/*#__PURE__*/\nfunction (_Object3D) {\n  _inherits(Group, _Object3D);\n\n  function Group() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Group);\n\n    opts = Array.isArray(opts) ? {\n      children: opts\n    } : opts;\n    var _opts = opts,\n        _opts$children = _opts.children,\n        children = _opts$children === void 0 ? [] : _opts$children;\n    children.every(function (child) {\n      return assert(child instanceof Object3D);\n    });\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Group).call(this, opts));\n    _this.children = children;\n    return _this;\n  } // Unpacks arrays and nested arrays of children\n\n\n  _createClass(Group, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n        children[_key] = arguments[_key];\n      }\n\n      for (var _i = 0; _i < children.length; _i++) {\n        var child = children[_i];\n\n        if (Array.isArray(child)) {\n          this.add.apply(this, _toConsumableArray(child));\n        } else {\n          this.children.push(child);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(child) {\n      var children = this.children;\n      var indexOf = children.indexOf(child);\n\n      if (indexOf > -1) {\n        children.splice(indexOf, 1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeAll\",\n    value: function removeAll() {\n      this.children = [];\n      return this;\n    } // If visitor returns a truthy value, traversal will be aborted and that value\n    // will be returned from `traverse`. Otherwise `traverse` will return null.\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(visitor) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$modelMatrix = _ref.modelMatrix,\n          modelMatrix = _ref$modelMatrix === void 0 ? new Matrix4() : _ref$modelMatrix;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          var matrix = child.matrix;\n          modelMatrix = modelMatrix.multiplyRight(matrix);\n          var result = void 0;\n\n          if (child instanceof Group) {\n            result = child.traverse(visitor, {\n              modelMatrix: modelMatrix\n            });\n          } else {\n            // child.setUniforms({modelMatrix});\n            result = visitor(child, {});\n          } // Abort if a result was returned\n\n\n          if (result) {\n            return result;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    } // If visitor returns a truthy value, traversal will be aborted and that value\n    // will be returned from `traverseReverse`. Otherwise `traverseReverse` will return null.\n\n  }, {\n    key: \"traverseReverse\",\n    value: function traverseReverse(visitor) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$modelMatrix = _ref2.modelMatrix,\n          modelMatrix = _ref2$modelMatrix === void 0 ? new Matrix4() : _ref2$modelMatrix;\n\n      for (var i = this.children.length - 1; i >= 0; --i) {\n        var child = this.children[i];\n        var matrix = child.matrix;\n        modelMatrix = modelMatrix.multiplyRight(matrix);\n        var result = void 0;\n\n        if (child instanceof Group) {\n          result = child.traverseReverse(visitor, {\n            modelMatrix: modelMatrix\n          });\n        } else {\n          // child.setUniforms({modelMatrix});\n          result = visitor(child, {});\n        } // Abort if a result was returned\n\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Group;\n}(Object3D);\n\nexport { Group as default };","map":null,"metadata":{},"sourceType":"module"}