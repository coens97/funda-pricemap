{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n/* global window */\n\nimport AnimationLoop from './animation-loop';\nimport { getPageLoadPromise, createCanvas } from '../webgl-context';\nimport { requestAnimationFrame, cancelAnimationFrame } from '../webgl-utils';\n\nvar AnimationLoopProxy =\n/*#__PURE__*/\nfunction () {\n  _createClass(AnimationLoopProxy, null, [{\n    key: \"createWorker\",\n    // Create the script for the rendering worker.\n    // @param opts {object} - options to construct an AnimationLoop instance\n    value: function createWorker(opts) {\n      return function (self) {\n        self.animationLoop = new AnimationLoop(Object.assign({}, opts, {\n          offScreen: true,\n          // Prevent the animation loop from trying to access DOM properties\n          useDevicePixels: false,\n          autoResizeDrawingBuffer: false\n        }));\n        self.canvas = null;\n        self.addEventListener('message', function (evt) {\n          var animationLoop = self.animationLoop;\n\n          switch (evt.data.command) {\n            case 'start':\n              self.canvas = evt.data.opts.canvas;\n              animationLoop.start(evt.data.opts);\n              break;\n\n            case 'stop':\n              animationLoop.stop();\n              break;\n\n            case 'resize':\n              self.canvas.width = evt.data.width;\n              self.canvas.height = evt.data.height;\n              break;\n\n            default:\n          }\n        });\n      };\n    }\n    /*\n     * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context\n     */\n\n  }]);\n\n  function AnimationLoopProxy(_ref) {\n    var worker = _ref.worker,\n        _ref$onInitialize = _ref.onInitialize,\n        onInitialize = _ref$onInitialize === void 0 ? function () {} : _ref$onInitialize,\n        _ref$onFinalize = _ref.onFinalize,\n        onFinalize = _ref$onFinalize === void 0 ? function () {} : _ref$onFinalize,\n        _ref$useDevicePixels = _ref.useDevicePixels,\n        useDevicePixels = _ref$useDevicePixels === void 0 ? true : _ref$useDevicePixels,\n        _ref$autoResizeDrawin = _ref.autoResizeDrawingBuffer,\n        autoResizeDrawingBuffer = _ref$autoResizeDrawin === void 0 ? true : _ref$autoResizeDrawin;\n\n    _classCallCheck(this, AnimationLoopProxy);\n\n    this.props = {\n      worker: worker,\n      onInitialize: onInitialize,\n      onFinalize: onFinalize,\n      autoResizeDrawingBuffer: autoResizeDrawingBuffer,\n      useDevicePixels: useDevicePixels\n    }; // state\n\n    this.canvas = null;\n    this.width = null;\n    this.height = null;\n    this._stopped = true;\n    this._animationFrameId = null;\n    this._startPromise = null; // bind methods\n\n    this._updateFrame = this._updateFrame.bind(this);\n  }\n  /* Public methods */\n  // Starts a render loop if not already running\n\n\n  _createClass(AnimationLoopProxy, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this._stopped = false; // console.debug(`Starting ${this.constructor.name}`);\n\n      if (!this._animationFrameId) {\n        // Wait for start promise before rendering frame\n        this._startPromise = getPageLoadPromise().then(function () {\n          _this._createAndTransferCanvas(opts);\n\n          return _this.props.onInitialize(_this);\n        }).then(function () {\n          if (!_this._stopped) {\n            _this._animationFrameId = requestAnimationFrame(_this._updateFrame);\n          }\n        });\n      }\n\n      return this;\n    } // Stops a render loop if already running, finalizing\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._animationFrameId) {\n        cancelAnimationFrame(this._animationFrameId);\n        this._animationFrameId = null;\n        this._stopped = true;\n        this.props.onFinalize(this);\n      }\n\n      this.props.worker.postMessage({\n        command: 'stop'\n      });\n      return this;\n    } // PRIVATE METHODS\n\n  }, {\n    key: \"_updateFrame\",\n    value: function _updateFrame() {\n      this._resizeCanvasDrawingBuffer();\n\n      this._animationFrameId = requestAnimationFrame(this._updateFrame);\n    }\n  }, {\n    key: \"_createAndTransferCanvas\",\n    value: function _createAndTransferCanvas(opts) {\n      // Create a canvas on the main thread\n      var screenCanvas = createCanvas(opts); // Create an offscreen canvas controlling the main canvas\n\n      if (!screenCanvas.transferControlToOffscreen) {\n        onError('OffscreenCanvas is not available. Enable Experimental canvas features in chrome://flags'); // eslint-disable-line\n      }\n\n      var offscreenCanvas = screenCanvas.transferControlToOffscreen(); // Transfer the offscreen canvas to the worker\n\n      this.props.worker.postMessage({\n        command: 'start',\n        opts: Object.assign({}, opts, {\n          canvas: offscreenCanvas\n        })\n      }, [offscreenCanvas]); // store the main canvas on the local thread\n\n      this.canvas = screenCanvas;\n    }\n  }, {\n    key: \"_resizeCanvasDrawingBuffer\",\n    value: function _resizeCanvasDrawingBuffer() {\n      if (this.props.autoResizeDrawingBuffer) {\n        var devicePixelRatio = this.props.useDevicePixels ? window.devicePixelRatio || 1 : 1;\n        var width = this.canvas.clientWidth * devicePixelRatio;\n        var height = this.canvas.clientHeight * devicePixelRatio;\n\n        if (this.width !== width || this.height !== height) {\n          this.width = width;\n          this.height = height;\n          this.props.worker.postMessage({\n            command: 'resize',\n            width: width,\n            height: height\n          });\n        }\n      }\n    }\n  }]);\n\n  return AnimationLoopProxy;\n}();\n\nexport { AnimationLoopProxy as default };","map":null,"metadata":{},"sourceType":"module"}