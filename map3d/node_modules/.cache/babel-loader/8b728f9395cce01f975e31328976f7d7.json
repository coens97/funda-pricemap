{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport GL from './api';\nimport { isWebGL2, ERR_WEBGL2 } from './context';\nimport { clear as _clear, clearBuffer } from './clear';\nimport { getFeatures } from './context-features';\nimport Resource from './resource';\nimport Texture2D from './texture-2d';\nimport Renderbuffer from './renderbuffer';\nimport { getTypedArrayFromGLType, getGLTypeFromTypedArray } from '../utils/typed-array-utils';\nimport { log } from '../utils';\nimport assert from 'assert'; // Local constants - will collapse during minification\n\nvar GL_FRAMEBUFFER = 0x8D40;\nvar GL_DRAW_FRAMEBUFFER = 0x8CA8;\nvar GL_READ_FRAMEBUFFER = 0x8CA9;\nvar GL_COLOR_ATTACHMENT0 = 0x8CE0;\nvar GL_DEPTH_ATTACHMENT = 0x8D00;\nvar GL_STENCIL_ATTACHMENT = 0x8D20; // const GL_DEPTH_STENCIL_ATTACHMENT = 0x821A;\n\nvar GL_RENDERBUFFER = 0x8D41;\nvar GL_TEXTURE_3D = 0x806F;\nvar GL_TEXTURE_2D_ARRAY = 0x8C1A;\nvar GL_TEXTURE_2D = 0x0DE1;\nvar GL_TEXTURE_CUBE_MAP = 0x8513;\nvar GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\nvar GL_DEPTH_BUFFER_BIT = 0x00000100;\nvar GL_STENCIL_BUFFER_BIT = 0x00000400;\nvar GL_COLOR_BUFFER_BIT = 0x00004000;\nvar ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';\n\nvar Framebuffer =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Framebuffer, _Resource);\n\n  _createClass(Framebuffer, null, [{\n    key: 'isSupported',\n    value: function isSupported(gl) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          colorBufferFloat = _ref.colorBufferFloat,\n          colorBufferHalfFloat = _ref.colorBufferHalfFloat;\n\n      var supported = true;\n      supported = colorBufferFloat && gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'WEBGL_color_buffer_float');\n      supported = colorBufferHalfFloat && gl.getExtension(isWebGL2(gl) ? 'EXT_color_buffer_float' : 'EXT_color_buffer_half_float');\n      return supported;\n    }\n  }]);\n\n  function Framebuffer(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Framebuffer); // Public members\n\n\n    var _this = _possibleConstructorReturn(this, (Framebuffer.__proto__ || Object.getPrototypeOf(Framebuffer)).call(this, gl, opts));\n\n    _this.width = null;\n    _this.height = null;\n    _this.attachments = {};\n    _this.readBuffer = GL_COLOR_ATTACHMENT0;\n    _this.drawBuffers = [GL_COLOR_ATTACHMENT0];\n\n    _this.initialize(opts);\n\n    Object.seal(_this);\n    return _this;\n  }\n\n  _createClass(Framebuffer, [{\n    key: 'initialize',\n    value: function initialize(_ref2) {\n      var _ref2$width = _ref2.width,\n          width = _ref2$width === undefined ? 1 : _ref2$width,\n          _ref2$height = _ref2.height,\n          height = _ref2$height === undefined ? 1 : _ref2$height,\n          _ref2$attachments = _ref2.attachments,\n          attachments = _ref2$attachments === undefined ? null : _ref2$attachments,\n          _ref2$color = _ref2.color,\n          color = _ref2$color === undefined ? true : _ref2$color,\n          _ref2$depth = _ref2.depth,\n          depth = _ref2$depth === undefined ? true : _ref2$depth,\n          _ref2$stencil = _ref2.stencil,\n          stencil = _ref2$stencil === undefined ? false : _ref2$stencil,\n          _ref2$check = _ref2.check,\n          check = _ref2$check === undefined ? true : _ref2$check,\n          readBuffer = _ref2.readBuffer,\n          drawBuffers = _ref2.drawBuffers;\n      assert(width >= 0 && height >= 0, 'Width and height need to be integers'); // Store actual width and height for diffing\n\n      this.width = width;\n      this.height = height; // Resize any provided attachments - note that resize only resizes if needed\n      // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)\n\n      if (attachments) {\n        for (var attachment in attachments) {\n          var target = attachments[attachment];\n          var object = Array.isArray(target) ? target[0] : target;\n          object.resize({\n            width: width,\n            height: height\n          });\n        }\n      } else {\n        // Create any requested default attachments\n        attachments = this._createDefaultAttachments({\n          color: color,\n          depth: depth,\n          stencil: stencil,\n          width: width,\n          height: height\n        });\n      }\n\n      this.update({\n        clearAttachments: true,\n        attachments: attachments,\n        readBuffer: readBuffer,\n        drawBuffers: drawBuffers\n      }); // Checks that framebuffer was properly set up, if not, throws an explanatory error\n\n      if (attachments && check) {\n        this.checkStatus();\n      }\n    }\n  }, {\n    key: 'update',\n    value: function update(_ref3) {\n      var _ref3$attachments = _ref3.attachments,\n          attachments = _ref3$attachments === undefined ? {} : _ref3$attachments,\n          readBuffer = _ref3.readBuffer,\n          drawBuffers = _ref3.drawBuffers,\n          _ref3$clearAttachment = _ref3.clearAttachments,\n          clearAttachments = _ref3$clearAttachment === undefined ? false : _ref3$clearAttachment;\n      this.attach(attachments, {\n        clearAttachments: clearAttachments\n      });\n      var gl = this.gl; // Multiple render target support, set read buffer and draw buffers\n\n      gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n\n      if (readBuffer) {\n        this._setReadBuffer(readBuffer);\n      }\n\n      if (drawBuffers) {\n        this._setDrawBuffers(drawBuffers);\n      }\n\n      gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n      return this;\n    } // Attachment resize is expected to be a noop if size is same\n\n  }, {\n    key: 'resize',\n    value: function resize(_ref4) {\n      var width = _ref4.width,\n          height = _ref4.height;\n      log.log(2, 'Resizing framebuffer ' + this.id + ' to ' + width + 'x' + height);\n\n      for (var attachmentPoint in this.attachments) {\n        this.attachments[attachmentPoint].resize({\n          width: width,\n          height: height\n        });\n      }\n\n      this.width = width;\n      this.height = height;\n      return this;\n    } // Attach from a map of attachments\n\n  }, {\n    key: 'attach',\n    value: function attach(attachments) {\n      var _this2 = this;\n\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref5$clearAttachment = _ref5.clearAttachments,\n          clearAttachments = _ref5$clearAttachment === undefined ? false : _ref5$clearAttachment;\n\n      var newAttachments = {}; // Any current attachments need to be removed, add null values to map\n\n      if (clearAttachments) {\n        Object.keys(this.attachments).forEach(function (key) {\n          newAttachments[key] = null;\n        });\n      } // Overlay the new attachments\n\n\n      Object.assign(newAttachments, attachments);\n      this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle); // Walk the attachments\n\n      for (var attachment in newAttachments) {\n        // Ensure key is not undefined\n        assert(attachment !== 'undefined', 'Misspelled framebuffer binding point?');\n        var descriptor = newAttachments[attachment];\n        var object = descriptor;\n\n        if (!object) {\n          this._unattach({\n            attachment: attachment\n          });\n        } else if (object instanceof Renderbuffer) {\n          this._attachRenderbuffer({\n            attachment: attachment,\n            renderbuffer: object\n          });\n        } else if (Array.isArray(descriptor)) {\n          var _descriptor = _slicedToArray(descriptor, 3),\n              texture = _descriptor[0],\n              _descriptor$ = _descriptor[1],\n              layer = _descriptor$ === undefined ? 0 : _descriptor$,\n              _descriptor$2 = _descriptor[2],\n              level = _descriptor$2 === undefined ? 0 : _descriptor$2;\n\n          object = texture;\n\n          this._attachTexture({\n            attachment: attachment,\n            texture: texture,\n            layer: layer,\n            level: level\n          });\n        } else {\n          this._attachTexture({\n            attachment: attachment,\n            texture: object,\n            layer: 0,\n            level: 0\n          });\n        } // Resize objects\n\n\n        if (object) {\n          object.resize({\n            width: this.width,\n            height: this.height\n          });\n        }\n      }\n\n      this.gl.bindFramebuffer(GL_FRAMEBUFFER, null); // Assign to attachments and remove any nulls to get a clean attachment map\n\n      Object.assign(this.attachments, attachments);\n      Object.keys(this.attachments).filter(function (key) {\n        return !_this2.attachments[key];\n      }).forEach(function (key) {\n        delete _this2.attachments[key];\n      });\n    }\n  }, {\n    key: 'checkStatus',\n    value: function checkStatus() {\n      var gl = this.gl;\n      gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n      var status = gl.checkFramebufferStatus(GL_FRAMEBUFFER);\n      gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n\n      if (status !== gl.FRAMEBUFFER_COMPLETE) {\n        throw new Error(_getFrameBufferStatus(status));\n      }\n\n      return this;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          color = _ref6.color,\n          depth = _ref6.depth,\n          stencil = _ref6.stencil,\n          _ref6$drawBuffers = _ref6.drawBuffers,\n          drawBuffers = _ref6$drawBuffers === undefined ? [] : _ref6$drawBuffers; // Bind framebuffer and delegate to global clear functions\n\n\n      this.gl.bindFramebuffer(GL_FRAMEBUFFER, this.handle);\n\n      if (color || depth || stencil) {\n        _clear(this.gl, {\n          color: color,\n          depth: depth,\n          stencil: stencil\n        });\n      }\n\n      drawBuffers.forEach(function (value, drawBuffer) {\n        clearBuffer({\n          drawBuffer: drawBuffer,\n          value: value\n        });\n      });\n      this.gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n      return this;\n    } // NOTE: Slow requires roundtrip to GPU\n    // App can provide pixelArray or have it auto allocated by this method\n    // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n    //  newly allocated by this method unless provided by app.\n\n  }, {\n    key: 'readPixels',\n    value: function readPixels(_ref7) {\n      var _ref7$x = _ref7.x,\n          x = _ref7$x === undefined ? 0 : _ref7$x,\n          _ref7$y = _ref7.y,\n          y = _ref7$y === undefined ? 0 : _ref7$y,\n          width = _ref7.width,\n          height = _ref7.height,\n          _ref7$format = _ref7.format,\n          format = _ref7$format === undefined ? GL.RGBA : _ref7$format,\n          type = _ref7.type,\n          _ref7$pixelArray = _ref7.pixelArray,\n          pixelArray = _ref7$pixelArray === undefined ? null : _ref7$pixelArray;\n      var gl = this.gl; // Deduce type and allocated pixelArray if needed\n\n      if (!pixelArray) {\n        // Allocate pixel array if not already available, using supplied type\n        type = type || gl.UNSIGNED_BYTE;\n        var ArrayType = getTypedArrayFromGLType(type, {\n          clamped: false\n        });\n        var components = glFormatToComponents(format); // TODO - check for composite type (components = 1).\n\n        pixelArray = pixelArray || new ArrayType(width * height * components);\n      } // Pixel array available, if necessary, deduce type from it.\n\n\n      type = type || getGLTypeFromTypedArray(pixelArray);\n      this.bind();\n      this.gl.readPixels(x, y, width, height, format, type, pixelArray);\n      this.unbind();\n      return pixelArray;\n    }\n    /**\n     * Copy from framebuffer into a texture\n     */\n\n  }, {\n    key: 'copyToTexture',\n    value: function copyToTexture(_ref8) {\n      var srcFramebuffer = _ref8.srcFramebuffer,\n          x = _ref8.x,\n          y = _ref8.y,\n          width = _ref8.width,\n          height = _ref8.height,\n          texture = _ref8.texture,\n          _ref8$xoffset = _ref8.xoffset,\n          xoffset = _ref8$xoffset === undefined ? 0 : _ref8$xoffset,\n          _ref8$yoffset = _ref8.yoffset,\n          yoffset = _ref8$yoffset === undefined ? 0 : _ref8$yoffset,\n          _ref8$zoffset = _ref8.zoffset,\n          zoffset = _ref8$zoffset === undefined ? 0 : _ref8$zoffset,\n          _ref8$mipmapLevel = _ref8.mipmapLevel,\n          mipmapLevel = _ref8$mipmapLevel === undefined ? 0 : _ref8$mipmapLevel,\n          _ref8$internalFormat = _ref8.internalFormat,\n          internalFormat = _ref8$internalFormat === undefined ? GL.RGBA : _ref8$internalFormat,\n          _ref8$border = _ref8.border,\n          border = _ref8$border === undefined ? 0 : _ref8$border;\n      var gl = this.gl;\n      gl.bindFramebuffer(GL_FRAMEBUFFER, srcFramebuffer.handle); // target\n\n      switch (texture.target) {\n        case GL_TEXTURE_2D:\n        case GL_TEXTURE_CUBE_MAP:\n          gl.copyTexSubImage2D(texture.target, mipmapLevel, internalFormat, x, y, texture.width, texture.height);\n          break;\n\n        case GL_TEXTURE_2D_ARRAY:\n        case GL_TEXTURE_3D:\n          gl.copyTexSubImage3D(texture.target, mipmapLevel, internalFormat, x, y, texture.width, texture.height);\n          break;\n\n        default:\n      }\n\n      gl.bindFramebuffer(GL_FRAMEBUFFER, null);\n      return this;\n    } // WEBGL2 INTERFACE\n    // Copies a rectangle of pixels between framebuffers\n\n  }, {\n    key: 'blit',\n    value: function blit(_ref9) {\n      var srcFramebuffer = _ref9.srcFramebuffer,\n          srcX0 = _ref9.srcX0,\n          srcY0 = _ref9.srcY0,\n          srcX1 = _ref9.srcX1,\n          srcY1 = _ref9.srcY1,\n          dstX0 = _ref9.dstX0,\n          dstY0 = _ref9.dstY0,\n          dstX1 = _ref9.dstX1,\n          dstY1 = _ref9.dstY1,\n          color = _ref9.color,\n          depth = _ref9.depth,\n          stencil = _ref9.stencil,\n          _ref9$mask = _ref9.mask,\n          mask = _ref9$mask === undefined ? 0 : _ref9$mask,\n          _ref9$filter = _ref9.filter,\n          filter = _ref9$filter === undefined ? GL.NEAREST : _ref9$filter;\n      var gl = this.gl;\n      assert(isWebGL2(gl), ERR_WEBGL2);\n\n      if (color) {\n        mask |= GL_COLOR_BUFFER_BIT;\n      }\n\n      if (depth) {\n        mask |= GL_DEPTH_BUFFER_BIT;\n      }\n\n      if (stencil) {\n        mask |= GL_STENCIL_BUFFER_BIT;\n      }\n\n      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, srcFramebuffer.handle);\n      gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, this.handle);\n      gl.blitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\n      gl.bindFramebuffer(GL_DRAW_FRAMEBUFFER, null);\n      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, null);\n      return this;\n    } // signals to the GL that it need not preserve all pixels of a specified region\n    // of the framebuffer\n\n  }, {\n    key: 'invalidate',\n    value: function invalidate(_ref10) {\n      var _ref10$attachments = _ref10.attachments,\n          attachments = _ref10$attachments === undefined ? [] : _ref10$attachments,\n          _ref10$x = _ref10.x,\n          x = _ref10$x === undefined ? 0 : _ref10$x,\n          _ref10$y = _ref10.y,\n          y = _ref10$y === undefined ? 0 : _ref10$y,\n          width = _ref10.width,\n          height = _ref10.height;\n      var gl = this.gl;\n      assert(isWebGL2(gl, ERR_WEBGL2));\n      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, this.handle);\n      var invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;\n\n      if (invalidateAll) {\n        gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments);\n      } else {\n        gl.invalidateFramebuffer(GL_READ_FRAMEBUFFER, attachments, x, y, width, height);\n      }\n\n      gl.bindFramebuffer(GL_READ_FRAMEBUFFER, null);\n      return this;\n    } // Return the value for the passed pname given the target and attachment.\n    // The type returned is the natural type for the requested pname:\n    // pname returned type\n    // If an OpenGL error is generated, returns null.\n\n  }, {\n    key: 'getAttachmentParameter',\n    value: function getAttachmentParameter() {\n      var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref11$target = _ref11.target,\n          target = _ref11$target === undefined ? this.target : _ref11$target,\n          _ref11$attachment = _ref11.attachment,\n          attachment = _ref11$attachment === undefined ? GL_COLOR_ATTACHMENT0 : _ref11$attachment,\n          pname = _ref11.pname;\n\n      var fallback = this._getAttachmentParameterFallback(pname);\n\n      return fallback !== null ? fallback : this.gl.getFramebufferAttachmentParameter(target, attachment, pname);\n    }\n  }, {\n    key: 'getAttachmentParameters',\n    value: function getAttachmentParameters() {\n      var attachment = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : GL_COLOR_ATTACHMENT0;\n      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.constructor.ATTACHMENT_PARAMETERS || {};\n      var values = {};\n\n      for (var pname in parameters) {\n        values[pname] = this.getParameter(pname);\n      }\n\n      return this;\n    } // WEBGL INTERFACE\n\n  }, {\n    key: 'bind',\n    value: function bind() {\n      var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref12$target = _ref12.target,\n          target = _ref12$target === undefined ? GL_FRAMEBUFFER : _ref12$target;\n\n      this.gl.bindFramebuffer(target, this.handle);\n      return this;\n    }\n  }, {\n    key: 'unbind',\n    value: function unbind() {\n      var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref13$target = _ref13.target,\n          target = _ref13$target === undefined ? GL_FRAMEBUFFER : _ref13$target;\n\n      this.gl.bindFramebuffer(target, null);\n      return this;\n    } // PRIVATE METHODS\n\n  }, {\n    key: '_createDefaultAttachments',\n    value: function _createDefaultAttachments(_ref14) {\n      var color = _ref14.color,\n          depth = _ref14.depth,\n          stencil = _ref14.stencil,\n          width = _ref14.width,\n          height = _ref14.height;\n      var defaultAttachments = null; // Add a color buffer if requested and not supplied\n\n      if (color) {\n        var _parameters;\n\n        defaultAttachments = defaultAttachments || {};\n        defaultAttachments[GL_COLOR_ATTACHMENT0] = new Texture2D(this.gl, {\n          data: null,\n          // reserves texture memory, but texels are undefined\n          format: GL.RGBA,\n          type: GL.UNSIGNED_BYTE,\n          width: width,\n          height: height,\n          // Note: Mipmapping can be disabled by texture resource when we resize the texture\n          // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant\n          // behavior we always disable mipmaps.\n          mipmaps: false,\n          // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.\n          // Set WRAP modes that support NPOT textures too.\n          parameters: (_parameters = {}, _defineProperty(_parameters, GL.TEXTURE_MIN_FILTER, GL.NEAREST), _defineProperty(_parameters, GL.TEXTURE_MAG_FILTER, GL.NEAREST), _defineProperty(_parameters, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE), _defineProperty(_parameters, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE), _parameters)\n        });\n      } // Add a depth buffer if requested and not supplied\n\n\n      if (depth) {\n        defaultAttachments = defaultAttachments || {};\n        defaultAttachments[GL_DEPTH_ATTACHMENT] = new Renderbuffer(this.gl, {\n          format: GL.DEPTH_COMPONENT16,\n          width: width,\n          height: height\n        });\n      } // TODO - handle stencil and combined depth and stencil\n\n\n      return defaultAttachments;\n    }\n  }, {\n    key: '_unattach',\n    value: function _unattach(_ref15) {\n      var attachment = _ref15.attachment;\n      this.gl.bindRenderbuffer(GL_RENDERBUFFER, this.handle);\n      this.gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, null);\n      delete this.attachments[attachment];\n    }\n  }, {\n    key: '_attachRenderbuffer',\n    value: function _attachRenderbuffer(_ref16) {\n      var _ref16$attachment = _ref16.attachment,\n          attachment = _ref16$attachment === undefined ? GL_COLOR_ATTACHMENT0 : _ref16$attachment,\n          renderbuffer = _ref16.renderbuffer;\n      var gl = this.gl; // TODO - is the bind needed?\n      // gl.bindRenderbuffer(GL_RENDERBUFFER, renderbuffer.handle);\n\n      gl.framebufferRenderbuffer(GL_FRAMEBUFFER, attachment, GL_RENDERBUFFER, renderbuffer.handle); // TODO - is the unbind needed?\n      // gl.bindRenderbuffer(GL_RENDERBUFFER, null);\n\n      this.attachments[attachment] = renderbuffer;\n    } // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`\n    // level = 0 - mipmapLevel (must be 0 in WebGL1)\n\n  }, {\n    key: '_attachTexture',\n    value: function _attachTexture(_ref17) {\n      var _ref17$attachment = _ref17.attachment,\n          attachment = _ref17$attachment === undefined ? GL_COLOR_ATTACHMENT0 : _ref17$attachment,\n          texture = _ref17.texture,\n          layer = _ref17.layer,\n          level = _ref17.level;\n      var gl = this.gl;\n      gl.bindTexture(texture.target, texture.handle);\n\n      switch (texture.target) {\n        case GL_TEXTURE_2D_ARRAY:\n        case GL_TEXTURE_3D:\n          gl.framebufferTextureLayer(GL_FRAMEBUFFER, attachment, texture.target, level, layer);\n          break;\n\n        case GL_TEXTURE_CUBE_MAP:\n          // layer must be a cubemap face (or if index, converted to cube map face)\n          var face = mapIndexToCubeMapFace(layer);\n          gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, face, texture.handle, level);\n          break;\n\n        case GL_TEXTURE_2D:\n          gl.framebufferTexture2D(GL_FRAMEBUFFER, attachment, GL_TEXTURE_2D, texture.handle, level);\n          break;\n\n        default:\n          assert(false, 'Illegal texture type');\n      }\n\n      gl.bindTexture(texture.target, null);\n      this.attachments[attachment] = texture;\n    } // Expects framebuffer to be bound\n\n  }, {\n    key: '_setReadBuffer',\n    value: function _setReadBuffer(gl, readBuffer) {\n      if (isWebGL2(gl)) {\n        gl.readBuffer(readBuffer);\n      } else {\n        // Setting to color attachment 0 is a noop, so allow it in WebGL1\n        assert(readBuffer === GL_COLOR_ATTACHMENT0 || readBuffer === GL.BACK, ERR_MULTIPLE_RENDERTARGETS);\n      }\n\n      this.readBuffer = readBuffer;\n    } // Expects framebuffer to be bound\n\n  }, {\n    key: '_setDrawBuffers',\n    value: function _setDrawBuffers(gl, drawBuffers) {\n      if (isWebGL2(gl)) {\n        gl.drawBuffers(drawBuffers);\n      } else {\n        var ext = gl.getExtension('WEBGL_draw_buffers');\n\n        if (ext) {\n          ext.drawBuffersWEBGL(drawBuffers);\n        } else {\n          // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1\n          assert(drawBuffers.length === 1 && (drawBuffers[0] === GL_COLOR_ATTACHMENT0 || drawBuffers[0] === GL.BACK), ERR_MULTIPLE_RENDERTARGETS);\n        }\n      }\n\n      this.drawBuffers = drawBuffers;\n    } // Attempt to provide workable defaults for WebGL2 symbols under WebGL1\n    // null means OK to query\n\n    /* eslint-disable complexity */\n\n  }, {\n    key: '_getAttachmentParameterFallback',\n    value: function _getAttachmentParameterFallback(pname) {\n      var caps = getFeatures(this.gl);\n\n      switch (pname) {\n        case GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER:\n          // GLint\n          return !caps.webgl2 ? 0 : null;\n\n        case GL.FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint\n\n        case GL.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint\n\n        case GL.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint\n\n        case GL.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint\n\n        case GL.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint\n\n        case GL.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE:\n          // GLint\n          return !caps.webgl2 ? 8 : null;\n\n        case GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE:\n          // GLenum\n          return !caps.webgl2 ? GL.UNSIGNED_INT : null;\n\n        case GL.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:\n          return !caps.webgl2 && !caps.EXT_sRGB ? GL.LINEAR : null;\n\n        default:\n          return null;\n      }\n    }\n    /* eslint-enable complexity */\n    // RESOURCE METHODS\n\n  }, {\n    key: '_createHandle',\n    value: function _createHandle() {\n      return this.gl.createFramebuffer();\n    }\n  }, {\n    key: '_deleteHandle',\n    value: function _deleteHandle() {\n      this.gl.deleteFramebuffer(this.handle);\n    }\n  }, {\n    key: 'color',\n    get: function get() {\n      return this.attachments[GL_COLOR_ATTACHMENT0] || null;\n    }\n  }, {\n    key: 'texture',\n    get: function get() {\n      return this.attachments[GL_COLOR_ATTACHMENT0] || null;\n    }\n  }, {\n    key: 'depth',\n    get: function get() {\n      return this.attachments[GL_DEPTH_ATTACHMENT] || null;\n    }\n  }, {\n    key: 'stencil',\n    get: function get() {\n      return this.attachments[GL_STENCIL_ATTACHMENT] || null;\n    }\n  }]);\n\n  return Framebuffer;\n}(Resource); // PUBLIC METHODS\n// Map an index to a cube map face constant\n\n\nexport default Framebuffer;\n\nfunction mapIndexToCubeMapFace(layer) {\n  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)\n  // if smaller assume layer is index, otherwise assume it is already a cube map face constant\n  return layer < GL_TEXTURE_CUBE_MAP_POSITIVE_X ? layer + GL_TEXTURE_CUBE_MAP_POSITIVE_X : layer;\n} // Returns number of components in a specific WebGL format\n\n\nfunction glFormatToComponents(format) {\n  switch (format) {\n    case GL.ALPHA:\n      return 1;\n\n    case GL.RGB:\n      return 3;\n\n    case GL.RGBA:\n      return 4;\n\n    default:\n      throw new Error('Unknown format');\n  }\n} // Get a string describing the framebuffer error if installed\n\n\nfunction _getFrameBufferStatus(status) {\n  // Use error mapping if installed\n  var STATUS = Framebuffer.STATUS || {};\n  return STATUS[status] || 'Framebuffer error ' + status;\n}","map":null,"metadata":{},"sourceType":"module"}