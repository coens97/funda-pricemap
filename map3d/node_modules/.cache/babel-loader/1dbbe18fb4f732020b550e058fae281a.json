{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { equals } from 'math.gl';\nimport assert from '../utils/assert';\n\nvar TransitionInterpolator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param opts {array|object}\n   * @param opts.compare {array} - prop names used in equality check\n   * @param opts.extract {array} - prop names needed for interpolation\n   * @param opts.required {array} - prop names that must be supplied\n   * alternatively, supply one list of prop names as `opts` if all of the above are the same.\n   */\n  function TransitionInterpolator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TransitionInterpolator);\n\n    if (Array.isArray(opts)) {\n      opts = {\n        compare: opts,\n        extract: opts,\n        required: opts\n      };\n    }\n\n    var _opts = opts,\n        compare = _opts.compare,\n        extract = _opts.extract,\n        required = _opts.required;\n    this._propsToCompare = compare;\n    this._propsToExtract = extract;\n    this._requiredProps = required;\n  }\n  /**\n   * Checks if two sets of props need transition in between\n   * @param currentProps {object} - a list of viewport props\n   * @param nextProps {object} - a list of viewport props\n   * @returns {bool} - true if two props are equivalent\n   */\n\n\n  _createClass(TransitionInterpolator, [{\n    key: \"arePropsEqual\",\n    value: function arePropsEqual(currentProps, nextProps) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = (this._propsToCompare || Object.keys(nextProps))[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          if (!equals(currentProps[key], nextProps[key])) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Called before transition starts to validate/pre-process start and end props\n     * @param startProps {object} - a list of starting viewport props\n     * @param endProps {object} - a list of target viewport props\n     * @returns {Object} {start, end} - start and end props to be passed\n     *   to `interpolateProps`\n     */\n\n  }, {\n    key: \"initializeProps\",\n    value: function initializeProps(startProps, endProps) {\n      var result;\n\n      if (this._propsToExtract) {\n        var startViewStateProps = {};\n        var endViewStateProps = {};\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this._propsToExtract[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var key = _step2.value;\n            startViewStateProps[key] = startProps[key];\n            endViewStateProps[key] = endProps[key];\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        result = {\n          start: startViewStateProps,\n          end: endViewStateProps\n        };\n      } else {\n        result = {\n          start: startProps,\n          end: endProps\n        };\n      }\n\n      this._checkRequiredProps(result.start);\n\n      this._checkRequiredProps(result.end);\n\n      return result;\n    }\n    /**\n     * Returns viewport props in transition\n     * @param startProps {object} - a list of starting viewport props\n     * @param endProps {object} - a list of target viewport props\n     * @param t {number} - a time factor between [0, 1]\n     * @returns {object} - a list of interpolated viewport props\n     */\n\n  }, {\n    key: \"interpolateProps\",\n    value: function interpolateProps(startProps, endProps, t) {\n      assert(false, 'interpolateProps is not implemented');\n    }\n  }, {\n    key: \"_checkRequiredProps\",\n    value: function _checkRequiredProps(props) {\n      if (!this._requiredProps) {\n        return;\n      }\n\n      this._requiredProps.forEach(function (propName) {\n        var value = props[propName];\n        assert(Number.isFinite(value) || Array.isArray(value), \"\".concat(propName, \" is required for transition\"));\n      });\n    }\n  }]);\n\n  return TransitionInterpolator;\n}();\n\nexport { TransitionInterpolator as default };","map":null,"metadata":{},"sourceType":"module"}