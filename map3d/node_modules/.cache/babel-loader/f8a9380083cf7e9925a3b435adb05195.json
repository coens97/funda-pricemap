{"ast":null,"code":"// Resizing a webgl canvas\n\n/* global window, document */\nvar isBrowser = typeof window !== 'undefined';\nvar isPageLoaded = false;\nvar pageLoadPromise = isBrowser ? new Promise(function (resolve, reject) {\n  window.onload = function () {\n    isPageLoaded = true;\n    resolve(document);\n  };\n}) : Promise.resolve({});\n/**\n * Returns a promise that resolves when the page is loaded\n * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted\n * @return {Promise} - resolves when the page is loaded\n */\n\nexport function getPageLoadPromise() {\n  return pageLoadPromise;\n}\n/**\n * Create a canvas\n * @param {Number} width - set to 100%\n * @param {Number} height - set to 100%\n */\n\nexport function createCanvas(_ref) {\n  var _ref$width = _ref.width,\n      width = _ref$width === undefined ? 800 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === undefined ? 600 : _ref$height,\n      _ref$id = _ref.id,\n      id = _ref$id === undefined ? 'gl-canvas' : _ref$id,\n      _ref$insert = _ref.insert,\n      insert = _ref$insert === undefined ? true : _ref$insert;\n  var canvas = document.createElement('canvas');\n  canvas.id = id;\n  canvas.style.width = Number.isFinite(width) ? width + 'px' : '100%';\n  canvas.style.height = Number.isFinite(height) ? height + 'px' : '100%'; // add the canvas to the body element once the page has loaded\n\n  if (insert) {\n    getPageLoadPromise().then(function (document) {\n      var body = document.body;\n      body.insertBefore(canvas, body.firstChild);\n    });\n  }\n\n  return canvas;\n}\n/**\n * Gets an already created canvas from the DOM\n * @param {Number} id - DOM element id\n */\n\nexport function getCanvas(_ref2) {\n  var id = _ref2.id;\n\n  if (!isPageLoaded) {\n    throw new Error('createGLContext called on canvas \\'' + id + '\\' before page was loaded');\n  }\n\n  return document.getElementById(id);\n} // Gets current size of canvas in css (logical/window) coordinates\n\nexport function getCSSSize(canvas) {\n  return {\n    width: canvas.clientWidth,\n    height: canvas.clientHeight\n  };\n} // Gets current size of canvas drawing buffer in actual pixels\n// This is needed for the gl.viewport call\n\nexport function getDrawingBufferSize(canvas) {\n  return {\n    width: canvas.width,\n    height: canvas.height\n  };\n} // Calculate the drawing buffer size that would cover current canvas size and device pixel ratio\n// Intention is that every pixel in the drawing buffer will have a 1-to-1 mapping with\n// actual device pixels in the hardware framebuffer, allowing us to render at the full\n// resolution of the device.\n\nexport function calculateDrawingBufferSize(canvas, _ref3) {\n  var _ref3$useDevicePixelR = _ref3.useDevicePixelRatio,\n      useDevicePixelRatio = _ref3$useDevicePixelR === undefined ? true : _ref3$useDevicePixelR;\n  var cssToDevicePixels = useDevicePixelRatio ? window.devicePixelRatio || 1 : 1; // Lookup the size the browser is displaying the canvas in CSS pixels\n  // and compute a size needed to make our drawingbuffer match it in\n  // device pixels.\n\n  var cssSize = getCSSSize(canvas);\n  return {\n    width: Math.floor(cssSize.width * cssToDevicePixels),\n    height: Math.floor(cssSize.height * cssToDevicePixels),\n    devicePixelRatio: cssToDevicePixels\n  };\n}\n/**\n * Resizes canvas in \"CSS coordinates\" (note these can be very different from device coords,\n * depending on devicePixelRatio/retina screens and size of drawing buffer)\n * and can be changed separately from drawing buffer size.\n * Therefore, normally `resizeDrawingBuffer` should be called after calling `resizeCanvas`.\n *\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width, height - new width and height of canvas in CSS coordinates\n */\n\nexport function resizeCanvas(canvas, _ref4) {\n  var width = _ref4.width,\n      height = _ref4.height,\n      _ref4$useDevicePixelR = _ref4.useDevicePixelRatio,\n      useDevicePixelRatio = _ref4$useDevicePixelR === undefined ? true : _ref4$useDevicePixelR;\n  canvas.style.width = width + 'px';\n  canvas.style.height = height + 'px';\n}\n/**\n * Resize the canvas' drawing buffer to match the canvas CSS size,\n * and by default to also consider devicePixelRatio\n * detects if anything has changed, can be called every frame\n * for best visual results, usually set to either:\n *  canvas CSS width x canvas CSS height\n *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio\n *\n * NOTE: Regardless of size, the drawing buffer will always be scaled to the viewport\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * @param {Number} width - new width of canvas in CSS coordinates\n * @param {Number} height - new height of canvas in CSS coordinates\n */\n\nexport function resizeDrawingBuffer(canvas, _ref5) {\n  var _ref5$useDevicePixelR = _ref5.useDevicePixelRatio,\n      useDevicePixelRatio = _ref5$useDevicePixelR === undefined ? true : _ref5$useDevicePixelR; // Resize the render buffer of the canvas to match canvas client size\n  // multiplying with dpr (Optionally can be turned off)\n\n  var newBufferSize = calculateDrawingBufferSize(canvas, {\n    useDevicePixelRatio: useDevicePixelRatio\n  }); // Only update if the canvas size has not changed\n\n  if (newBufferSize.width !== canvas.width || newBufferSize.height !== canvas.height) {\n    // Make the canvas render buffer the same size as\n    canvas.width = newBufferSize.width;\n    canvas.height = newBufferSize.height; // Always reset CSS size after setting drawing buffer size\n    // canvas.style.width = `${cssSize.width}px`;\n    // canvas.style.height = `${cssSize.height}px`;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}