{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\n\n\nimport Stats from './stats';\nimport log from '../utils/log';\nimport { GL } from 'luma.gl';\nimport assert from 'assert';\nvar LOG_START_END_PRIORITY = 1;\nvar LOG_DETAIL_PRIORITY = 2;\n\nfunction noop() {}\n/* eslint-disable complexity */\n\n\nexport function glArrayFromType(glType) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$clamped = _ref.clamped,\n      clamped = _ref$clamped === undefined ? true : _ref$clamped; // Sorted in some order of likelihood to reduce amount of comparisons\n\n\n  switch (glType) {\n    case GL.FLOAT:\n      return Float32Array;\n\n    case GL.UNSIGNED_SHORT:\n    case GL.UNSIGNED_SHORT_5_6_5:\n    case GL.UNSIGNED_SHORT_4_4_4_4:\n    case GL.UNSIGNED_SHORT_5_5_5_1:\n      return Uint16Array;\n\n    case GL.UNSIGNED_INT:\n      return Uint32Array;\n\n    case GL.UNSIGNED_BYTE:\n      return clamped ? Uint8ClampedArray : Uint8Array;\n\n    case GL.BYTE:\n      return Int8Array;\n\n    case GL.SHORT:\n      return Int16Array;\n\n    case GL.INT:\n      return Int32Array;\n\n    default:\n      throw new Error('Failed to deduce type from array');\n  }\n}\n/* eslint-enable complexity */\n// Default loggers\n\nvar logFunctions = {\n  savedMessages: null,\n  timeStart: null,\n  onLog: function onLog(_ref2) {\n    var level = _ref2.level,\n        message = _ref2.message;\n    log.log(level, message);\n  },\n  onUpdateStart: function onUpdateStart(_ref3) {\n    var level = _ref3.level,\n        id = _ref3.id,\n        numInstances = _ref3.numInstances;\n    logFunctions.savedMessages = [];\n    logFunctions.timeStart = new Date();\n  },\n  onUpdate: function onUpdate(_ref4) {\n    var level = _ref4.level,\n        message = _ref4.message;\n\n    if (logFunctions.savedMessages) {\n      logFunctions.savedMessages.push(message);\n    }\n  },\n  onUpdateEnd: function onUpdateEnd(_ref5) {\n    var level = _ref5.level,\n        id = _ref5.id,\n        numInstances = _ref5.numInstances;\n    var timeMs = Math.round(new Date() - logFunctions.timeStart);\n    var time = timeMs + 'ms';\n    log.group(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in ' + time, {\n      collapsed: true\n    });\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var message = _step.value;\n        log.log(level, message);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    log.groupEnd(level, 'Updated attributes for ' + numInstances + ' instances in ' + id + ' in ' + time);\n    logFunctions.savedMessages = null;\n  }\n};\n\nvar AttributeManager = function () {\n  _createClass(AttributeManager, null, [{\n    key: 'setDefaultLogFunctions',\n\n    /**\n     * Sets log functions to help trace or time attribute updates.\n     * Default logging uses deck logger.\n     *\n     * `onLog` is called for each attribute.\n     *\n     * To enable detailed control of timming and e.g. hierarchical logging,\n     * hooks are also provided for update start and end.\n     *\n     * @param {Object} [opts]\n     * @param {String} [opts.onLog=] - called to print\n     * @param {String} [opts.onUpdateStart=] - called before update() starts\n     * @param {String} [opts.onUpdateEnd=] - called after update() ends\n     */\n    value: function setDefaultLogFunctions() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          onLog = _ref6.onLog,\n          onUpdateStart = _ref6.onUpdateStart,\n          onUpdate = _ref6.onUpdate,\n          onUpdateEnd = _ref6.onUpdateEnd;\n\n      if (onLog !== undefined) {\n        logFunctions.onLog = onLog || noop;\n      }\n\n      if (onUpdateStart !== undefined) {\n        logFunctions.onUpdateStart = onUpdateStart || noop;\n      }\n\n      if (onUpdate !== undefined) {\n        logFunctions.onUpdate = onUpdate || noop;\n      }\n\n      if (onUpdateEnd !== undefined) {\n        logFunctions.onUpdateEnd = onUpdateEnd || noop;\n      }\n    }\n    /**\n     * @classdesc\n     * Automated attribute generation and management. Suitable when a set of\n     * vertex shader attributes are generated by iteration over a data array,\n     * and updates to these attributes are needed either when the data itself\n     * changes, or when other data relevant to the calculations change.\n     *\n     * - First the application registers descriptions of its dynamic vertex\n     *   attributes using AttributeManager.add().\n     * - Then, when any change that affects attributes is detected by the\n     *   application, the app will call AttributeManager.invalidate().\n     * - Finally before it renders, it calls AttributeManager.update() to\n     *   ensure that attributes are automatically rebuilt if anything has been\n     *   invalidated.\n     *\n     * The application provided update functions describe how attributes\n     * should be updated from a data array and are expected to traverse\n     * that data array (or iterable) and fill in the attribute's typed array.\n     *\n     * Note that the attribute manager intentionally does not do advanced\n     * change detection, but instead makes it easy to build such detection\n     * by offering the ability to \"invalidate\" each attribute separately.\n     *\n     * Summary:\n     * - keeps track of valid state for each attribute\n     * - auto reallocates attributes when needed\n     * - auto updates attributes with registered updater functions\n     * - allows overriding with application supplied buffers\n     *\n     * Limitations:\n     * - There are currently no provisions for only invalidating a range of\n     *   indices in an attribute.\n     *\n     * @class\n     * @param {Object} [props]\n     * @param {String} [props.id] - identifier (for debugging)\n     */\n\n  }]);\n\n  function AttributeManager() {\n    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref7$id = _ref7.id,\n        id = _ref7$id === undefined ? 'attribute-manager' : _ref7$id;\n\n    _classCallCheck(this, AttributeManager);\n\n    this.id = id;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.allocedInstances = -1;\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = new Stats({\n      id: 'attr'\n    }); // For debugging sanity, prevent uninitialized members\n\n    Object.seal(this);\n  }\n  /**\n   * Adds attributes\n   * Takes a map of attribute descriptor objects\n   * - keys are attribute names\n   * - values are objects with attribute fields\n   *\n   * attribute.size - number of elements per object\n   * attribute.updater - number of elements\n   * attribute.instanced=0 - is this is an instanced attribute (a.k.a. divisor)\n   * attribute.noAlloc=false - if this attribute should not be allocated\n   *\n   * @example\n   * attributeManager.add({\n   *   positions: {size: 2, update: calculatePositions}\n   *   colors: {size: 3, update: calculateColors}\n   * });\n   *\n   * @param {Object} attributes - attribute map (see above)\n   * @param {Object} updaters - separate map of update functions (deprecated)\n   */\n\n\n  _createClass(AttributeManager, [{\n    key: 'add',\n    value: function add(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._add(attributes, updaters);\n    }\n    /**\n     * Removes attributes\n     * Takes an array of attribute names and delete them from\n     * the attribute map if they exists\n     *\n     * @example\n     * attributeManager.remove(['position']);\n     *\n     * @param {Object} attributeNameArray - attribute name array (see above)\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(attributeNameArray) {\n      for (var i = 0; i < attributeNameArray.length; i++) {\n        var name = attributeNameArray[i];\n\n        if (this.attributes[name] !== undefined) {\n          delete this.attributes[name];\n        }\n      }\n    }\n    /* Marks an attribute for update\n     * @param {string} triggerName: attribute or accessor name\n     */\n\n  }, {\n    key: 'invalidate',\n    value: function invalidate(triggerName) {\n      var invalidatedAttributes = this._invalidateTrigger(triggerName); // For performance tuning\n\n\n      logFunctions.onLog({\n        level: LOG_DETAIL_PRIORITY,\n        message: 'invalidated attributes ' + invalidatedAttributes + ' (' + triggerName + ') for ' + this.id,\n        id: this.identifier\n      });\n    }\n  }, {\n    key: 'invalidateAll',\n    value: function invalidateAll() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].needsUpdate = true;\n      } // For performance tuning\n\n\n      logFunctions.onLog({\n        level: LOG_DETAIL_PRIORITY,\n        message: 'invalidated all attributes for ' + this.id,\n        id: this.identifier\n      });\n    }\n  }, {\n    key: '_invalidateTrigger',\n    value: function _invalidateTrigger(triggerName) {\n      var attributes = this.attributes,\n          updateTriggers = this.updateTriggers;\n      var invalidatedAttributes = updateTriggers[triggerName];\n\n      if (!invalidatedAttributes) {\n        var message = 'invalidating non-existent trigger ' + triggerName + ' for ' + this.id + '\\n';\n        message += 'Valid triggers: ' + Object.keys(attributes).join(', ');\n        log.warn(message, invalidatedAttributes);\n      } else {\n        invalidatedAttributes.forEach(function (name) {\n          var attribute = attributes[name];\n\n          if (attribute) {\n            attribute.needsUpdate = true;\n          }\n        });\n      }\n\n      return invalidatedAttributes;\n    }\n    /**\n     * Ensure all attribute buffers are updated from props or data.\n     *\n     * Note: Any preallocated buffers in \"buffers\" matching registered attribute\n     * names will be used. No update will happen in this case.\n     * Note: Calls onUpdateStart and onUpdateEnd log callbacks before and after.\n     *\n     * @param {Object} opts - options\n     * @param {Object} opts.data - data (iterable object)\n     * @param {Object} opts.numInstances - count of data\n     * @param {Object} opts.buffers = {} - pre-allocated buffers\n     * @param {Object} opts.props - passed to updaters\n     * @param {Object} opts.context - Used as \"this\" context for updaters\n     */\n\n  }, {\n    key: 'update',\n    value: function update() {\n      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          data = _ref8.data,\n          numInstances = _ref8.numInstances,\n          _ref8$props = _ref8.props,\n          props = _ref8$props === undefined ? {} : _ref8$props,\n          _ref8$buffers = _ref8.buffers,\n          buffers = _ref8$buffers === undefined ? {} : _ref8$buffers,\n          _ref8$context = _ref8.context,\n          context = _ref8$context === undefined ? {} : _ref8$context,\n          _ref8$ignoreUnknownAt = _ref8.ignoreUnknownAttributes,\n          ignoreUnknownAttributes = _ref8$ignoreUnknownAt === undefined ? false : _ref8$ignoreUnknownAt; // First apply any application provided buffers\n\n\n      this._checkExternalBuffers({\n        buffers: buffers,\n        ignoreUnknownAttributes: ignoreUnknownAttributes\n      });\n\n      this._setExternalBuffers(buffers); // Only initiate alloc/update (and logging) if actually needed\n\n\n      if (this._analyzeBuffers({\n        numInstances: numInstances\n      })) {\n        logFunctions.onUpdateStart({\n          level: LOG_START_END_PRIORITY,\n          id: this.id,\n          numInstances: numInstances\n        });\n        this.stats.timeStart();\n\n        this._updateBuffers({\n          numInstances: numInstances,\n          data: data,\n          props: props,\n          context: context\n        });\n\n        this.stats.timeEnd();\n        logFunctions.onUpdateEnd({\n          level: LOG_START_END_PRIORITY,\n          id: this.id,\n          numInstances: numInstances\n        });\n      }\n    }\n    /**\n     * Returns all attribute descriptors\n     * Note: Format matches luma.gl Model/Program.setAttributes()\n     * @return {Object} attributes - descriptors\n     */\n\n  }, {\n    key: 'getAttributes',\n    value: function getAttributes() {\n      return this.attributes;\n    }\n    /**\n     * Returns changed attribute descriptors\n     * This indicates which WebGLBuggers need to be updated\n     * @return {Object} attributes - descriptors\n     */\n\n  }, {\n    key: 'getChangedAttributes',\n    value: function getChangedAttributes(_ref9) {\n      var _ref9$clearChangedFla = _ref9.clearChangedFlags,\n          clearChangedFlags = _ref9$clearChangedFla === undefined ? false : _ref9$clearChangedFla;\n      var attributes = this.attributes;\n      var changedAttributes = {};\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        if (attribute.changed) {\n          attribute.changed = attribute.changed && !clearChangedFlags;\n          changedAttributes[attributeName] = attribute;\n        }\n      }\n\n      return changedAttributes;\n    }\n    /**\n     * Returns the redraw flag, optionally clearing it.\n     * Redraw flag will be set if any attributes attributes changed since\n     * flag was last cleared.\n     *\n     * @param {Object} [opts]\n     * @param {String} [opts.clearRedrawFlags=false] - whether to clear the flag\n     * @return {false|String} - reason a redraw is needed.\n     */\n\n  }, {\n    key: 'getNeedsRedraw',\n    value: function getNeedsRedraw() {\n      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref10$clearRedrawFla = _ref10.clearRedrawFlags,\n          clearRedrawFlags = _ref10$clearRedrawFla === undefined ? false : _ref10$clearRedrawFla;\n\n      var redraw = this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n      return redraw && this.id;\n    }\n    /**\n     * Sets the redraw flag.\n     * @param {Boolean} redraw=true\n     * @return {AttributeManager} - for chaining\n     */\n\n  }, {\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = true;\n      return this;\n    } // DEPRECATED METHODS\n\n    /**\n     * Adds attributes\n     * @param {Object} attributes - attribute map (see above)\n     * @param {Object} updaters - separate map of update functions (deprecated)\n     */\n\n  }, {\n    key: 'addInstanced',\n    value: function addInstanced(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._add(attributes, updaters, {\n        instanced: 1\n      });\n    } // PROTECTED METHODS - Only to be used by collaborating classes, not by apps\n\n    /**\n     * Returns object containing all accessors as keys, with non-null values\n     * @return {Object} - accessors object\n     */\n\n  }, {\n    key: 'getAccessors',\n    value: function getAccessors() {\n      return this.updateTriggers;\n    } // PRIVATE METHODS\n    // Used to register an attribute\n\n  }, {\n    key: '_add',\n    value: function _add(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var newAttributes = {};\n\n      for (var attributeName in attributes) {\n        // support for separate update function map\n        // For now, just copy any attributes from that map into the main map\n        // TODO - Attribute maps are a deprecated feature, remove\n        if (attributeName in updaters) {\n          attributes[attributeName] = Object.assign({}, attributes[attributeName], updaters[attributeName]);\n        }\n\n        var attribute = attributes[attributeName];\n        var isIndexed = attribute.isIndexed || attribute.elements;\n        var size = attribute.elements && 1 || attribute.size;\n        var value = attribute.value || null; // Initialize the attribute descriptor, with WebGL and metadata fields\n\n        var attributeData = Object.assign({\n          // Ensure that fields are present before Object.seal()\n          target: undefined,\n          userData: {} // Reserved for application\n\n        }, // Metadata\n        attribute, {\n          // State\n          isExternalBuffer: false,\n          needsAlloc: false,\n          needsUpdate: false,\n          changed: false,\n          // Luma fields\n          isIndexed: isIndexed,\n          size: size,\n          value: value\n        }, _extraProps); // Sanity - no app fields on our attributes. Use userData instead.\n\n        Object.seal(attributeData); // Check all fields and generate helpful error messages\n\n        this._validateAttributeDefinition(attributeName, attributeData); // Add to both attributes list (for registration with model)\n\n\n        newAttributes[attributeName] = attributeData;\n      }\n\n      Object.assign(this.attributes, newAttributes);\n\n      this._mapUpdateTriggersToAttributes();\n    } // build updateTrigger name to attribute name mapping\n\n  }, {\n    key: '_mapUpdateTriggersToAttributes',\n    value: function _mapUpdateTriggersToAttributes() {\n      var _this = this;\n\n      var triggers = {};\n\n      var _loop = function _loop(attributeName) {\n        var attribute = _this.attributes[attributeName];\n        var accessor = attribute.accessor; // Backards compatibility: allow attribute name to be used as update trigger key\n\n        triggers[attributeName] = [attributeName]; // use accessor name as update trigger key\n\n        if (typeof accessor === 'string') {\n          accessor = [accessor];\n        }\n\n        if (Array.isArray(accessor)) {\n          accessor.forEach(function (accessorName) {\n            if (!triggers[accessorName]) {\n              triggers[accessorName] = [];\n            }\n\n            triggers[accessorName].push(attributeName);\n          });\n        }\n      };\n\n      for (var attributeName in this.attributes) {\n        _loop(attributeName);\n      }\n\n      this.updateTriggers = triggers;\n    }\n  }, {\n    key: '_validateAttributeDefinition',\n    value: function _validateAttributeDefinition(attributeName, attribute) {\n      assert(attribute.size >= 1 && attribute.size <= 4, 'Attribute definition for ' + attributeName + ' invalid size'); // Check that either 'accessor' or 'update' is a valid function\n\n      var hasUpdater = attribute.noAlloc || typeof attribute.update === 'function' || typeof attribute.accessor === 'string';\n\n      if (!hasUpdater) {\n        throw new Error('Attribute ' + attributeName + ' missing update or accessor');\n      }\n    } // Checks that any attribute buffers in props are valid\n    // Note: This is just to help app catch mistakes\n\n  }, {\n    key: '_checkExternalBuffers',\n    value: function _checkExternalBuffers() {\n      var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref11$buffers = _ref11.buffers,\n          buffers = _ref11$buffers === undefined ? {} : _ref11$buffers,\n          _ref11$ignoreUnknownA = _ref11.ignoreUnknownAttributes,\n          ignoreUnknownAttributes = _ref11$ignoreUnknownA === undefined ? false : _ref11$ignoreUnknownA;\n\n      var attributes = this.attributes;\n\n      for (var attributeName in buffers) {\n        var attribute = attributes[attributeName];\n\n        if (!attribute && !ignoreUnknownAttributes) {\n          throw new Error('Unknown attribute prop ' + attributeName);\n        } // const buffer = buffers[attributeName];\n        // TODO - check buffer type\n\n      }\n    } // Set the buffers for the supplied attributes\n    // Update attribute buffers from any attributes in props\n    // Detach any previously set buffers, marking all\n    // Attributes for auto allocation\n\n    /* eslint-disable max-statements */\n\n  }, {\n    key: '_setExternalBuffers',\n    value: function _setExternalBuffers(bufferMap) {\n      var attributes = this.attributes,\n          numInstances = this.numInstances; // Copy the refs of any supplied buffers in the props\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n        var buffer = bufferMap[attributeName];\n        attribute.isExternalBuffer = false;\n\n        if (buffer) {\n          var ArrayType = glArrayFromType(attribute.type || GL.FLOAT);\n\n          if (!(buffer instanceof ArrayType)) {\n            throw new Error('Attribute ' + attributeName + ' must be of type ' + ArrayType.name);\n          }\n\n          if (attribute.auto && buffer.length <= numInstances * attribute.size) {\n            throw new Error('Attribute prop array must match length and size');\n          }\n\n          attribute.isExternalBuffer = true;\n          attribute.needsUpdate = false;\n\n          if (attribute.value !== buffer) {\n            attribute.value = buffer;\n            attribute.changed = true;\n            this.needsRedraw = true;\n          }\n        }\n      }\n    }\n    /* eslint-enable max-statements */\n\n    /* Checks that typed arrays for attributes are big enough\n     * sets alloc flag if not\n     * @return {Boolean} whether any updates are needed\n     */\n\n  }, {\n    key: '_analyzeBuffers',\n    value: function _analyzeBuffers(_ref12) {\n      var numInstances = _ref12.numInstances;\n      var attributes = this.attributes;\n      assert(numInstances !== undefined, 'numInstances not defined'); // Track whether any allocations or updates are needed\n\n      var needsUpdate = false;\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        if (!attribute.isExternalBuffer) {\n          // Do we need to reallocate the attribute's typed array?\n          var needsAlloc = attribute.value === null || attribute.value.length / attribute.size < numInstances;\n\n          if (needsAlloc && (attribute.update || attribute.accessor)) {\n            attribute.needsAlloc = true;\n            needsUpdate = true;\n          }\n\n          if (attribute.needsUpdate) {\n            needsUpdate = true;\n          }\n        }\n      }\n\n      return needsUpdate;\n    }\n    /**\n     * @private\n     * Calls update on any buffers that need update\n     * TODO? - If app supplied all attributes, no need to iterate over data\n     *\n     * @param {Object} opts - options\n     * @param {Object} opts.data - data (iterable object)\n     * @param {Object} opts.numInstances - count of data\n     * @param {Object} opts.buffers = {} - pre-allocated buffers\n     * @param {Object} opts.props - passed to updaters\n     * @param {Object} opts.context - Used as \"this\" context for updaters\n     */\n\n    /* eslint-disable max-statements, complexity */\n\n  }, {\n    key: '_updateBuffers',\n    value: function _updateBuffers(_ref13) {\n      var numInstances = _ref13.numInstances,\n          data = _ref13.data,\n          props = _ref13.props,\n          context = _ref13.context;\n      var attributes = this.attributes; // Allocate at least one element to ensure a valid buffer\n\n      var allocCount = Math.max(numInstances, 1);\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName]; // Allocate a new typed array if needed\n\n        if (attribute.needsAlloc) {\n          var ArrayType = glArrayFromType(attribute.type || GL.FLOAT);\n          attribute.value = new ArrayType(attribute.size * allocCount);\n          logFunctions.onUpdate({\n            level: LOG_DETAIL_PRIORITY,\n            message: attributeName + ' allocated ' + allocCount,\n            id: this.id\n          });\n          attribute.needsAlloc = false;\n          attribute.needsUpdate = true;\n        }\n      }\n\n      for (var _attributeName in attributes) {\n        var _attribute = attributes[_attributeName]; // Call updater function if needed\n\n        if (_attribute.needsUpdate) {\n          this._updateBuffer({\n            attribute: _attribute,\n            attributeName: _attributeName,\n            numInstances: numInstances,\n            data: data,\n            props: props,\n            context: context\n          });\n        }\n      }\n\n      this.allocedInstances = allocCount;\n    }\n  }, {\n    key: '_updateBuffer',\n    value: function _updateBuffer(_ref14) {\n      var attribute = _ref14.attribute,\n          attributeName = _ref14.attributeName,\n          numInstances = _ref14.numInstances,\n          data = _ref14.data,\n          props = _ref14.props,\n          context = _ref14.context;\n      var update = attribute.update,\n          accessor = attribute.accessor;\n      var timeStart = new Date();\n\n      if (update) {\n        // Custom updater - typically for non-instanced layers\n        update.call(context, attribute, {\n          data: data,\n          props: props,\n          numInstances: numInstances\n        });\n\n        this._checkAttributeArray(attribute, attributeName);\n      } else if (accessor) {\n        // Standard updater\n        this._updateBufferViaStandardAccessor({\n          attribute: attribute,\n          data: data,\n          props: props\n        });\n\n        this._checkAttributeArray(attribute, attributeName);\n      } else {\n        logFunctions.onUpdate({\n          level: LOG_DETAIL_PRIORITY,\n          message: attributeName + ' missing update function',\n          id: this.id\n        });\n      }\n\n      var timeMs = Math.round(new Date() - timeStart);\n      var time = timeMs + 'ms';\n      logFunctions.onUpdate({\n        level: LOG_DETAIL_PRIORITY,\n        message: attributeName + ' updated ' + numInstances + ' ' + time,\n        id: this.id\n      });\n      attribute.needsUpdate = false;\n      attribute.changed = true;\n      this.needsRedraw = true;\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: '_updateBufferViaStandardAccessor',\n    value: function _updateBufferViaStandardAccessor(_ref15) {\n      var attribute = _ref15.attribute,\n          data = _ref15.data,\n          props = _ref15.props;\n      var accessor = attribute.accessor,\n          value = attribute.value,\n          size = attribute.size;\n      var accessorFunc = props[accessor];\n      assert(typeof accessorFunc === 'function', 'accessor \"' + accessor + '\" is not a function');\n      var _attribute$defaultVal = attribute.defaultValue,\n          defaultValue = _attribute$defaultVal === undefined ? [0, 0, 0, 0] : _attribute$defaultVal;\n      defaultValue = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n      var i = 0;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = data[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n          var objectValue = accessorFunc(object);\n          objectValue = Array.isArray(objectValue) ? objectValue : [objectValue];\n          /* eslint-disable no-fallthrough, default-case */\n\n          switch (size) {\n            case 4:\n              value[i + 3] = Number.isFinite(objectValue[3]) ? objectValue[3] : defaultValue[3];\n\n            case 3:\n              value[i + 2] = Number.isFinite(objectValue[2]) ? objectValue[2] : defaultValue[2];\n\n            case 2:\n              value[i + 1] = Number.isFinite(objectValue[1]) ? objectValue[1] : defaultValue[1];\n\n            case 1:\n              value[i + 0] = Number.isFinite(objectValue[0]) ? objectValue[0] : defaultValue[0];\n          }\n\n          i += size;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_checkAttributeArray',\n    value: function _checkAttributeArray(attribute, attributeName) {\n      var value = attribute.value;\n\n      if (value && value.length >= 4) {\n        var valid = Number.isFinite(value[0]) && Number.isFinite(value[1]) && Number.isFinite(value[2]) && Number.isFinite(value[3]);\n\n        if (!valid) {\n          throw new Error('Illegal attribute generated for ' + attributeName);\n        }\n      }\n    }\n  }]);\n\n  return AttributeManager;\n}();\n\nexport default AttributeManager;","map":null,"metadata":{},"sourceType":"module"}