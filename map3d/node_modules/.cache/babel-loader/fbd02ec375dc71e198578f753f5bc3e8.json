{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\"; // WebGL2 Query (also handles disjoint timer extensions)\n\nimport Resource from './resource';\nimport { FEATURES, hasFeatures } from '../webgl-context/context-features';\nimport { isWebGL2 } from '../webgl-utils';\nimport queryManager from '../webgl-utils/query-manager';\nimport assert from '../utils/assert';\n\nvar noop = function noop(x) {\n  return x;\n};\n\nvar ERR_GPU_DISJOINT = 'Disjoint GPU operation invalidated timer queries';\nvar ERR_TIMER_QUERY_NOT_SUPPORTED = 'Timer queries require \"EXT_disjoint_timer_query\" extension';\nvar GL_QUERY_COUNTER_BITS_EXT = 0x8864; // # bits in query result for the given target.\n\nvar GL_QUERY_RESULT = 0x8866; // Returns a GLuint containing the query result.\n\nvar GL_QUERY_RESULT_AVAILABLE = 0x8867; // whether query result is available.\n\nvar GL_TIME_ELAPSED_EXT = 0x88BF; // Elapsed time (in nanoseconds).\n\nvar GL_TIMESTAMP_EXT = 0x8E28; // The current time.\n\nvar GL_GPU_DISJOINT_EXT = 0x8FBB; // Whether GPU performed any disjoint operation.\n\nvar GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88; // #primitives written to feedback buffers\n\nvar GL_ANY_SAMPLES_PASSED = 0x8C2F; // Occlusion query (if drawing passed depth test)\n\nvar GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A; // Occlusion query less accurate/faster version\n\nvar Query =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Query, _Resource);\n\n  _createClass(Query, null, [{\n    key: \"isSupported\",\n    // Returns true if Query is supported by the WebGL implementation\n    // Can also check whether timestamp queries are available.\n    value: function isSupported(gl) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var webgl2 = isWebGL2(gl); // Initial value\n\n      var hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);\n      var supported = webgl2 || hasTimerQuery;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = opts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          switch (key) {\n            case 'queries':\n              supported = supported && webgl2;\n              break;\n\n            case 'timers':\n              supported = supported && hasTimerQuery;\n              break;\n\n            case 'timestamps':\n              var queryCounterBits = hasTimerQuery ? gl.getQuery(GL_TIMESTAMP_EXT, GL_QUERY_COUNTER_BITS_EXT) : 0;\n              supported = supported && queryCounterBits > 0;\n              break;\n\n            default:\n              assert(false);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return supported;\n    } // Create a query class\n\n  }]);\n\n  function Query(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Query);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Query).call(this, gl, opts));\n    var _opts$onComplete = opts.onComplete,\n        onComplete = _opts$onComplete === void 0 ? noop : _opts$onComplete,\n        _opts$onError = opts.onError,\n        onError = _opts$onError === void 0 ? noop : _opts$onError;\n    _this.target = null;\n    _this.onComplete = onComplete;\n    _this.onError = onError; // query manager needs a promise field\n\n    _this.promise = null;\n    Object.seal(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  } // Shortcut for timer query (dependent on extension in both WebGL1 and 2)\n  // Measures GPU time delta between this call and a matching `end` call in the\n  // GPU instruction stream.\n\n\n  _createClass(Query, [{\n    key: \"beginTimeElapsedQuery\",\n    value: function beginTimeElapsedQuery() {\n      return this.begin(GL_TIME_ELAPSED_EXT);\n    } // Shortcut for occlusion queries\n\n  }, {\n    key: \"beginOcclusionQuery\",\n    value: function beginOcclusionQuery() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$conservative = _ref.conservative,\n          conservative = _ref$conservative === void 0 ? false : _ref$conservative;\n\n      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);\n    } // Shortcut for transformFeedbackQuery\n\n  }, {\n    key: \"beginTransformFeedbackQuery\",\n    value: function beginTransformFeedbackQuery() {\n      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n    } // Generates a GPU time stamp when the GPU instruction stream reaches this instruction.\n    // To measure time deltas, two timestamp queries are needed.\n    // Note: timestamp() queries may not be available even when the timer query extension is.\n\n  }, {\n    key: \"getTimestamp\",\n    value: function getTimestamp() {\n      queryManager.beginQuery(this, this.onComplete, this.onError);\n\n      try {\n        this.gl.queryCounter(this.handle, GL_TIMESTAMP_EXT);\n      } catch (error) {\n        queryManager.rejectQuery(this, ERR_TIMER_QUERY_NOT_SUPPORTED);\n      }\n\n      return this;\n    } // Due to OpenGL API limitations, after calling `begin()` on one Query\n    // instance, `end()` must be called on that same instance before\n    // calling `begin()` on another query. While there can be multiple\n    // outstanding queries representing disjoint `begin()`/`end()` intervals.\n    // It is not possible to interleave or overlap `begin` and `end` calls.\n\n  }, {\n    key: \"begin\",\n    value: function begin(target) {\n      // - Triggering a new query when a Query is already tracking an\n      //   unresolved query causes that query to be cancelled.\n      queryManager.beginQuery(this, this.onComplete, this.onError);\n      this.target = target;\n\n      try {\n        this.gl.beginQuery(this.target, this.handle);\n      } catch (error) {\n        queryManager.rejectQuery(this, 'Query not supported');\n      }\n\n      return this;\n    } // ends the current query\n\n  }, {\n    key: \"end\",\n    value: function end() {\n      // Note: calling end does not affect the pending promise\n      if (this.target) {\n        this.ext.endQuery(this.target);\n        this.target = null;\n      }\n\n      return this;\n    } // Cancels a pending query\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this.end();\n      queryManager.cancelQuery(this);\n      return this;\n    } // Returns true if the query result is available\n\n  }, {\n    key: \"isResultAvailable\",\n    value: function isResultAvailable() {\n      return this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);\n    } // Returns the query result, converted to milliseconds to match JavaScript conventions.\n    // TODO - what about non-timer queries\n\n  }, {\n    key: \"getResult\",\n    value: function getResult() {\n      var result = this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT);\n      return Number.isFinite(result) ? result / 1e6 : 0;\n    }\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return Query.isSupported(this.gl) ? this.gl.createQuery() : null;\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      queryManager.deleteQuery(this);\n      this.gl.deleteQuery(this.handle);\n    }\n  }], [{\n    key: \"poll\",\n    value: function poll(gl) {\n      queryManager.poll(gl);\n    }\n  }]);\n\n  return Query;\n}(Resource); // NOTE: This call lets the queryManager know how to detect disjoint GPU state\n// It will check dsjoint state on polls and before adding a new query\n// and reject any outstanding TimerQueries with our supplied error message.\n\n\nexport { Query as default };\nqueryManager.setInvalidator({\n  queryType: Query,\n  errorMessage: ERR_GPU_DISJOINT,\n  // Note: Querying the disjoint state resets it\n  checkInvalid: function checkInvalid(gl) {\n    return gl.getParameter(GL_GPU_DISJOINT_EXT);\n  }\n});","map":null,"metadata":{},"sourceType":"module"}