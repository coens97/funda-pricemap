{"ast":null,"code":"// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { experimental } from '@deck.gl/core';\nvar flattenVertices = experimental.flattenVertices;\nimport earcut from 'earcut'; // Basic polygon support\n//\n// Handles simple and complex polygons\n// Simple polygons are arrays of vertices, implicitly \"closed\"\n// Complex polygons are arrays of simple polygons, with the first polygon\n// representing the outer hull and other polygons representing holes\n\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\n\nexport function isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n/**\n * Ensure that all simple polygons have the same start and end vertex\n */\n\nfunction closeLoop(simplePolygon) {\n  // check if first and last vertex are the same\n  var p0 = simplePolygon[0];\n  var p1 = simplePolygon[simplePolygon.length - 1];\n\n  if (p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2]) {\n    return simplePolygon;\n  } // duplicate the starting vertex at end\n\n\n  return simplePolygon.concat([p0]);\n}\n/**\n * Normalize to ensure that all polygons in a list are complex - simplifies processing\n * @param {Array} polygon - either a complex or a simple polygon\n * @param {Object} opts\n * @param {Object} opts.dimensions - if 3, the coords will be padded with 0's if needed\n * @return {Array} - returns a complex polygons\n */\n\n\nexport function normalize(polygon) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$dimensions = _ref.dimensions,\n      dimensions = _ref$dimensions === void 0 ? 3 : _ref$dimensions;\n\n  return isSimple(polygon) ? [closeLoop(polygon)] : polygon.map(closeLoop);\n}\n/**\n * Check if this is a non-nested polygon (i.e. the first element of the first element is a number)\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\n\nexport function getVertexCount(polygon) {\n  return isSimple(polygon) ? polygon.length : polygon.reduce(function (length, simplePolygon) {\n    return length + simplePolygon.length;\n  }, 0);\n} // Return number of triangles needed to tesselate the polygon\n\nexport function getTriangleCount(polygon) {\n  var triangleCount = 0;\n  var first = true;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = normalize(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var simplePolygon = _step.value;\n      var size = simplePolygon.length;\n\n      if (first) {\n        triangleCount += size >= 3 ? size - 2 : 0;\n      } else {\n        triangleCount += size + 1;\n      }\n\n      first = false;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return triangleCount;\n} // Returns the offset of each hole polygon in the flattened array for that polygon\n\nfunction getHoleIndices(complexPolygon) {\n  var holeIndices = null;\n\n  if (complexPolygon.length > 1) {\n    var polygonStartIndex = 0;\n    holeIndices = [];\n    complexPolygon.forEach(function (polygon) {\n      polygonStartIndex += polygon.length;\n      holeIndices.push(polygonStartIndex);\n    }); // Last element points to end of the flat array, remove it\n\n    holeIndices.pop();\n  }\n\n  return holeIndices;\n}\n/*\n * Get vertex indices for drawing complexPolygon mesh\n * @private\n * @param {[Number,Number,Number][][]} complexPolygon\n * @returns {[Number]} indices\n */\n\n\nexport function getSurfaceIndices(complexPolygon) {\n  // Prepare an array of hole indices as expected by earcut\n  var holeIndices = getHoleIndices(complexPolygon); // Flatten the polygon as expected by earcut\n\n  var verts = flattenVertices(complexPolygon, {\n    dimensions: 2,\n    result: []\n  }); // Let earcut triangulate the polygon\n\n  return earcut(verts, holeIndices, 2);\n}","map":null,"metadata":{},"sourceType":"module"}