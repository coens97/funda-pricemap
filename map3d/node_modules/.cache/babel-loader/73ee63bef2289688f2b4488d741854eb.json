{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nimport { log } from './utils';\nimport assert from 'assert';\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n\n/* eslint-disable max-statements, complexity */\n\nexport function compareProps() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      oldProps = _ref.oldProps,\n      newProps = _ref.newProps,\n      _ref$ignoreProps = _ref.ignoreProps,\n      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps,\n      _ref$triggerName = _ref.triggerName,\n      triggerName = _ref$triggerName === undefined ? 'props' : _ref$triggerName;\n\n  assert(oldProps !== undefined && newProps !== undefined, 'compareProps args'); // shallow equality => deep equality\n\n  if (oldProps === newProps) {\n    return null;\n  }\n\n  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {\n    return triggerName + ' changed shallowly';\n  }\n\n  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {\n    return triggerName + ' changed shallowly';\n  } // Test if new props different from old props\n\n\n  for (var key in oldProps) {\n    if (!(key in ignoreProps)) {\n      if (!newProps.hasOwnProperty(key)) {\n        return triggerName + ' ' + key + ' dropped: ' + oldProps[key] + ' -> (undefined)';\n      }\n\n      var equals = newProps[key] && oldProps[key] && newProps[key].equals;\n\n      if (equals && !equals.call(newProps[key], oldProps[key])) {\n        return triggerName + ' ' + key + ' changed deeply: ' + oldProps[key] + ' -> ' + newProps[key];\n      }\n\n      if (!equals && oldProps[key] !== newProps[key]) {\n        return triggerName + ' ' + key + ' changed shallowly: ' + oldProps[key] + ' -> ' + newProps[key];\n      }\n    }\n  } // Test if any new props have been added\n\n\n  for (var _key in newProps) {\n    if (!(_key in ignoreProps)) {\n      if (!oldProps.hasOwnProperty(_key)) {\n        return triggerName + ' ' + _key + ' added: (undefined) -> ' + newProps[_key];\n      }\n    }\n  }\n\n  return null;\n}\n/* eslint-enable max-statements, complexity */\n// HELPERS\n// Constructors have their super class constructors as prototypes\n\nfunction getOwnProperty(object, prop) {\n  return object.hasOwnProperty(prop) && object[prop];\n}\n/*\n * Return merged default props stored on layers constructor, create them if needed\n */\n\n\nexport function getDefaultProps(layer) {\n  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');\n\n  if (mergedDefaultProps) {\n    return mergedDefaultProps;\n  }\n\n  return mergeDefaultProps(layer);\n}\n/*\n * Walk a prototype chain and merge all default props from any 'defaultProps' objects\n */\n\nexport function mergeDefaultProps(object) {\n  var objectNameKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'layerName';\n  var subClassConstructor = object.constructor;\n  var objectName = getOwnProperty(subClassConstructor, objectNameKey);\n\n  if (!objectName) {\n    log.once(0, object.constructor.name + ' does not specify a ' + objectNameKey);\n  } // Use the object's constructor name as default id prop.\n  // Note that constructor names are substituted during minification and may not be \"human readable\"\n\n\n  var mergedDefaultProps = {\n    id: objectName || object.constructor.name\n  }; // Reverse shadowing\n  // TODO - Rewrite to stop when mergedDefaultProps is available on parent?\n\n  while (object) {\n    var objectDefaultProps = getOwnProperty(object.constructor, 'defaultProps');\n    Object.freeze(objectDefaultProps);\n\n    if (objectDefaultProps) {\n      mergedDefaultProps = Object.assign({}, objectDefaultProps, mergedDefaultProps);\n    }\n\n    object = Object.getPrototypeOf(object);\n  }\n\n  Object.freeze(mergedDefaultProps); // Store for quick lookup\n\n  subClassConstructor.mergedDefaultProps = mergedDefaultProps;\n  assert(mergeDefaultProps);\n  return mergedDefaultProps;\n}","map":null,"metadata":{},"sourceType":"module"}