{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // WebGL2 Query (also handles disjoint timer extensions)\n\n\nimport Resource from './resource';\nimport queryManager from './helpers/query-manager';\nimport { FEATURES, hasFeatures } from './context-features';\nimport { isWebGL2 } from './context';\nimport { polyfillContext } from '../webgl-utils';\n\nvar noop = function noop(x) {\n  return x;\n};\n\nvar ERR_GPU_DISJOINT = 'Disjoint GPU operation invalidated timer queries';\nvar ERR_TIMER_QUERY_NOT_SUPPORTED = 'Timer queries require \"EXT_disjoint_timer_query\" extension';\nvar GL_QUERY_COUNTER_BITS_EXT = 0x8864; // # bits in query result for the given target.\n\nvar GL_QUERY_RESULT = 0x8866; // Returns a GLuint containing the query result.\n\nvar GL_QUERY_RESULT_AVAILABLE = 0x8867; // whether query result is available.\n\nvar GL_TIME_ELAPSED_EXT = 0x88BF; // Elapsed time (in nanoseconds).\n\nvar GL_TIMESTAMP_EXT = 0x8E28; // The current time.\n\nvar GL_GPU_DISJOINT_EXT = 0x8FBB; // Whether GPU performed any disjoint operation.\n\nvar GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8C88; // #primitives written to feedback buffers\n\nvar GL_ANY_SAMPLES_PASSED = 0x8C2F; // Occlusion query (if drawing passed depth test)\n\nvar GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A; // Occlusion query less accurate/faster version\n\nvar Query =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Query, _Resource);\n\n  _createClass(Query, null, [{\n    key: 'isSupported',\n    // Returns true if Query is supported by the WebGL implementation\n    // Can also check whether timestamp queries are available.\n    value: function isSupported(gl) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$queries = _ref.queries,\n          queries = _ref$queries === undefined ? false : _ref$queries,\n          _ref$timers = _ref.timers,\n          timers = _ref$timers === undefined ? false : _ref$timers,\n          _ref$timestamps = _ref.timestamps,\n          timestamps = _ref$timestamps === undefined ? false : _ref$timestamps;\n\n      var webgl2 = isWebGL2(gl);\n      var hasTimerQueries = hasFeatures(gl, FEATURES.TIMER_QUERY);\n      var supported = webgl2 || hasTimerQueries;\n\n      if (queries) {\n        supported = supported && webgl2;\n      }\n\n      if (timers) {\n        supported = supported && hasTimerQueries;\n      }\n\n      if (timestamps) {\n        polyfillContext(gl);\n        var queryCounterBits = gl.getQuery(GL_TIMESTAMP_EXT, GL_QUERY_COUNTER_BITS_EXT);\n        supported = supported && queryCounterBits > 0;\n      }\n\n      return supported;\n    } // Create a query class\n\n  }]);\n\n  function Query(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Query);\n\n    var _this = _possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).call(this, gl, opts));\n\n    var _opts$onComplete = opts.onComplete,\n        onComplete = _opts$onComplete === undefined ? noop : _opts$onComplete,\n        _opts$onError = opts.onError,\n        onError = _opts$onError === undefined ? noop : _opts$onError;\n    _this.target = null;\n    _this.onComplete = onComplete;\n    _this.onError = onError; // query manager needs a promise field\n\n    _this.promise = null;\n    Object.seal(_this);\n    return _this;\n  } // Shortcut for timer query (dependent on extension in both WebGL1 and 2)\n  // Measures GPU time delta between this call and a matching `end` call in the\n  // GPU instruction stream.\n\n\n  _createClass(Query, [{\n    key: 'beginTimeElapsedQuery',\n    value: function beginTimeElapsedQuery() {\n      return this.begin(GL_TIME_ELAPSED_EXT);\n    } // Shortcut for occlusion queries\n\n  }, {\n    key: 'beginOcclusionQuery',\n    value: function beginOcclusionQuery() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$conservative = _ref2.conservative,\n          conservative = _ref2$conservative === undefined ? false : _ref2$conservative;\n\n      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);\n    } // Shortcut for transformFeedbackQuery\n\n  }, {\n    key: 'beginTransformFeedbackQuery',\n    value: function beginTransformFeedbackQuery() {\n      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);\n    } // Generates a GPU time stamp when the GPU instruction stream reaches this instruction.\n    // To measure time deltas, two timestamp queries are needed.\n    // Note: timestamp() queries may not be available even when the timer query extension is.\n\n  }, {\n    key: 'getTimestamp',\n    value: function getTimestamp() {\n      queryManager.beginQuery(this, this.onComplete, this.onError);\n\n      try {\n        this.gl.queryCounter(this.handle, GL_TIMESTAMP_EXT);\n      } catch (error) {\n        queryManager.rejectQuery(this, ERR_TIMER_QUERY_NOT_SUPPORTED);\n      }\n\n      return this;\n    } // Due to OpenGL API limitations, after calling `begin()` on one Query\n    // instance, `end()` must be called on that same instance before\n    // calling `begin()` on another query. While there can be multiple\n    // outstanding queries representing disjoint `begin()`/`end()` intervals.\n    // It is not possible to interleave or overlap `begin` and `end` calls.\n\n  }, {\n    key: 'begin',\n    value: function begin(target) {\n      // - Triggering a new query when a Query is already tracking an\n      //   unresolved query causes that query to be cancelled.\n      queryManager.beginQuery(this, this.onComplete, this.onError);\n      this.target = target;\n\n      try {\n        this.gl.beginQuery(this.target, this.handle);\n      } catch (error) {\n        queryManager.rejectQuery(this, 'Query not supported');\n      }\n\n      return this;\n    } // ends the current query\n\n  }, {\n    key: 'end',\n    value: function end() {\n      // Note: calling end does not affect the pending promise\n      if (this.target) {\n        this.ext.endQuery(this.target);\n        this.target = null;\n      }\n\n      return this;\n    } // Cancels a pending query\n\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      this.end();\n      queryManager.cancelQuery(this);\n      return this;\n    } // Returns true if the query result is available\n\n  }, {\n    key: 'isResultAvailable',\n    value: function isResultAvailable() {\n      return this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);\n    } // Returns the query result, converted to milliseconds to match JavaScript conventions.\n    // TODO - what about non-timer queries\n\n  }, {\n    key: 'getResult',\n    value: function getResult() {\n      var result = this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT);\n      return Number.isFinite(result) ? result / 1e6 : 0;\n    }\n  }, {\n    key: '_createHandle',\n    value: function _createHandle() {\n      return Query.isSupported(this.gl) ? this.gl.createQuery() : null;\n    }\n  }, {\n    key: '_deleteHandle',\n    value: function _deleteHandle() {\n      queryManager.deleteQuery(this);\n      this.gl.deleteQuery(this.handle);\n    }\n  }], [{\n    key: 'poll',\n    value: function poll(gl) {\n      queryManager.poll(gl);\n    }\n  }]);\n\n  return Query;\n}(Resource); // NOTE: This call lets the queryManager know how to detect disjoint GPU state\n// It will check dsjoint state on polls and before adding a new query\n// and reject any outstanding TimerQueries with our supplied error message.\n\n\nexport default Query;\nqueryManager.setInvalidator({\n  queryType: Query,\n  errorMessage: ERR_GPU_DISJOINT,\n  // Note: Querying the disjoint state resets it\n  checkInvalid: function checkInvalid(gl) {\n    return gl.getParameter(GL_GPU_DISJOINT_EXT);\n  }\n});","map":null,"metadata":{},"sourceType":"module"}