{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MAPBOX_LIMITS = undefined;\n\nvar _log = require('babel-runtime/core-js/math/log2');\n\nvar _log2 = _interopRequireDefault(_log);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _isFinite = require('babel-runtime/core-js/number/is-finite');\n\nvar _isFinite2 = _interopRequireDefault(_isFinite);\n\nvar _viewportMercatorProject = require('viewport-mercator-project');\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // MAPBOX LIMITS\n\n\nvar MAPBOX_LIMITS = exports.MAPBOX_LIMITS = {\n  minZoom: 0,\n  maxZoom: 20,\n  minPitch: 0,\n  maxPitch: 60,\n  // defined by mapbox-gl\n  maxLatitude: 85.05113,\n  minLatitude: -85.05113\n};\nvar defaultState = {\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\n/* Utils */\n\nfunction mod(value, divisor) {\n  var modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\nfunction ensureFinite(value, fallbackValue) {\n  return (0, _isFinite2.default)(value) ? value : fallbackValue;\n}\n\nvar MapState = function () {\n  function MapState() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        width = _ref.width,\n        height = _ref.height,\n        latitude = _ref.latitude,\n        longitude = _ref.longitude,\n        zoom = _ref.zoom,\n        bearing = _ref.bearing,\n        pitch = _ref.pitch,\n        altitude = _ref.altitude,\n        maxZoom = _ref.maxZoom,\n        minZoom = _ref.minZoom,\n        maxPitch = _ref.maxPitch,\n        minPitch = _ref.minPitch,\n        maxLatitude = _ref.maxLatitude,\n        minLatitude = _ref.minLatitude,\n        startPanLngLat = _ref.startPanLngLat,\n        startZoomLngLat = _ref.startZoomLngLat,\n        startBearing = _ref.startBearing,\n        startPitch = _ref.startPitch,\n        startZoom = _ref.startZoom;\n\n    (0, _classCallCheck3.default)(this, MapState);\n    (0, _assert2.default)((0, _isFinite2.default)(width), '`width` must be supplied');\n    (0, _assert2.default)((0, _isFinite2.default)(height), '`height` must be supplied');\n    (0, _assert2.default)((0, _isFinite2.default)(longitude), '`longitude` must be supplied');\n    (0, _assert2.default)((0, _isFinite2.default)(latitude), '`latitude` must be supplied');\n    (0, _assert2.default)((0, _isFinite2.default)(zoom), '`zoom` must be supplied');\n    this._viewportProps = this._applyConstraints({\n      width: width,\n      height: height,\n      latitude: latitude,\n      longitude: longitude,\n      zoom: zoom,\n      bearing: ensureFinite(bearing, defaultState.bearing),\n      pitch: ensureFinite(pitch, defaultState.pitch),\n      altitude: ensureFinite(altitude, defaultState.altitude),\n      maxZoom: ensureFinite(maxZoom, MAPBOX_LIMITS.maxZoom),\n      minZoom: ensureFinite(minZoom, MAPBOX_LIMITS.minZoom),\n      maxPitch: ensureFinite(maxPitch, MAPBOX_LIMITS.maxPitch),\n      minPitch: ensureFinite(minPitch, MAPBOX_LIMITS.minPitch),\n      maxLatitude: ensureFinite(maxLatitude, MAPBOX_LIMITS.maxLatitude),\n      minLatitude: ensureFinite(minLatitude, MAPBOX_LIMITS.minLatitude)\n    });\n    this._interactiveState = {\n      startPanLngLat: startPanLngLat,\n      startZoomLngLat: startZoomLngLat,\n      startBearing: startBearing,\n      startPitch: startPitch,\n      startZoom: startZoom\n    };\n  }\n  /* Public API */\n\n\n  (0, _createClass3.default)(MapState, [{\n    key: 'getViewportProps',\n    value: function getViewportProps() {\n      return this._viewportProps;\n    }\n  }, {\n    key: 'getInteractiveState',\n    value: function getInteractiveState() {\n      return this._interactiveState;\n    }\n    /**\n     * Start panning\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n\n  }, {\n    key: 'panStart',\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      return this._getUpdatedMapState({\n        startPanLngLat: this._unproject(pos)\n      });\n    }\n    /**\n     * Pan\n     * @param {[Number, Number]} pos - position on screen where the pointer is\n     * @param {[Number, Number], optional} startPos - where the pointer grabbed at\n     *   the start of the operation. Must be supplied of `panStart()` was not called\n     */\n\n  }, {\n    key: 'pan',\n    value: function pan(_ref3) {\n      var pos = _ref3.pos,\n          startPos = _ref3.startPos;\n\n      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos); // take the start lnglat and put it where the mouse is down.\n\n\n      (0, _assert2.default)(startPanLngLat, '`startPanLngLat` prop is required ' + 'for mouse pan behavior to calculate where to position the map.');\n\n      var _calculateNewLngLat2 = this._calculateNewLngLat({\n        startPanLngLat: startPanLngLat,\n        pos: pos\n      }),\n          _calculateNewLngLat3 = (0, _slicedToArray3.default)(_calculateNewLngLat2, 2),\n          longitude = _calculateNewLngLat3[0],\n          latitude = _calculateNewLngLat3[1];\n\n      return this._getUpdatedMapState({\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n    /**\n     * End panning\n     * Must call if `panStart()` was called\n     */\n\n  }, {\n    key: 'panEnd',\n    value: function panEnd() {\n      return this._getUpdatedMapState({\n        startPanLngLat: null\n      });\n    }\n    /**\n     * Start rotating\n     * @param {[Number, Number]} pos - position on screen where the center is\n     */\n\n  }, {\n    key: 'rotateStart',\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos;\n      return this._getUpdatedMapState({\n        startBearing: this._viewportProps.bearing,\n        startPitch: this._viewportProps.pitch\n      });\n    }\n    /**\n     * Rotate\n     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the\n     *   change to bearing.\n     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the\n     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.\n     */\n\n  }, {\n    key: 'rotate',\n    value: function rotate(_ref5) {\n      var deltaScaleX = _ref5.deltaScaleX,\n          deltaScaleY = _ref5.deltaScaleY;\n      (0, _assert2.default)(deltaScaleX >= -1 && deltaScaleX <= 1, '`deltaScaleX` must be a number between [-1, 1]');\n      (0, _assert2.default)(deltaScaleY >= -1 && deltaScaleY <= 1, '`deltaScaleY` must be a number between [-1, 1]');\n      var _interactiveState = this._interactiveState,\n          startBearing = _interactiveState.startBearing,\n          startPitch = _interactiveState.startPitch;\n\n      if (!(0, _isFinite2.default)(startBearing)) {\n        startBearing = this._viewportProps.bearing;\n      }\n\n      if (!(0, _isFinite2.default)(startPitch)) {\n        startPitch = this._viewportProps.pitch;\n      }\n\n      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY,\n        startBearing: startBearing,\n        startPitch: startPitch\n      }),\n          pitch = _calculateNewPitchAnd.pitch,\n          bearing = _calculateNewPitchAnd.bearing;\n\n      return this._getUpdatedMapState({\n        bearing: bearing,\n        pitch: pitch\n      });\n    }\n    /**\n     * End rotating\n     * Must call if `rotateStart()` was called\n     */\n\n  }, {\n    key: 'rotateEnd',\n    value: function rotateEnd() {\n      return this._getUpdatedMapState({\n        startBearing: null,\n        startPitch: null\n      });\n    }\n    /**\n     * Start zooming\n     * @param {[Number, Number]} pos - position on screen where the center is\n     */\n\n  }, {\n    key: 'zoomStart',\n    value: function zoomStart(_ref6) {\n      var pos = _ref6.pos;\n      return this._getUpdatedMapState({\n        startZoomLngLat: this._unproject(pos),\n        startZoom: this._viewportProps.zoom\n      });\n    }\n    /**\n     * Zoom\n     * @param {[Number, Number]} pos - position on screen where the current center is\n     * @param {[Number, Number]} startPos - the center position at\n     *   the start of the operation. Must be supplied of `zoomStart()` was not called\n     * @param {Number} scale - a number between [0, 1] specifying the accumulated\n     *   relative scale.\n     */\n\n  }, {\n    key: 'zoom',\n    value: function zoom(_ref7) {\n      var pos = _ref7.pos,\n          startPos = _ref7.startPos,\n          scale = _ref7.scale;\n      (0, _assert2.default)(scale > 0, '`scale` must be a positive number'); // Make sure we zoom around the current mouse position rather than map center\n\n      var startZoomLngLat = this._interactiveState.startZoomLngLat || this._unproject(startPos) || this._unproject(pos);\n\n      var startZoom = this._interactiveState.startZoom;\n\n      if (!(0, _isFinite2.default)(startZoom)) {\n        startZoom = this._viewportProps.zoom;\n      } // take the start lnglat and put it where the mouse is down.\n\n\n      (0, _assert2.default)(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');\n\n      var zoom = this._calculateNewZoom({\n        scale: scale,\n        startZoom: startZoom\n      });\n\n      var zoomedViewport = new _viewportMercatorProject.PerspectiveMercatorViewport((0, _assign2.default)({}, this._viewportProps, {\n        zoom: zoom\n      }));\n\n      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({\n        lngLat: startZoomLngLat,\n        pos: pos\n      }),\n          _zoomedViewport$getLo2 = (0, _slicedToArray3.default)(_zoomedViewport$getLo, 2),\n          longitude = _zoomedViewport$getLo2[0],\n          latitude = _zoomedViewport$getLo2[1];\n\n      return this._getUpdatedMapState({\n        zoom: zoom,\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n    /**\n     * End zooming\n     * Must call if `zoomStart()` was called\n     */\n\n  }, {\n    key: 'zoomEnd',\n    value: function zoomEnd() {\n      return this._getUpdatedMapState({\n        startZoomLngLat: null,\n        startZoom: null\n      });\n    }\n    /* Private methods */\n\n  }, {\n    key: '_getUpdatedMapState',\n    value: function _getUpdatedMapState(newProps) {\n      // Update _viewportProps\n      return new MapState((0, _assign2.default)({}, this._viewportProps, this._interactiveState, newProps));\n    } // Apply any constraints (mathematical or defined by _viewportProps) to map state\n\n  }, {\n    key: '_applyConstraints',\n    value: function _applyConstraints(props) {\n      // Normalize degrees\n      props.longitude = mod(props.longitude + 180, 360) - 180;\n      props.bearing = mod(props.bearing + 180, 360) - 180; // Ensure zoom is within specified range\n\n      var maxZoom = props.maxZoom,\n          minZoom = props.minZoom,\n          zoom = props.zoom;\n      props.zoom = zoom > maxZoom ? maxZoom : zoom;\n      props.zoom = zoom < minZoom ? minZoom : zoom; // Ensure pitch is within specified range\n\n      var maxPitch = props.maxPitch,\n          minPitch = props.minPitch,\n          pitch = props.pitch;\n      props.pitch = pitch > maxPitch ? maxPitch : pitch;\n      props.pitch = pitch < minPitch ? minPitch : pitch; // Constrain zoom and shift center at low zoom levels\n\n      var height = props.height;\n\n      var _getLatitudeRange2 = this._getLatitudeRange(props),\n          _getLatitudeRange2$la = (0, _slicedToArray3.default)(_getLatitudeRange2.latitudeRange, 2),\n          topY = _getLatitudeRange2$la[0],\n          bottomY = _getLatitudeRange2$la[1],\n          viewport = _getLatitudeRange2.viewport;\n\n      var shiftY = 0;\n\n      if (bottomY - topY < height) {\n        // Map height must not be smaller than viewport height\n        props.zoom += (0, _log2.default)(height / (bottomY - topY));\n\n        var newRange = this._getLatitudeRange(props);\n\n        var _newRange$latitudeRan = (0, _slicedToArray3.default)(newRange.latitudeRange, 2);\n\n        topY = _newRange$latitudeRan[0];\n        bottomY = _newRange$latitudeRan[1];\n        viewport = newRange.viewport;\n      }\n\n      if (topY > 0) {\n        // Compensate for white gap on top\n        shiftY = topY;\n      } else if (bottomY < height) {\n        // Compensate for white gap on bottom\n        shiftY = bottomY - height;\n      }\n\n      if (shiftY) {\n        props.latitude = viewport.unproject([props.width / 2, height / 2 + shiftY])[1];\n      }\n\n      return props;\n    } // Returns {viewport, latitudeRange: [topY, bottomY]} in non-perspective mode\n\n  }, {\n    key: '_getLatitudeRange',\n    value: function _getLatitudeRange(props) {\n      var flatViewport = new _viewportMercatorProject.PerspectiveMercatorViewport((0, _assign2.default)({}, props, {\n        pitch: 0,\n        bearing: 0\n      }));\n      return {\n        viewport: flatViewport,\n        latitudeRange: [flatViewport.project([props.longitude, props.maxLatitude])[1], flatViewport.project([props.longitude, props.minLatitude])[1]]\n      };\n    }\n  }, {\n    key: '_unproject',\n    value: function _unproject(pos) {\n      var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(this._viewportProps);\n      return pos && viewport.unproject(pos, {\n        topLeft: false\n      });\n    } // Calculate a new lnglat based on pixel dragging position\n\n  }, {\n    key: '_calculateNewLngLat',\n    value: function _calculateNewLngLat(_ref8) {\n      var startPanLngLat = _ref8.startPanLngLat,\n          pos = _ref8.pos;\n      var viewport = new _viewportMercatorProject.PerspectiveMercatorViewport(this._viewportProps);\n      return viewport.getLocationAtPoint({\n        lngLat: startPanLngLat,\n        pos: pos\n      });\n    } // Calculates new zoom\n\n  }, {\n    key: '_calculateNewZoom',\n    value: function _calculateNewZoom(_ref9) {\n      var scale = _ref9.scale,\n          startZoom = _ref9.startZoom;\n      var _viewportProps = this._viewportProps,\n          maxZoom = _viewportProps.maxZoom,\n          minZoom = _viewportProps.minZoom;\n      var zoom = startZoom + (0, _log2.default)(scale);\n      zoom = zoom > maxZoom ? maxZoom : zoom;\n      zoom = zoom < minZoom ? minZoom : zoom;\n      return zoom;\n    } // Calculates a new pitch and bearing from a position (coming from an event)\n\n  }, {\n    key: '_calculateNewPitchAndBearing',\n    value: function _calculateNewPitchAndBearing(_ref10) {\n      var deltaScaleX = _ref10.deltaScaleX,\n          deltaScaleY = _ref10.deltaScaleY,\n          startBearing = _ref10.startBearing,\n          startPitch = _ref10.startPitch;\n      var _viewportProps2 = this._viewportProps,\n          minPitch = _viewportProps2.minPitch,\n          maxPitch = _viewportProps2.maxPitch;\n      var bearing = startBearing + 180 * deltaScaleX;\n      var pitch = startPitch;\n\n      if (deltaScaleY > 0) {\n        // Gradually increase pitch\n        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n      } else if (deltaScaleY < 0) {\n        // Gradually decrease pitch\n        pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n      }\n\n      return {\n        pitch: pitch,\n        bearing: bearing\n      };\n    }\n  }]);\n  return MapState;\n}();\n\nexports.default = MapState;","map":null,"metadata":{},"sourceType":"script"}