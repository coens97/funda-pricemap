{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable guard-for-in */\n\n\nimport Attribute from './attribute';\nimport log from '../utils/log';\nimport AttributeTransitionManager from './attribute-transition-manager';\nvar LOG_START_END_PRIORITY = 2;\nvar LOG_DETAIL_PRIORITY = 3;\n\nfunction noop() {} // Default loggers\n\n\nvar logFunctions = {\n  savedMessages: null,\n  timeStart: null,\n  onLog: function onLog(_ref) {\n    var level = _ref.level,\n        message = _ref.message;\n    log.log(level, message)();\n  },\n  onUpdateStart: function onUpdateStart(_ref2) {\n    var level = _ref2.level,\n        numInstances = _ref2.numInstances;\n    logFunctions.savedMessages = [];\n    logFunctions.timeStart = new Date();\n  },\n  onUpdate: function onUpdate(_ref3) {\n    var level = _ref3.level,\n        message = _ref3.message;\n\n    if (logFunctions.savedMessages) {\n      logFunctions.savedMessages.push(message);\n    }\n  },\n  onUpdateEnd: function onUpdateEnd(_ref4) {\n    var level = _ref4.level,\n        id = _ref4.id,\n        numInstances = _ref4.numInstances;\n    var timeMs = Math.round(new Date() - logFunctions.timeStart);\n    var time = \"\".concat(timeMs, \"ms\");\n    log.group(level, \"Updated attributes for \".concat(numInstances, \" instances in \").concat(id, \" in \").concat(time), {\n      collapsed: true\n    })();\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = logFunctions.savedMessages[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var message = _step.value;\n        log.log(level, message)();\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    log.groupEnd(level, \"Updated attributes for \".concat(numInstances, \" instances in \").concat(id, \" in \").concat(time))();\n    logFunctions.savedMessages = null;\n  }\n};\n\nvar AttributeManager =\n/*#__PURE__*/\nfunction () {\n  _createClass(AttributeManager, null, [{\n    key: \"setDefaultLogFunctions\",\n\n    /**\n     * Sets log functions to help trace or time attribute updates.\n     * Default logging uses deck logger.\n     *\n     * `onLog` is called for each attribute.\n     *\n     * To enable detailed control of timming and e.g. hierarchical logging,\n     * hooks are also provided for update start and end.\n     *\n     * @param {Object} [opts]\n     * @param {String} [onLog=] - called to print\n     * @param {String} [onUpdateStart=] - called before update() starts\n     * @param {String} [onUpdateEnd=] - called after update() ends\n     */\n    value: function setDefaultLogFunctions() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          onLog = _ref5.onLog,\n          onUpdateStart = _ref5.onUpdateStart,\n          onUpdate = _ref5.onUpdate,\n          onUpdateEnd = _ref5.onUpdateEnd;\n\n      if (onLog !== undefined) {\n        logFunctions.onLog = onLog || noop;\n      }\n\n      if (onUpdateStart !== undefined) {\n        logFunctions.onUpdateStart = onUpdateStart || noop;\n      }\n\n      if (onUpdate !== undefined) {\n        logFunctions.onUpdate = onUpdate || noop;\n      }\n\n      if (onUpdateEnd !== undefined) {\n        logFunctions.onUpdateEnd = onUpdateEnd || noop;\n      }\n    }\n    /**\n     * @classdesc\n     * Automated attribute generation and management. Suitable when a set of\n     * vertex shader attributes are generated by iteration over a data array,\n     * and updates to these attributes are needed either when the data itself\n     * changes, or when other data relevant to the calculations change.\n     *\n     * - First the application registers descriptions of its dynamic vertex\n     *   attributes using AttributeManager.add().\n     * - Then, when any change that affects attributes is detected by the\n     *   application, the app will call AttributeManager.invalidate().\n     * - Finally before it renders, it calls AttributeManager.update() to\n     *   ensure that attributes are automatically rebuilt if anything has been\n     *   invalidated.\n     *\n     * The application provided update functions describe how attributes\n     * should be updated from a data array and are expected to traverse\n     * that data array (or iterable) and fill in the attribute's typed array.\n     *\n     * Note that the attribute manager intentionally does not do advanced\n     * change detection, but instead makes it easy to build such detection\n     * by offering the ability to \"invalidate\" each attribute separately.\n     */\n\n  }]);\n\n  function AttributeManager(gl) {\n    var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref6$id = _ref6.id,\n        id = _ref6$id === void 0 ? 'attribute-manager' : _ref6$id,\n        stats = _ref6.stats;\n\n    _classCallCheck(this, AttributeManager);\n\n    this.id = id;\n    this.gl = gl;\n    this.attributes = {};\n    this.updateTriggers = {};\n    this.accessors = {};\n    this.needsRedraw = true;\n    this.userData = {};\n    this.stats = stats;\n    this.attributeTransitionManager = new AttributeTransitionManager(gl, {\n      id: \"\".concat(id, \"-transitions\")\n    }); // For debugging sanity, prevent uninitialized members\n\n    Object.seal(this);\n  }\n\n  _createClass(AttributeManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].delete();\n      }\n\n      this.attributeTransitionManager.finalize();\n    } // Returns the redraw flag, optionally clearing it.\n    // Redraw flag will be set if any attributes attributes changed since\n    // flag was last cleared.\n    //\n    // @param {String} [clearRedrawFlags=false] - whether to clear the flag\n    // @return {false|String} - reason a redraw is needed.\n\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref7$clearRedrawFlag = _ref7.clearRedrawFlags,\n          clearRedrawFlags = _ref7$clearRedrawFlag === void 0 ? false : _ref7$clearRedrawFlag;\n\n      var redraw = this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n      return redraw && this.id;\n    } // Sets the redraw flag.\n    // @param {Boolean} redraw=true\n    // @return {AttributeManager} - for chaining\n\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = true;\n      return this;\n    } // Adds attributes\n\n  }, {\n    key: \"add\",\n    value: function add(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._add(attributes, updaters);\n    } // Adds attributes\n\n  }, {\n    key: \"addInstanced\",\n    value: function addInstanced(attributes) {\n      var updaters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._add(attributes, updaters, {\n        instanced: 1\n      });\n    }\n    /**\n     * Removes attributes\n     * Takes an array of attribute names and delete them from\n     * the attribute map if they exists\n     *\n     * @example\n     * attributeManager.remove(['position']);\n     *\n     * @param {Object} attributeNameArray - attribute name array (see above)\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(attributeNameArray) {\n      for (var i = 0; i < attributeNameArray.length; i++) {\n        var name = attributeNameArray[i];\n\n        if (this.attributes[name] !== undefined) {\n          this.attributes[name].delete();\n          delete this.attributes[name];\n        }\n      }\n    } // Marks an attribute for update\n\n  }, {\n    key: \"invalidate\",\n    value: function invalidate(triggerName) {\n      var invalidatedAttributes = this._invalidateTrigger(triggerName); // For performance tuning\n\n\n      logFunctions.onLog({\n        level: LOG_DETAIL_PRIORITY,\n        message: \"invalidated attributes \".concat(invalidatedAttributes, \" (\").concat(triggerName, \") for \").concat(this.id)\n      });\n    }\n  }, {\n    key: \"invalidateAll\",\n    value: function invalidateAll() {\n      for (var attributeName in this.attributes) {\n        this.attributes[attributeName].setNeedsUpdate();\n      } // For performance tuning\n\n\n      logFunctions.onLog({\n        level: LOG_DETAIL_PRIORITY,\n        message: \"invalidated all attributes for \".concat(this.id)\n      });\n    } // Ensure all attribute buffers are updated from props or data.\n\n  }, {\n    key: \"update\",\n    value: function update() {\n      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          data = _ref8.data,\n          numInstances = _ref8.numInstances,\n          transitions = _ref8.transitions,\n          _ref8$props = _ref8.props,\n          props = _ref8$props === void 0 ? {} : _ref8$props,\n          _ref8$buffers = _ref8.buffers,\n          buffers = _ref8$buffers === void 0 ? {} : _ref8$buffers,\n          _ref8$context = _ref8.context,\n          context = _ref8$context === void 0 ? {} : _ref8$context; // keep track of whether some attributes are updated\n\n\n      var updated = false;\n      logFunctions.onUpdateStart({\n        level: LOG_START_END_PRIORITY,\n        id: this.id,\n        numInstances: numInstances\n      });\n\n      if (this.stats) {\n        this.stats.timeStart('attribute updates', this.id);\n      }\n\n      for (var attributeName in this.attributes) {\n        var attribute = this.attributes[attributeName];\n\n        if (attribute.setExternalBuffer(buffers[attributeName], this.numInstances)) {// Attribute is using external buffer from the props\n        } else if (attribute.setGenericValue(props[attribute.getAccessor()])) {// Attribute is using generic value from the props\n        } else if (attribute.needsUpdate()) {\n          updated = true;\n\n          this._updateAttribute({\n            attribute: attribute,\n            numInstances: numInstances,\n            data: data,\n            props: props,\n            context: context\n          });\n        }\n\n        this.needsRedraw |= attribute.needsRedraw();\n      }\n\n      if (updated) {\n        // Only initiate alloc/update (and logging) if actually needed\n        if (this.stats) {\n          this.stats.timeEnd('attribute updates', this.id);\n        }\n\n        logFunctions.onUpdateEnd({\n          level: LOG_START_END_PRIORITY,\n          id: this.id,\n          numInstances: numInstances\n        });\n      }\n\n      this.attributeTransitionManager.update({\n        attributes: this.attributes,\n        numInstances: numInstances,\n        transitions: transitions\n      });\n    } // Update attribute transition to the current timestamp\n    // Returns `true` if any transition is in progress\n\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition() {\n      var attributeTransitionManager = this.attributeTransitionManager;\n      var transitionUpdated = attributeTransitionManager.setCurrentTime(Date.now());\n      this.needsRedraw = this.needsRedraw || transitionUpdated;\n      return transitionUpdated;\n    }\n    /**\n     * Returns all attribute descriptors\n     * Note: Format matches luma.gl Model/Program.setAttributes()\n     * @return {Object} attributes - descriptors\n     */\n\n  }, {\n    key: \"getAttributes\",\n    value: function getAttributes() {\n      return this.attributes;\n    }\n    /**\n     * Returns changed attribute descriptors\n     * This indicates which WebGLBuggers need to be updated\n     * @return {Object} attributes - descriptors\n     */\n\n  }, {\n    key: \"getChangedAttributes\",\n    value: function getChangedAttributes(_ref9) {\n      var _ref9$clearChangedFla = _ref9.clearChangedFlags,\n          clearChangedFlags = _ref9$clearChangedFla === void 0 ? false : _ref9$clearChangedFla;\n      var attributes = this.attributes,\n          attributeTransitionManager = this.attributeTransitionManager;\n      var changedAttributes = Object.assign({}, attributeTransitionManager.getAttributes());\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        if (attribute.needsRedraw({\n          clearChangedFlags: true\n        })) {\n          // Only return non-transition attributes\n          if (!attributeTransitionManager.hasAttribute(attributeName)) {\n            changedAttributes[attributeName] = attribute;\n          }\n        }\n      }\n\n      return changedAttributes;\n    } // PROTECTED METHODS - Only to be used by collaborating classes, not by apps\n    // Returns object containing all accessors as keys, with non-null values\n    // @return {Object} - accessors object\n\n  }, {\n    key: \"getAccessors\",\n    value: function getAccessors() {\n      return this.updateTriggers;\n    } // PRIVATE METHODS\n    // Used to register an attribute\n\n  }, {\n    key: \"_add\",\n    value: function _add(attributes, updaters) {\n      var extraProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (updaters) {\n        log.removed('AttributeManager.add({updaters}) - updater map no longer supported');\n      }\n\n      var newAttributes = {};\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName]; // Initialize the attribute descriptor, with WebGL and metadata fields\n\n        newAttributes[attributeName] = new Attribute(this.gl, Object.assign({}, attribute, {\n          id: attributeName,\n          // Luma fields\n          constant: attribute.constant || false,\n          isIndexed: attribute.isIndexed || attribute.elements,\n          size: attribute.elements && 1 || attribute.size,\n          value: attribute.value || null,\n          instanced: attribute.instanced || extraProps.instanced\n        }));\n      }\n\n      Object.assign(this.attributes, newAttributes);\n\n      this._mapUpdateTriggersToAttributes();\n    }\n    /* eslint-enable max-statements */\n    // build updateTrigger name to attribute name mapping\n\n  }, {\n    key: \"_mapUpdateTriggersToAttributes\",\n    value: function _mapUpdateTriggersToAttributes() {\n      var _this = this;\n\n      var triggers = {};\n\n      var _loop = function _loop(attributeName) {\n        var attribute = _this.attributes[attributeName];\n        attribute.getUpdateTriggers().forEach(function (triggerName) {\n          if (!triggers[triggerName]) {\n            triggers[triggerName] = [];\n          }\n\n          triggers[triggerName].push(attributeName);\n        });\n      };\n\n      for (var attributeName in this.attributes) {\n        _loop(attributeName);\n      }\n\n      this.updateTriggers = triggers;\n    }\n  }, {\n    key: \"_invalidateTrigger\",\n    value: function _invalidateTrigger(triggerName) {\n      var attributes = this.attributes,\n          updateTriggers = this.updateTriggers;\n      var invalidatedAttributes = updateTriggers[triggerName];\n\n      if (invalidatedAttributes) {\n        invalidatedAttributes.forEach(function (name) {\n          var attribute = attributes[name];\n\n          if (attribute) {\n            attribute.setNeedsUpdate();\n          }\n        });\n      } else {\n        var message = \"invalidating non-existent trigger \".concat(triggerName, \" for \").concat(this.id, \"\\n\");\n        message += \"Valid triggers: \".concat(Object.keys(attributes).join(', '));\n        log.warn(message, invalidatedAttributes)();\n      }\n\n      return invalidatedAttributes;\n    }\n  }, {\n    key: \"_updateAttribute\",\n    value: function _updateAttribute(_ref10) {\n      var attribute = _ref10.attribute,\n          numInstances = _ref10.numInstances,\n          data = _ref10.data,\n          props = _ref10.props,\n          context = _ref10.context;\n\n      if (attribute.allocate(numInstances)) {\n        logFunctions.onUpdate({\n          level: LOG_DETAIL_PRIORITY,\n          message: \"\".concat(attribute.id, \" allocated \").concat(numInstances),\n          id: this.id\n        });\n      } // Calls update on any buffers that need update\n\n\n      var timeStart = Date.now();\n      var updated = attribute.updateBuffer({\n        numInstances: numInstances,\n        data: data,\n        props: props,\n        context: context\n      });\n\n      if (updated) {\n        this.needsRedraw = true;\n        var timeMs = Math.round(Date.now() - timeStart);\n        logFunctions.onUpdate({\n          level: LOG_DETAIL_PRIORITY,\n          message: \"\".concat(attribute.id, \" updated \").concat(numInstances, \" in \").concat(timeMs, \"ms\")\n        });\n      }\n    }\n  }]);\n\n  return AttributeManager;\n}();\n\nexport { AttributeManager as default };","map":null,"metadata":{},"sourceType":"module"}