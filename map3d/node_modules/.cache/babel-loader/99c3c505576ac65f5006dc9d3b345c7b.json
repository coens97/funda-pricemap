{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Geometry from './geometry';\nimport { uid } from '../utils';\n\nvar PlaneGeometry =\n/*#__PURE__*/\nfunction (_Geometry) {\n  _inherits(PlaneGeometry, _Geometry); // Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n  // copyright 2011 Google Inc. new BSD License\n  // (http://www.opensource.org/licenses/bsd-license.php).\n\n  /* eslint-disable max-statements, complexity */\n\n  /* eslint-disable complexity, max-statements */\n\n\n  function PlaneGeometry() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PlaneGeometry);\n\n    var _opts$type = opts.type,\n        type = _opts$type === void 0 ? 'x,y' : _opts$type,\n        _opts$offset = opts.offset,\n        offset = _opts$offset === void 0 ? 0 : _opts$offset,\n        _opts$flipCull = opts.flipCull,\n        flipCull = _opts$flipCull === void 0 ? false : _opts$flipCull,\n        _opts$unpack = opts.unpack,\n        unpack = _opts$unpack === void 0 ? false : _opts$unpack,\n        _opts$id = opts.id,\n        id = _opts$id === void 0 ? uid('plane-geometry') : _opts$id;\n    var coords = type.split(','); // width, height\n\n    var c1len = opts[\"\".concat(coords[0], \"len\")];\n    var c2len = opts[\"\".concat(coords[1], \"len\")]; // subdivisionsWidth, subdivisionsDepth\n\n    var subdivisions1 = opts[\"n\".concat(coords[0])] || 1;\n    var subdivisions2 = opts[\"n\".concat(coords[1])] || 1;\n    var numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);\n    var positions = new Float32Array(numVertices * 3);\n    var normals = new Float32Array(numVertices * 3);\n    var texCoords = new Float32Array(numVertices * 2);\n\n    if (flipCull) {\n      c1len = -c1len;\n    }\n\n    var i2 = 0;\n    var i3 = 0;\n\n    for (var z = 0; z <= subdivisions2; z++) {\n      for (var x = 0; x <= subdivisions1; x++) {\n        var u = x / subdivisions1;\n        var v = z / subdivisions2;\n        texCoords[i2 + 0] = flipCull ? 1 - u : u;\n        texCoords[i2 + 1] = v;\n\n        switch (type) {\n          case 'x,y':\n            positions[i3 + 0] = c1len * u - c1len * 0.5;\n            positions[i3 + 1] = c2len * v - c2len * 0.5;\n            positions[i3 + 2] = offset;\n            normals[i3 + 0] = 0;\n            normals[i3 + 1] = 0;\n            normals[i3 + 2] = flipCull ? 1 : -1;\n            break;\n\n          case 'x,z':\n            positions[i3 + 0] = c1len * u - c1len * 0.5;\n            positions[i3 + 1] = offset;\n            positions[i3 + 2] = c2len * v - c2len * 0.5;\n            normals[i3 + 0] = 0;\n            normals[i3 + 1] = flipCull ? 1 : -1;\n            normals[i3 + 2] = 0;\n            break;\n\n          case 'y,z':\n            positions[i3 + 0] = offset;\n            positions[i3 + 1] = c1len * u - c1len * 0.5;\n            positions[i3 + 2] = c2len * v - c2len * 0.5;\n            normals[i3 + 0] = flipCull ? 1 : -1;\n            normals[i3 + 1] = 0;\n            normals[i3 + 2] = 0;\n            break;\n\n          default:\n            break;\n        }\n\n        i2 += 2;\n        i3 += 3;\n      }\n    }\n\n    var numVertsAcross = subdivisions1 + 1;\n    var indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);\n\n    for (var _z = 0; _z < subdivisions2; _z++) {\n      for (var _x = 0; _x < subdivisions1; _x++) {\n        var index = (_z * subdivisions1 + _x) * 6; // Make triangle 1 of quad.\n\n        indices[index + 0] = (_z + 0) * numVertsAcross + _x;\n        indices[index + 1] = (_z + 1) * numVertsAcross + _x;\n        indices[index + 2] = (_z + 0) * numVertsAcross + _x + 1; // Make triangle 2 of quad.\n\n        indices[index + 3] = (_z + 1) * numVertsAcross + _x;\n        indices[index + 4] = (_z + 1) * numVertsAcross + _x + 1;\n        indices[index + 5] = (_z + 0) * numVertsAcross + _x + 1;\n      }\n    } // Optionally, unpack indexed geometry\n\n\n    if (unpack) {\n      var positions2 = new Float32Array(indices.length * 3);\n      var normals2 = new Float32Array(indices.length * 3);\n      var texCoords2 = new Float32Array(indices.length * 2);\n\n      for (var _x2 = 0; _x2 < indices.length; ++_x2) {\n        var _index = indices[_x2];\n        positions2[_x2 * 3 + 0] = positions[_index * 3 + 0];\n        positions2[_x2 * 3 + 1] = positions[_index * 3 + 1];\n        positions2[_x2 * 3 + 2] = positions[_index * 3 + 2];\n        normals2[_x2 * 3 + 0] = normals[_index * 3 + 0];\n        normals2[_x2 * 3 + 1] = normals[_index * 3 + 1];\n        normals2[_x2 * 3 + 2] = normals[_index * 3 + 2];\n        texCoords2[_x2 * 2 + 0] = texCoords[_index * 2 + 0];\n        texCoords2[_x2 * 2 + 1] = texCoords[_index * 2 + 1];\n      }\n\n      positions = positions2;\n      normals = normals2;\n      texCoords = texCoords2;\n      indices = undefined;\n    }\n\n    var attributes = {\n      positions: positions,\n      normals: normals,\n      texCoords: texCoords\n    };\n\n    if (indices) {\n      attributes.indices = indices;\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PlaneGeometry).call(this, Object.assign({}, opts, {\n      attributes: attributes,\n      id: id\n    })));\n  }\n\n  return PlaneGeometry;\n}(Geometry);\n\nexport { PlaneGeometry as default };","map":null,"metadata":{},"sourceType":"module"}