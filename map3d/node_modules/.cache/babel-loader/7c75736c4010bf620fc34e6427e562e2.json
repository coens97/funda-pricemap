{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\n\n\nimport * as Polygon from './polygon';\nimport { experimental } from '@deck.gl/core';\nvar fillArray = experimental.fillArray;\nimport { fp64 as fp64Module } from 'luma.gl';\nvar fp64LowPart = fp64Module.fp64LowPart; // Maybe deck.gl or luma.gl needs to export this\n\nfunction getPickingColor(index) {\n  index++;\n  return [index & 255, index >> 8 & 255, index >> 16 & 255];\n}\n\nvar DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\n\nexport var PolygonTesselator =\n/*#__PURE__*/\nfunction () {\n  function PolygonTesselator(_ref) {\n    var polygons = _ref.polygons,\n        IndexType = _ref.IndexType;\n\n    _classCallCheck(this, PolygonTesselator); // Normalize all polygons\n\n\n    polygons = polygons.map(function (polygon) {\n      return Polygon.normalize(polygon);\n    }); // Count all polygon vertices\n\n    var pointCount = getPointCount(polygons);\n    this.polygons = polygons;\n    this.pointCount = pointCount;\n    this.bufferLayout = polygons.map(function (polygon) {\n      return Polygon.getVertexCount(polygon);\n    });\n    this.IndexType = IndexType; // TODO: dynamically decide IndexType in tesselator?\n    // Check if the vertex count excedes index type limit\n\n    if (IndexType === Uint16Array && pointCount > 65535) {\n      throw new Error(\"Vertex count exceeds browser's limit\");\n    }\n\n    this.attributes = {\n      pickingColors: calculatePickingColors({\n        polygons: polygons,\n        pointCount: pointCount\n      })\n    };\n  }\n\n  _createClass(PolygonTesselator, [{\n    key: \"updatePositions\",\n    value: function updatePositions(_ref2) {\n      var fp64 = _ref2.fp64,\n          extruded = _ref2.extruded;\n      var attributes = this.attributes,\n          polygons = this.polygons,\n          pointCount = this.pointCount;\n      attributes.positions = attributes.positions || new Float32Array(pointCount * 3);\n      attributes.vertexValid = attributes.vertexValid || new Uint8ClampedArray(pointCount).fill(1);\n\n      if (fp64) {\n        // We only need x, y component\n        attributes.positions64xyLow = attributes.positions64xyLow || new Float32Array(pointCount * 2);\n      }\n\n      _updatePositions({\n        cache: attributes,\n        polygons: polygons,\n        extruded: extruded,\n        fp64: fp64\n      });\n    }\n  }, {\n    key: \"indices\",\n    value: function indices() {\n      var polygons = this.polygons,\n          IndexType = this.IndexType;\n      return calculateIndices({\n        polygons: polygons,\n        IndexType: IndexType\n      });\n    }\n  }, {\n    key: \"positions\",\n    value: function positions() {\n      return this.attributes.positions;\n    }\n  }, {\n    key: \"positions64xyLow\",\n    value: function positions64xyLow() {\n      return this.attributes.positions64xyLow;\n    }\n  }, {\n    key: \"vertexValid\",\n    value: function vertexValid() {\n      return this.attributes.vertexValid;\n    }\n  }, {\n    key: \"elevations\",\n    value: function elevations() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$key = _ref3.key,\n          key = _ref3$key === void 0 ? 'elevations' : _ref3$key,\n          _ref3$getElevation = _ref3.getElevation,\n          getElevation = _ref3$getElevation === void 0 ? function (x) {\n        return 100;\n      } : _ref3$getElevation;\n\n      var attributes = this.attributes,\n          polygons = this.polygons,\n          pointCount = this.pointCount;\n      var values = updateElevations({\n        cache: attributes[key],\n        polygons: polygons,\n        pointCount: pointCount,\n        getElevation: getElevation\n      });\n      attributes[key] = values;\n      return values;\n    }\n  }, {\n    key: \"colors\",\n    value: function colors() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$key = _ref4.key,\n          key = _ref4$key === void 0 ? 'colors' : _ref4$key,\n          _ref4$getColor = _ref4.getColor,\n          getColor = _ref4$getColor === void 0 ? function (x) {\n        return DEFAULT_COLOR;\n      } : _ref4$getColor;\n\n      var attributes = this.attributes,\n          polygons = this.polygons,\n          pointCount = this.pointCount;\n      var values = updateColors({\n        cache: attributes[key],\n        polygons: polygons,\n        pointCount: pointCount,\n        getColor: getColor\n      });\n      attributes[key] = values;\n      return values;\n    }\n  }, {\n    key: \"pickingColors\",\n    value: function pickingColors() {\n      return this.attributes.pickingColors;\n    }\n  }]);\n\n  return PolygonTesselator;\n}(); // Count number of points in a list of complex polygons\n\nfunction getPointCount(polygons) {\n  return polygons.reduce(function (points, polygon) {\n    return points + Polygon.getVertexCount(polygon);\n  }, 0);\n} // COunt number of triangles in a list of complex polygons\n\n\nfunction getTriangleCount(polygons) {\n  return polygons.reduce(function (triangles, polygon) {\n    return triangles + Polygon.getTriangleCount(polygon);\n  }, 0);\n} // Returns the offsets of each complex polygon in the combined array of all polygons\n\n\nfunction getPolygonOffsets(polygons) {\n  var offsets = new Array(polygons.length + 1);\n  offsets[0] = 0;\n  var offset = 0;\n  polygons.forEach(function (polygon, i) {\n    offset += Polygon.getVertexCount(polygon);\n    offsets[i + 1] = offset;\n  });\n  return offsets;\n}\n\nfunction calculateIndices(_ref5) {\n  var polygons = _ref5.polygons,\n      _ref5$IndexType = _ref5.IndexType,\n      IndexType = _ref5$IndexType === void 0 ? Uint32Array : _ref5$IndexType; // Calculate length of index array (3 * number of triangles)\n\n  var indexCount = 3 * getTriangleCount(polygons);\n  var offsets = getPolygonOffsets(polygons); // Allocate the attribute\n\n  var attribute = new IndexType(indexCount); // 1. get triangulated indices for the internal areas\n  // 2. offset them by the number of indices in previous polygons\n\n  var i = 0;\n  polygons.forEach(function (polygon, polygonIndex) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = Polygon.getSurfaceIndices(polygon)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var index = _step.value;\n        attribute[i++] = index + offsets[polygonIndex];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return attribute;\n}\n\nfunction _updatePositions(_ref6) {\n  var _ref6$cache = _ref6.cache,\n      positions = _ref6$cache.positions,\n      positions64xyLow = _ref6$cache.positions64xyLow,\n      vertexValid = _ref6$cache.vertexValid,\n      polygons = _ref6.polygons,\n      extruded = _ref6.extruded,\n      fp64 = _ref6.fp64; // Flatten out all the vertices of all the sub subPolygons\n\n  var i = 0;\n  polygons.forEach(function (polygon, polygonIndex) {\n    polygon.forEach(function (loop) {\n      loop.forEach(function (vertex, vertexIndex) {\n        // eslint-disable-line\n        var x = vertex[0];\n        var y = vertex[1];\n        var z = vertex[2] || 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n\n        if (fp64) {\n          positions64xyLow[i * 2] = fp64LowPart(x);\n          positions64xyLow[i * 2 + 1] = fp64LowPart(y);\n        }\n\n        i++;\n      });\n      /* We are reusing the some buffer for `nextPositions` by offsetting one vertex\n       * to the left. As a result,\n       * the last vertex of each loop overlaps with the first vertex of the next loop.\n       * `vertexValid` is used to mark the end of each loop so we don't draw these\n       * segments:\n        positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n        nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n        vertexValid    1  1  1  1  0  1  1  0  1 ...\n       */\n\n      vertexValid[i - 1] = 0;\n    });\n  });\n}\n\nfunction updateElevations(_ref7) {\n  var cache = _ref7.cache,\n      polygons = _ref7.polygons,\n      pointCount = _ref7.pointCount,\n      getElevation = _ref7.getElevation;\n  var elevations = cache || new Float32Array(pointCount);\n  var i = 0;\n  polygons.forEach(function (complexPolygon, polygonIndex) {\n    // Calculate polygon color\n    var height = getElevation(polygonIndex);\n    var vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({\n      target: elevations,\n      source: [height],\n      start: i,\n      count: vertexCount\n    });\n    i += vertexCount;\n  });\n  return elevations;\n}\n\nfunction updateColors(_ref8) {\n  var cache = _ref8.cache,\n      polygons = _ref8.polygons,\n      pointCount = _ref8.pointCount,\n      getColor = _ref8.getColor;\n  var colors = cache || new Uint8ClampedArray(pointCount * 4);\n  var i = 0;\n  polygons.forEach(function (complexPolygon, polygonIndex) {\n    // Calculate polygon color\n    var color = getColor(polygonIndex);\n\n    if (isNaN(color[3])) {\n      color[3] = 255;\n    }\n\n    var vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({\n      target: colors,\n      source: color,\n      start: i,\n      count: vertexCount\n    });\n    i += color.length * vertexCount;\n  });\n  return colors;\n}\n\nfunction calculatePickingColors(_ref9) {\n  var polygons = _ref9.polygons,\n      pointCount = _ref9.pointCount;\n  var attribute = new Uint8ClampedArray(pointCount * 3);\n  var i = 0;\n  polygons.forEach(function (complexPolygon, polygonIndex) {\n    var color = getPickingColor(polygonIndex);\n    var vertexCount = Polygon.getVertexCount(complexPolygon);\n    fillArray({\n      target: attribute,\n      source: color,\n      start: i,\n      count: vertexCount\n    });\n    i += color.length * vertexCount;\n  });\n  return attribute;\n}","map":null,"metadata":{},"sourceType":"module"}