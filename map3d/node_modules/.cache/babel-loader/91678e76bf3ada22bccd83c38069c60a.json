{"ast":null,"code":"// All utility mehtods needed to implement Marching Squres algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\nimport assert from 'assert'; // Table to map code to the intersection offsets\n// All offsets are relative to the center of marching cell (which is top right corner of grid-cell)\n\nvar OFFSET = {\n  N: [0, 0.5],\n  E: [0.5, 0],\n  S: [0, -0.5],\n  W: [-0.5, 0]\n}; // Note: above wiki page invertes white/black dots for generating the code, we don't\n\nvar CODE_OFFSET_MAP = {\n  0: [],\n  1: [[OFFSET.W, OFFSET.S]],\n  2: [[OFFSET.S, OFFSET.E]],\n  3: [[OFFSET.W, OFFSET.E]],\n  4: [[OFFSET.N, OFFSET.E]],\n  5: [[OFFSET.W, OFFSET.N], [OFFSET.S, OFFSET.E]],\n  6: [[OFFSET.N, OFFSET.S]],\n  7: [[OFFSET.W, OFFSET.N]],\n  8: [[OFFSET.W, OFFSET.N]],\n  9: [[OFFSET.N, OFFSET.S]],\n  10: [[OFFSET.W, OFFSET.S], [OFFSET.N, OFFSET.E]],\n  11: [[OFFSET.N, OFFSET.E]],\n  12: [[OFFSET.W, OFFSET.E]],\n  13: [[OFFSET.S, OFFSET.E]],\n  14: [[OFFSET.W, OFFSET.S]],\n  15: []\n}; // Returns marching square code for given cell\n\n/* eslint-disable complexity */\n\nexport function getCode(_ref) {\n  var cellWeights = _ref.cellWeights,\n      thresholdValue = _ref.thresholdValue,\n      x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height; // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n\n  assert(x >= -1 && x < width);\n  assert(y >= -1 && y < height);\n  var isLeftBoundary = x < 0;\n  var isRightBoundary = x >= width - 1;\n  var isBottomBoundary = y < 0;\n  var isTopBoundary = y >= height - 1;\n  var top = isLeftBoundary || isTopBoundary ? 0 : cellWeights[(y + 1) * width + x] - thresholdValue >= 0 ? 1 : 0;\n  var topRight = isRightBoundary || isTopBoundary ? 0 : cellWeights[(y + 1) * width + x + 1] - thresholdValue >= 0 ? 1 : 0;\n  var right = isRightBoundary ? 0 : cellWeights[y * width + x + 1] - thresholdValue >= 0 ? 1 : 0;\n  var current = isLeftBoundary || isBottomBoundary ? 0 : cellWeights[y * width + x] - thresholdValue >= 0 ? 1 : 0;\n  var code = top << 3 | topRight << 2 | right << 1 | current;\n  assert(code >= 0 && code < 16);\n  return code;\n}\n/* eslint-enable complexity */\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marchng cell, reference vertex is always top-right corner\n\nexport function getVertices(_ref2) {\n  var gridOrigin = _ref2.gridOrigin,\n      cellSize = _ref2.cellSize,\n      x = _ref2.x,\n      y = _ref2.y,\n      code = _ref2.code;\n  var offsets = CODE_OFFSET_MAP[code]; // Reference vertex is at top-right move to top-right corner\n\n  assert(x >= -1);\n  assert(y >= -1);\n  var rX = (x + 1) * cellSize[0];\n  var rY = (y + 1) * cellSize[1];\n  var refVertexX = gridOrigin[0] + rX;\n  var refVertexY = gridOrigin[1] + rY;\n  var vertices = [];\n  offsets.forEach(function (xyOffsets) {\n    xyOffsets.forEach(function (offset) {\n      var vX = refVertexX + offset[0] * cellSize[0];\n      var vY = refVertexY + offset[1] * cellSize[1];\n      vertices.push([vX, vY]);\n    });\n  });\n  return vertices;\n}","map":null,"metadata":{},"sourceType":"module"}