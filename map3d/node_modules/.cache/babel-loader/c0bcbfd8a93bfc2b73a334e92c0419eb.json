{"ast":null,"code":"var _WEBGL_CONTEXT_POLYFI;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // WebGL1/WebGL2 extension polyfill support\n//\n// Provides a function that creates polyfills for WebGL2 functions based\n// on available extensions and installs them on a supplied target (could be\n// the WebGLContext or its prototype, or a separate object).\n//\n// This is intended to be a stand-alone file with minimal dependencies,\n// easy to reuse or repurpose in other projects.\n\n/* eslint-disable camelcase, brace-style */\n\n\nimport assert from '../utils/assert';\nimport { getParameterPolyfill } from './polyfill-get-parameter';\nvar OES_vertex_array_object = 'OES_vertex_array_object';\nvar ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';\nvar WEBGL_draw_buffers = 'WEBGL_draw_buffers';\nvar EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';\nvar EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';\nvar EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';\nvar ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension'; // Return true if WebGL2 context\n\nfunction isWebGL2(gl) {\n  var GL_TEXTURE_BINDING_3D = 0x806A;\n  return gl && gl.TEXTURE_BINDING_3D === GL_TEXTURE_BINDING_3D;\n} // Return object with webgl2 flag and an extension\n\n\nfunction getExtensionData(gl, extension) {\n  return {\n    webgl2: isWebGL2(gl),\n    ext: gl.getExtension(extension)\n  };\n} // function mapExtensionConstant(gl, constant) {\n//   switch (constant) {\n//   case ext.FRAGMENT_SHADER_DERIVATIVE_HINT_OES: return GL.FRAGMENT_SHADER_DERIVATIVE_HINT;\n//   }\n// }\n\n\nvar WEBGL_CONTEXT_POLYFILLS = (_WEBGL_CONTEXT_POLYFI = {}, _defineProperty(_WEBGL_CONTEXT_POLYFI, OES_vertex_array_object, {\n  meta: {\n    suffix: 'OES'\n  },\n  // NEW METHODS\n  createVertexArray: function createVertexArray() {\n    assert(false, ERR_VAO_NOT_SUPPORTED);\n  },\n  deleteVertexArray: function deleteVertexArray() {},\n  bindVertexArray: function bindVertexArray() {},\n  isVertexArray: function isVertexArray() {\n    return false;\n  }\n}), _defineProperty(_WEBGL_CONTEXT_POLYFI, ANGLE_instanced_arrays, {\n  meta: {\n    suffix: 'ANGLE' // constants: {\n    //   VERTEX_ATTRIB_ARRAY_DIVISOR: 'VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE'\n    // }\n\n  },\n  vertexAttribDivisor: function vertexAttribDivisor(location, divisor) {\n    // Accept divisor 0 even if instancing is not supported (0 = no instancing)\n    assert(divisor === 0, 'WebGL instanced rendering not supported');\n  },\n  drawElementsInstanced: function drawElementsInstanced() {},\n  drawArraysInstanced: function drawArraysInstanced() {}\n}), _defineProperty(_WEBGL_CONTEXT_POLYFI, WEBGL_draw_buffers, {\n  meta: {\n    suffix: 'WEBGL'\n  },\n  drawBuffers: function drawBuffers() {\n    assert(false);\n  }\n}), _defineProperty(_WEBGL_CONTEXT_POLYFI, EXT_disjoint_timer_query, {\n  meta: {\n    suffix: 'EXT'\n  },\n  // WebGL1: Polyfills the WebGL2 Query API\n  createQuery: function createQuery() {\n    assert(false);\n  },\n  deleteQuery: function deleteQuery() {\n    assert(false);\n  },\n  beginQuery: function beginQuery() {\n    assert(false);\n  },\n  endQuery: function endQuery() {},\n  getQuery: function getQuery(handle, pname) {\n    return this.getQueryObject(handle, pname);\n  },\n  // The WebGL1 extension uses getQueryObject rather then getQueryParameter\n  getQueryParameter: function getQueryParameter(handle, pname) {\n    return this.getQueryObject(handle, pname);\n  },\n  // plus the additional `queryCounter` method\n  queryCounter: function queryCounter() {},\n  getQueryObject: function getQueryObject() {}\n}), _defineProperty(_WEBGL_CONTEXT_POLYFI, EXT_disjoint_timer_query_webgl2, {\n  meta: {\n    suffix: 'EXT'\n  },\n  // install `queryCounter`\n  // `null` avoids overwriting WebGL1 `queryCounter` if the WebGL2 extension is not available\n  queryCounter: null\n}), _defineProperty(_WEBGL_CONTEXT_POLYFI, \"OVERRIDES\", {\n  // Ensure readBuffer is a no-op\n  readBuffer: function readBuffer(gl, originalFunc, attachment) {\n    if (isWebGL2(gl)) {\n      originalFunc(attachment);\n    } else {// assert(attachment !== GL_COLOR_ATTACHMENT0 && attachment !== GL_FRONT);\n    }\n  },\n  // Override for getVertexAttrib that returns sane values for non-WebGL1 constants\n  getVertexAttrib: function getVertexAttrib(gl, originalFunc, location, pname) {\n    // const gl = this; // eslint-disable-line\n    var _getExtensionData = getExtensionData(gl, ANGLE_instanced_arrays),\n        webgl2 = _getExtensionData.webgl2,\n        ext = _getExtensionData.ext;\n\n    var GL_VERTEX_ATTRIB_ARRAY_INTEGER = 0x88FD;\n    var GL_VERTEX_ATTRIB_ARRAY_DIVISOR = 0x88FE;\n    var result;\n\n    switch (pname) {\n      // WebGL1 attributes will never be integer\n      case GL_VERTEX_ATTRIB_ARRAY_INTEGER:\n        result = !webgl2 ? false : undefined;\n        break;\n      // if instancing is not available, return 0 meaning divisor has not been set\n\n      case GL_VERTEX_ATTRIB_ARRAY_DIVISOR:\n        result = !webgl2 && !ext ? 0 : undefined;\n        break;\n\n      default:\n    }\n\n    return result !== undefined ? result : originalFunc(location, pname);\n  },\n  // Handle transform feedback and uniform block queries in WebGL1\n  getProgramParameter: function getProgramParameter(gl, originalFunc, program, pname) {\n    var GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;\n    var GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;\n    var GL_ACTIVE_UNIFORM_BLOCKS = 0x8A36;\n    var GL_SEPARATE_ATTRIBS = 0x8C8D;\n\n    if (!isWebGL2(gl)) {\n      switch (pname) {\n        case GL_TRANSFORM_FEEDBACK_BUFFER_MODE:\n          return GL_SEPARATE_ATTRIBS;\n\n        case GL_TRANSFORM_FEEDBACK_VARYINGS:\n          return 0;\n\n        case GL_ACTIVE_UNIFORM_BLOCKS:\n          return 0;\n\n        default:\n      }\n    }\n\n    return originalFunc(program, pname);\n  },\n  getInternalformatParameter: function getInternalformatParameter(gl, originalFunc, target, format, pname) {\n    var GL_SAMPLES = 0x80A9;\n\n    if (!isWebGL2(gl)) {\n      switch (pname) {\n        case GL_SAMPLES:\n          return new Int32Array([0]);\n\n        default:\n      }\n    }\n\n    return gl.getInternalformatParameter(target, format, pname);\n  },\n  getTexParameter: function getTexParameter(gl, originalFunc, target, pname) {\n    var GL_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;\n\n    switch (pname) {\n      case GL_TEXTURE_MAX_ANISOTROPY_EXT:\n        var extensions = gl.luma.extensions;\n        var ext = extensions[EXT_texture_filter_anisotropic];\n        pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || GL_TEXTURE_MAX_ANISOTROPY_EXT;\n        break;\n\n      default:\n    }\n\n    return originalFunc(target, pname);\n  },\n  getParameter: getParameterPolyfill,\n  hint: function hint(gl, originalFunc, pname, value) {\n    // TODO - handle GL.FRAGMENT_SHADER_DERIVATIVE_HINT:\n    // switch (pname) {\n    // case GL.FRAGMENT_SHADER_DERIVATIVE_HINT:\n    // }\n    return originalFunc(pname, value);\n  }\n}), _WEBGL_CONTEXT_POLYFI);\n\nfunction initializeExtensions(gl) {\n  gl.luma.extensions = {};\n  var EXTENSIONS = gl.getSupportedExtensions();\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = EXTENSIONS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var extension = _step.value;\n      gl.luma[extension] = gl.getExtension(extension);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n} // Polyfills a single WebGL extension into the `target` object\n\n\nfunction polyfillExtension(gl, _ref) {\n  var extension = _ref.extension,\n      target = _ref.target,\n      target2 = _ref.target2;\n  var defaults = WEBGL_CONTEXT_POLYFILLS[extension];\n  assert(defaults);\n  var _defaults$meta = defaults.meta,\n      meta = _defaults$meta === void 0 ? {} : _defaults$meta;\n  var _meta$suffix = meta.suffix,\n      suffix = _meta$suffix === void 0 ? '' : _meta$suffix;\n  var ext = gl.getExtension(extension);\n  Object.keys(defaults).forEach(function (key) {\n    var extKey = \"\".concat(key).concat(suffix);\n    var polyfill = null;\n\n    if (key === 'meta') {// ignore\n    } else if (typeof gl[key] === 'function') {// WebGL2 implementation is already\n    } else if (ext && typeof ext[extKey] === 'function') {\n      // pick extension implemenentation,if available\n      polyfill = function polyfill() {\n        return ext[extKey].apply(ext, arguments);\n      };\n    } else if (typeof defaults[key] === 'function') {\n      // pick the mock implementation, if no implementation was detected\n      polyfill = defaults[key].bind(target);\n    }\n\n    if (polyfill) {\n      target[key] = polyfill;\n      target2[key] = polyfill;\n    }\n  });\n} // Install simple overrides (mostly get* functions)\n\n\nfunction installOverrides(gl, _ref2) {\n  var target = _ref2.target,\n      target2 = _ref2.target2;\n  var OVERRIDES = WEBGL_CONTEXT_POLYFILLS.OVERRIDES;\n  Object.keys(OVERRIDES).forEach(function (key) {\n    if (typeof OVERRIDES[key] === 'function') {\n      // install an override, if no implementation was detected\n      var originalFunc = gl[key] ? gl[key].bind(gl) : function () {};\n      var polyfill = OVERRIDES[key].bind(null, gl, originalFunc);\n      target[key] = polyfill;\n      target2[key] = polyfill;\n    }\n  });\n} // Registers polyfill or mock functions for all known extensions\n\n\nexport default function polyfillContext(gl) {\n  gl.luma = gl.luma || {};\n  initializeExtensions(gl);\n\n  if (!gl.luma.polyfilled) {\n    for (var extension in WEBGL_CONTEXT_POLYFILLS) {\n      if (extension !== 'overrides') {\n        polyfillExtension(gl, {\n          extension: extension,\n          target: gl.luma,\n          target2: gl\n        });\n      }\n    }\n\n    installOverrides(gl, {\n      target: gl.luma,\n      target2: gl\n    });\n    gl.luma.polyfilled = true;\n  }\n\n  return gl;\n}","map":null,"metadata":{},"sourceType":"module"}