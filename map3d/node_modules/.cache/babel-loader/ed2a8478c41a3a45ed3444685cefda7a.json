{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n} // Copyright (c) 2015 - 2018 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { CompositeLayer, _GPUGridAggregator as GPUGridAggregator, _pointToDensityGridData as pointToDensityGridData } from '@deck.gl/core';\nimport { LineLayer } from '@deck.gl/layers';\nimport { generateContours as _generateContours } from './contour-utils';\nvar DEFAULT_COLOR = [255, 255, 255];\nvar DEFAULT_STROKE_WIDTH = 1;\nvar DEFAULT_THRESHOLD = 1;\nvar defaultProps = {\n  // grid aggregation\n  cellSize: {\n    type: 'number',\n    min: 1,\n    max: 1000,\n    value: 1000\n  },\n  getPosition: function getPosition(x) {\n    return x.position;\n  },\n  // contour lines\n  contours: [{\n    threshold: DEFAULT_THRESHOLD\n  }],\n  fp64: false\n};\n\nvar ContourLayer =\n/*#__PURE__*/\nfunction (_CompositeLayer) {\n  _inherits(ContourLayer, _CompositeLayer);\n\n  function ContourLayer() {\n    _classCallCheck(this, ContourLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ContourLayer).apply(this, arguments));\n  }\n\n  _createClass(ContourLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      var gl = this.context.gl;\n      var options = {\n        id: \"\".concat(this.id, \"-gpu-aggregator\"),\n        shaderCache: this.context.shaderCache\n      };\n      this.state = {\n        contourData: [],\n        gridAggregator: new GPUGridAggregator(gl, options)\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n      var contoursDirty = false;\n\n      if (changeFlags.dataChanged || oldProps.cellSize !== props.cellSize) {\n        contoursDirty = true; // Clear countsData cache\n\n        this.setState({\n          countsData: null\n        });\n        this.aggregateData();\n      }\n\n      contoursDirty = contoursDirty || this.rebuildContours({\n        oldProps: oldProps,\n        props: props\n      });\n\n      if (contoursDirty) {\n        this.generateContours();\n      }\n    }\n  }, {\n    key: \"getSubLayerClass\",\n    value: function getSubLayerClass() {\n      return LineLayer;\n    }\n  }, {\n    key: \"getSubLayerProps\",\n    value: function getSubLayerProps() {\n      var fp64 = this.props.fp64;\n      return _get(_getPrototypeOf(ContourLayer.prototype), \"getSubLayerProps\", this).call(this, {\n        id: 'contour-line-layer',\n        data: this.state.contourData,\n        fp64: fp64,\n        getSourcePosition: function getSourcePosition(d) {\n          return d.start;\n        },\n        getTargetPosition: function getTargetPosition(d) {\n          return d.end;\n        },\n        getColor: this.onGetSublayerColor.bind(this),\n        getStrokeWidth: this.onGetSublayerStrokeWidth.bind(this)\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var SubLayerClass = this.getSubLayerClass();\n      return new SubLayerClass(this.getSubLayerProps());\n    } // Private\n\n  }, {\n    key: \"aggregateData\",\n    value: function aggregateData() {\n      var _this$props = this.props,\n          data = _this$props.data,\n          cellSizeMeters = _this$props.cellSize,\n          getPosition = _this$props.getPosition,\n          gpuAggregation = _this$props.gpuAggregation,\n          fp64 = _this$props.fp64,\n          coordinateSystem = _this$props.coordinateSystem;\n\n      var _pointToDensityGridDa = pointToDensityGridData({\n        data: data,\n        cellSizeMeters: cellSizeMeters,\n        getPosition: getPosition,\n        gpuAggregation: gpuAggregation,\n        gpuGridAggregator: this.state.gridAggregator,\n        fp64: fp64,\n        coordinateSystem: coordinateSystem,\n        viewport: this.context.viewport\n      }),\n          countsData = _pointToDensityGridDa.countsData,\n          countsBuffer = _pointToDensityGridDa.countsBuffer,\n          gridSize = _pointToDensityGridDa.gridSize,\n          gridOrigin = _pointToDensityGridDa.gridOrigin,\n          cellSize = _pointToDensityGridDa.cellSize;\n\n      this.setState({\n        countsData: countsData,\n        countsBuffer: countsBuffer,\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        cellSize: cellSize\n      });\n    }\n  }, {\n    key: \"generateContours\",\n    value: function generateContours() {\n      var _this$state = this.state,\n          gridSize = _this$state.gridSize,\n          gridOrigin = _this$state.gridOrigin,\n          cellSize = _this$state.cellSize;\n      var countsData = this.state.countsData;\n\n      if (!countsData) {\n        var countsBuffer = this.state.countsBuffer;\n        countsData = countsBuffer.getData();\n        this.setState({\n          countsData: countsData\n        });\n      }\n\n      var _GPUGridAggregator$ge = GPUGridAggregator.getCellData({\n        countsData: countsData\n      }),\n          cellWeights = _GPUGridAggregator$ge.cellWeights;\n\n      var thresholds = this.props.contours.map(function (x) {\n        return x.threshold;\n      });\n\n      var contourData = _generateContours({\n        thresholds: thresholds,\n        cellWeights: cellWeights,\n        gridSize: gridSize,\n        gridOrigin: gridOrigin,\n        cellSize: cellSize\n      });\n\n      this.setState({\n        contourData: contourData\n      });\n    }\n  }, {\n    key: \"onGetSublayerColor\",\n    value: function onGetSublayerColor(segment) {\n      var contours = this.props.contours;\n      var color = DEFAULT_COLOR;\n      contours.forEach(function (data) {\n        if (data.threshold === segment.threshold) {\n          color = data.color || DEFAULT_COLOR;\n        }\n      });\n      return color;\n    }\n  }, {\n    key: \"onGetSublayerStrokeWidth\",\n    value: function onGetSublayerStrokeWidth(segment) {\n      var contours = this.props.contours;\n      var strokeWidth = DEFAULT_STROKE_WIDTH; // Linearly searches the contours, but there should only be few contours\n\n      contours.some(function (contour) {\n        if (contour.threshold === segment.threshold) {\n          strokeWidth = contour.strokeWidth || DEFAULT_STROKE_WIDTH;\n          return true;\n        }\n\n        return false;\n      });\n      return strokeWidth;\n    }\n  }, {\n    key: \"rebuildContours\",\n    value: function rebuildContours(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props;\n\n      if (oldProps.contours.length !== props.contours.length) {\n        return true;\n      }\n\n      var oldThresholds = oldProps.contours.map(function (x) {\n        return x.threshold;\n      });\n      var thresholds = props.contours.map(function (x) {\n        return x.threshold;\n      });\n      return thresholds.some(function (_, i) {\n        return thresholds[i] !== oldThresholds[i];\n      });\n    }\n  }]);\n\n  return ContourLayer;\n}(CompositeLayer);\n\nexport { ContourLayer as default };\nContourLayer.layerName = 'ContourLayer';\nContourLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}