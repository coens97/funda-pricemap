{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport * as Polygon from './polygon';\nimport vec3_normalize from 'gl-vec3/normalize';\nimport { fp64ify } from '../../../lib/utils/fp64';\nimport { get, count } from '../../../lib/utils';\nimport earcut from 'earcut';\nimport flattenDeep from 'lodash.flattendeep';\n\nfunction getPickingColor(index) {\n  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];\n}\n\nfunction parseColor(color) {\n  if (!Array.isArray(color)) {\n    color = [get(color, 0), get(color, 1), get(color, 2), get(color, 3)];\n  }\n\n  color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n  return color;\n}\n\nvar DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\nexport var PolygonTesselatorExtruded = function () {\n  function PolygonTesselatorExtruded(_ref) {\n    var polygons = _ref.polygons,\n        _ref$getHeight = _ref.getHeight,\n        getHeight = _ref$getHeight === undefined ? function (x) {\n      return 1000;\n    } : _ref$getHeight,\n        _ref$getColor = _ref.getColor,\n        getColor = _ref$getColor === undefined ? function (x) {\n      return [0, 0, 0, 255];\n    } : _ref$getColor,\n        _ref$wireframe = _ref.wireframe,\n        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,\n        _ref$fp = _ref.fp64,\n        fp64 = _ref$fp === undefined ? false : _ref$fp;\n\n    _classCallCheck(this, PolygonTesselatorExtruded);\n\n    this.fp64 = fp64; // Expensive operation, convert all polygons to arrays\n\n    polygons = polygons.map(function (complexPolygon, polygonIndex) {\n      var height = getHeight(polygonIndex) || 0;\n      return Polygon.normalize(complexPolygon).map(function (polygon) {\n        return polygon.map(function (coord) {\n          return [get(coord, 0), get(coord, 1), height];\n        });\n      });\n    });\n    var groupedVertices = polygons;\n    this.groupedVertices = polygons;\n    this.wireframe = wireframe;\n    this.attributes = {};\n    var positionsJS = calculatePositionsJS({\n      groupedVertices: groupedVertices,\n      wireframe: wireframe\n    });\n    Object.assign(this.attributes, {\n      positions: calculatePositions(positionsJS, this.fp64),\n      indices: calculateIndices({\n        groupedVertices: groupedVertices,\n        wireframe: wireframe\n      }),\n      normals: calculateNormals({\n        groupedVertices: groupedVertices,\n        wireframe: wireframe\n      }),\n      // colors: calculateColors({groupedVertices, wireframe, getColor}),\n      pickingColors: calculatePickingColors({\n        groupedVertices: groupedVertices,\n        wireframe: wireframe\n      })\n    });\n  }\n\n  _createClass(PolygonTesselatorExtruded, [{\n    key: 'indices',\n    value: function indices() {\n      return this.attributes.indices;\n    }\n  }, {\n    key: 'positions',\n    value: function positions() {\n      return this.attributes.positions;\n    }\n  }, {\n    key: 'normals',\n    value: function normals() {\n      return this.attributes.normals;\n    }\n  }, {\n    key: 'colors',\n    value: function colors() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$getColor = _ref2.getColor,\n          getColor = _ref2$getColor === undefined ? function (x) {\n        return DEFAULT_COLOR;\n      } : _ref2$getColor;\n\n      var groupedVertices = this.groupedVertices,\n          wireframe = this.wireframe;\n      return calculateColors({\n        groupedVertices: groupedVertices,\n        wireframe: wireframe,\n        getColor: getColor\n      });\n    }\n  }, {\n    key: 'pickingColors',\n    value: function pickingColors() {\n      return this.attributes.pickingColors;\n    } // updateTriggers: {\n    //   positions: ['getHeight'],\n    //   colors: ['getColors']\n    //   pickingColors: 'none'\n    // }\n\n  }]);\n\n  return PolygonTesselatorExtruded;\n}();\n\nfunction countVertices(vertices) {\n  return vertices.reduce(function (vertexCount, polygon) {\n    return vertexCount + count(polygon);\n  }, 0);\n}\n\nfunction calculateIndices(_ref3) {\n  var groupedVertices = _ref3.groupedVertices,\n      _ref3$wireframe = _ref3.wireframe,\n      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe; // adjust index offset for multiple polygons\n\n  var multiplier = wireframe ? 2 : 5;\n  var offsets = groupedVertices.reduce(function (acc, vertices) {\n    return acc.concat(acc[acc.length - 1] + countVertices(vertices) * multiplier);\n  }, [0]);\n  var indices = groupedVertices.map(function (vertices, polygonIndex) {\n    return wireframe ? // 1. get sequentially ordered indices of each polygons wireframe\n    // 2. offset them by the number of indices in previous polygons\n    calculateContourIndices(vertices, offsets[polygonIndex]) : // 1. get triangulated indices for the internal areas\n    // 2. offset them by the number of indices in previous polygons\n    calculateSurfaceIndices(vertices, offsets[polygonIndex]);\n  });\n  return new Uint32Array(flattenDeep(indices));\n} // Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays\n// Remarks:\n// * each top vertex is on 3 surfaces\n// * each bottom vertex is on 2 surfaces\n\n\nfunction calculatePositionsJS(_ref4) {\n  var groupedVertices = _ref4.groupedVertices,\n      _ref4$wireframe = _ref4.wireframe,\n      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;\n  var positions = groupedVertices.map(function (vertices) {\n    var topVertices = Array.prototype.concat.apply([], vertices);\n    var baseVertices = topVertices.map(function (v) {\n      return [get(v, 0), get(v, 1), 0];\n    });\n    return wireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n  });\n  return flattenDeep(positions);\n}\n\nfunction calculatePositions(positionsJS, fp64) {\n  var positionLow = void 0;\n\n  if (fp64) {\n    // We only need x, y component\n    positionLow = new Float32Array(positionsJS.length / 3 * 2);\n\n    for (var i = 0; i < positionsJS.length / 3; i++) {\n      positionLow[i * 2 + 0] = fp64ify(positionsJS[i * 3 + 0])[1];\n      positionLow[i * 2 + 1] = fp64ify(positionsJS[i * 3 + 1])[1];\n    }\n  }\n\n  return {\n    positions: new Float32Array(positionsJS),\n    positions64xyLow: positionLow\n  };\n}\n\nfunction calculateNormals(_ref5) {\n  var groupedVertices = _ref5.groupedVertices,\n      wireframe = _ref5.wireframe;\n  var up = [0, 1, 0];\n  var normals = groupedVertices.map(function (vertices, polygonIndex) {\n    var topNormals = new Array(countVertices(vertices)).fill(up);\n    var sideNormals = vertices.map(function (polygon) {\n      return calculateSideNormals(polygon);\n    });\n    var sideNormalsForward = sideNormals.map(function (n) {\n      return n[0];\n    });\n    var sideNormalsBackward = sideNormals.map(function (n) {\n      return n[1];\n    });\n    return wireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];\n  });\n  return new Float32Array(flattenDeep(normals));\n}\n\nfunction calculateSideNormals(vertices) {\n  var normals = [];\n  var lastVertice = null;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var vertice = _step.value;\n\n      if (lastVertice) {\n        // vertex[i-1], vertex[i]\n        var n = getNormal(lastVertice, vertice);\n        normals.push(n);\n      }\n\n      lastVertice = vertice;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return [[normals.concat(normals[0])], [[normals[0]].concat(normals)]];\n}\n\nfunction calculateColors(_ref6) {\n  var groupedVertices = _ref6.groupedVertices,\n      getColor = _ref6.getColor,\n      _ref6$wireframe = _ref6.wireframe,\n      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;\n  var colors = groupedVertices.map(function (complexPolygon, polygonIndex) {\n    var color = getColor(polygonIndex);\n    color = parseColor(color);\n    var numVertices = countVertices(complexPolygon);\n    var topColors = new Array(numVertices).fill(color);\n    var baseColors = new Array(numVertices).fill(color);\n    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];\n  });\n  return new Uint8ClampedArray(flattenDeep(colors));\n}\n\nfunction calculatePickingColors(_ref7) {\n  var groupedVertices = _ref7.groupedVertices,\n      _ref7$wireframe = _ref7.wireframe,\n      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;\n  var colors = groupedVertices.map(function (vertices, polygonIndex) {\n    var numVertices = countVertices(vertices);\n    var color = getPickingColor(polygonIndex);\n    var topColors = new Array(numVertices).fill(color);\n    var baseColors = new Array(numVertices).fill(color);\n    return wireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];\n  });\n  return new Uint8ClampedArray(flattenDeep(colors));\n}\n\nfunction calculateContourIndices(vertices, offset) {\n  var stride = countVertices(vertices);\n  return vertices.map(function (polygon) {\n    var indices = [offset];\n    var numVertices = polygon.length; // polygon top\n    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n\n    for (var i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n\n    indices.push(offset); // polygon sides\n\n    for (var _i = 0; _i < numVertices - 1; _i++) {\n      indices.push(_i + offset, _i + stride + offset);\n    }\n\n    offset += numVertices;\n    return indices;\n  });\n}\n\nfunction calculateSurfaceIndices(vertices, offset) {\n  var stride = countVertices(vertices);\n  var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];\n\n  function drawRectangle(i) {\n    return quad.map(function (v) {\n      return i + v[0] + stride * v[1] + offset;\n    });\n  }\n\n  var holes = null;\n\n  if (vertices.length > 1) {\n    holes = vertices.reduce(function (acc, polygon) {\n      return acc.concat(acc[acc.length - 1] + polygon.length);\n    }, [0]).slice(1, vertices.length);\n  }\n\n  var topIndices = earcut(flattenDeep(vertices), holes, 3).map(function (index) {\n    return index + offset;\n  });\n  var sideIndices = vertices.map(function (polygon) {\n    var numVertices = polygon.length; // polygon top\n\n    var indices = []; // polygon sides\n\n    for (var i = 0; i < numVertices - 1; i++) {\n      indices = indices.concat(drawRectangle(i));\n    }\n\n    offset += numVertices;\n    return indices;\n  });\n  return [topIndices, sideIndices];\n} // helpers\n// get normal vector of line segment\n\n\nfunction getNormal(p1, p2) {\n  var p1x = get(p1, 0);\n  var p1y = get(p1, 1);\n  var p2x = get(p2, 0);\n  var p2y = get(p2, 1);\n\n  if (p1x === p2x && p1y === p2y) {\n    return [1, 0, 0];\n  }\n\n  var degrees2radians = Math.PI / 180;\n  var lon1 = degrees2radians * p1x;\n  var lon2 = degrees2radians * p2x;\n  var lat1 = degrees2radians * p1y;\n  var lat2 = degrees2radians * p2y;\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return vec3_normalize([], [b, 0, -a]);\n}","map":null,"metadata":{},"sourceType":"module"}