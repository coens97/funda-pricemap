{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport Geometry from './geometry';\nimport { Vector3 } from '../packages/math';\n/* eslint-disable comma-spacing, max-statements, complexity */\n\nvar ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];\nvar ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];\n\nvar IcoSphereGeometry =\n/*#__PURE__*/\nfunction (_Geometry) {\n  _inherits(IcoSphereGeometry, _Geometry);\n\n  function IcoSphereGeometry() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, IcoSphereGeometry);\n\n    var _opts$iterations = opts.iterations,\n        iterations = _opts$iterations === undefined ? 0 : _opts$iterations;\n    var PI = Math.PI;\n    var PI2 = PI * 2;\n    var positions = [].concat(ICO_POSITIONS);\n    var indices = [].concat(ICO_INDICES);\n    positions.push();\n    indices.push();\n\n    var getMiddlePoint = function () {\n      var pointMemo = {};\n      return function (i1, i2) {\n        i1 *= 3;\n        i2 *= 3;\n        var mini = i1 < i2 ? i1 : i2;\n        var maxi = i1 > i2 ? i1 : i2;\n        var key = mini + '|' + maxi;\n\n        if (key in pointMemo) {\n          return pointMemo[key];\n        }\n\n        var x1 = positions[i1];\n        var y1 = positions[i1 + 1];\n        var z1 = positions[i1 + 2];\n        var x2 = positions[i2];\n        var y2 = positions[i2 + 1];\n        var z2 = positions[i2 + 2];\n        var xm = (x1 + x2) / 2;\n        var ym = (y1 + y2) / 2;\n        var zm = (z1 + z2) / 2;\n        var len = Math.sqrt(xm * xm + ym * ym + zm * zm);\n        xm /= len;\n        ym /= len;\n        zm /= len;\n        positions.push(xm, ym, zm);\n        return pointMemo[key] = positions.length / 3 - 1;\n      };\n    }();\n\n    for (var i = 0; i < iterations; i++) {\n      var indices2 = [];\n\n      for (var j = 0; j < indices.length; j += 3) {\n        var a = getMiddlePoint(indices[j + 0], indices[j + 1]);\n        var b = getMiddlePoint(indices[j + 1], indices[j + 2]);\n        var c = getMiddlePoint(indices[j + 2], indices[j + 0]);\n        indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);\n      }\n\n      indices = indices2;\n    } // Calculate texCoords and normals\n\n\n    var normals = new Array(indices.length * 3);\n    var texCoords = new Array(indices.length * 2);\n    var l = indices.length;\n\n    for (var _i = l - 3; _i >= 0; _i -= 3) {\n      var i1 = indices[_i + 0];\n      var i2 = indices[_i + 1];\n      var i3 = indices[_i + 2];\n      var in1 = i1 * 3;\n      var in2 = i2 * 3;\n      var in3 = i3 * 3;\n      var iu1 = i1 * 2;\n      var iu2 = i2 * 2;\n      var iu3 = i3 * 2;\n      var x1 = positions[in1 + 0];\n      var y1 = positions[in1 + 1];\n      var z1 = positions[in1 + 2];\n      var theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));\n      var phi1 = Math.atan2(y1, x1) + PI;\n      var v1 = theta1 / PI;\n      var u1 = 1 - phi1 / PI2;\n      var x2 = positions[in2 + 0];\n      var y2 = positions[in2 + 1];\n      var z2 = positions[in2 + 2];\n      var theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));\n      var phi2 = Math.atan2(y2, x2) + PI;\n      var v2 = theta2 / PI;\n      var u2 = 1 - phi2 / PI2;\n      var x3 = positions[in3 + 0];\n      var y3 = positions[in3 + 1];\n      var z3 = positions[in3 + 2];\n      var theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));\n      var phi3 = Math.atan2(y3, x3) + PI;\n      var v3 = theta3 / PI;\n      var u3 = 1 - phi3 / PI2;\n      var vec1 = [x3 - x2, y3 - y2, z3 - z2];\n      var vec2 = [x1 - x2, y1 - y2, z1 - z2];\n      var normal = new Vector3(vec1).cross(vec2).normalize();\n      var newIndex = void 0;\n\n      if ((u1 === 0 || u2 === 0 || u3 === 0) && (u1 === 0 || u1 > 0.5) && (u2 === 0 || u2 > 0.5) && (u3 === 0 || u3 > 0.5)) {\n        positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);\n        newIndex = positions.length / 3 - 1;\n        indices.push(newIndex);\n        texCoords[newIndex * 2 + 0] = 1;\n        texCoords[newIndex * 2 + 1] = v1;\n        normals[newIndex * 3 + 0] = normal.x;\n        normals[newIndex * 3 + 1] = normal.y;\n        normals[newIndex * 3 + 2] = normal.z;\n        positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);\n        newIndex = positions.length / 3 - 1;\n        indices.push(newIndex);\n        texCoords[newIndex * 2 + 0] = 1;\n        texCoords[newIndex * 2 + 1] = v2;\n        normals[newIndex * 3 + 0] = normal.x;\n        normals[newIndex * 3 + 1] = normal.y;\n        normals[newIndex * 3 + 2] = normal.z;\n        positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);\n        newIndex = positions.length / 3 - 1;\n        indices.push(newIndex);\n        texCoords[newIndex * 2 + 0] = 1;\n        texCoords[newIndex * 2 + 1] = v3;\n        normals[newIndex * 3 + 0] = normal.x;\n        normals[newIndex * 3 + 1] = normal.y;\n        normals[newIndex * 3 + 2] = normal.z;\n      }\n\n      normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;\n      normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;\n      normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;\n      texCoords[iu1 + 0] = u1;\n      texCoords[iu1 + 1] = v1;\n      texCoords[iu2 + 0] = u2;\n      texCoords[iu2 + 1] = v2;\n      texCoords[iu3 + 0] = u3;\n      texCoords[iu3 + 1] = v3;\n    }\n\n    return _possibleConstructorReturn(this, (IcoSphereGeometry.__proto__ || Object.getPrototypeOf(IcoSphereGeometry)).call(this, Object.assign({}, opts, {\n      attributes: {\n        positions: new Float32Array(positions),\n        normals: new Float32Array(normals),\n        texCoords: new Float32Array(texCoords),\n        indices: new Uint16Array(indices)\n      }\n    })));\n  }\n\n  return IcoSphereGeometry;\n}(Geometry);\n\nexport default IcoSphereGeometry;","map":null,"metadata":{},"sourceType":"module"}