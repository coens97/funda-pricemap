{"ast":null,"code":"function _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // event.js\n// Handle keyboard/mouse/touch events in the Canvas\n// TODO - this will not work under node\n\n/* eslint-disable dot-notation, max-statements, no-loop-func */\n\n/* global window, document */\n\n\nfunction noop() {}\n\nvar KEYS = {\n  enter: 13,\n  up: 38,\n  down: 40,\n  left: 37,\n  right: 39,\n  esc: 27,\n  space: 32,\n  backspace: 8,\n  tab: 9,\n  delete: 46\n}; // returns an O3D object or false otherwise.\n\nfunction toO3D(n) {\n  return n !== true ? n : false;\n} // Returns an element position\n\n\nfunction _getPos(elem) {\n  var bbox = elem.getBoundingClientRect();\n  return {\n    x: bbox.left,\n    y: bbox.top,\n    bbox: bbox\n  };\n} // event object wrapper\n\n\nexport function get(e, win) {\n  win = win || window;\n  return e || win.event;\n}\nexport function getWheel(e) {\n  return e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n}\nexport function getKey(e) {\n  var code = e.which || e.keyCode;\n  var key = keyOf(code); // onkeydown\n\n  var fKey = code - 111;\n\n  if (fKey > 0 && fKey < 13) {\n    key = \"f\".concat(fKey);\n  }\n\n  key = key || String.fromCharCode(code).toLowerCase();\n  return {\n    code: code,\n    key: key,\n    shift: e.shiftKey,\n    control: e.ctrlKey,\n    alt: e.altKey,\n    meta: e.metaKey\n  };\n}\nexport function isRightClick(e) {\n  return e.which === 3 || e.button === 2;\n}\nexport function getPos(e, win) {\n  // get mouse position\n  win = win || window;\n  e = e || win.event;\n  var doc = win.document;\n  doc = doc.documentElement || doc.body; // TODO(nico): make touch event handling better\n\n  if (e.touches && e.touches.length) {\n    var touchesPos = [];\n    var l = e.touches.length;\n    var evt;\n\n    for (var i = 0; i < l; ++i) {\n      evt = e.touches[i];\n      touchesPos.push({\n        x: evt.pageX || evt.clientX + doc.scrollLeft,\n        y: evt.pageY || evt.clientY + doc.scrollTop\n      });\n    }\n\n    return touchesPos;\n  }\n\n  var page = {\n    x: e.pageX || e.clientX + doc.scrollLeft,\n    y: e.pageY || e.clientY + doc.scrollTop\n  };\n  return [page];\n}\n\nfunction _stop(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n\n  e.cancelBubble = true;\n\n  if (e.preventDefault) {\n    e.preventDefault();\n  } else {\n    e.returnValue = false;\n  }\n}\n\nexport { _stop as stop };\nexport var EventsProxy =\n/*#__PURE__*/\nfunction () {\n  function EventsProxy(domElem, opt) {\n    _classCallCheck(this, EventsProxy);\n\n    this.scene = opt.scene;\n    this.domElem = domElem;\n    this.pos = _getPos(domElem);\n    this.opt = this.callbacks = opt;\n    this.size = {\n      width: domElem.width || domElem.offsetWidth,\n      height: domElem.height || domElem.offsetHeight\n    };\n    this.attachEvents();\n  }\n\n  _createClass(EventsProxy, [{\n    key: \"attachEvents\",\n    value: function attachEvents() {\n      var _this = this;\n\n      var domElem = this.domElem;\n      var opt = this.opt;\n\n      if (opt.disableContextMenu) {\n        domElem.oncontextmenu = function () {\n          return false;\n        };\n      }\n\n      if (opt.enableMouse) {\n        ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout'].forEach(function (action) {\n          domElem.addEventListener(action, function (e, win) {\n            _this[action](_this.eventInfo(action, e, win));\n          }, false);\n        }); // \"well, this is embarrassing...\"\n\n        var type = '';\n\n        if (!document.getBoxObjectFor && window.mozInnerScreenX === null) {\n          type = 'mousewheel';\n        } else {\n          type = 'DOMMouseScroll';\n        }\n\n        domElem.addEventListener(type, function (e, win) {\n          _this['mousewheel'](_this.eventInfo('mousewheel', e, win));\n        }, false);\n      }\n\n      if (opt.enableTouch) {\n        ['touchstart', 'touchmove', 'touchend'].forEach(function (action) {\n          domElem.addEventListener(action, function (e, win) {\n            _this[action](_this.eventInfo(action, e, win));\n          }, false);\n        });\n      }\n\n      if (opt.enableKeyboard) {\n        ['keydown', 'keyup'].forEach(function (action) {\n          document.addEventListener(action, function (e, win) {\n            _this[action](_this.eventInfo(action, e, win));\n          }, false);\n        });\n      }\n    }\n  }, {\n    key: \"eventInfo\",\n    value: function eventInfo(type, e, win) {\n      var domElem = this.domElem;\n      var scene = this.scene;\n      var opt = this.opt;\n      var size = this.getSize();\n      var relative = opt.relative;\n      var centerOrigin = opt.centerOrigin;\n\n      var pos = opt.cachePosition && this.pos || _getPos(domElem);\n\n      var ge = get(e, win);\n      var epos = getPos(e, win);\n      var origPos = {\n        x: epos[0].x,\n        y: epos[0].y\n      };\n      var evt = {};\n      var x;\n      var y; // get Position\n\n      for (var i = 0, l = epos.length; i < l; ++i) {\n        x = epos[i].x;\n        y = epos[i].y;\n\n        if (relative) {\n          x -= pos.x;\n          y -= pos.y;\n\n          if (centerOrigin) {\n            x -= size.width / 2;\n            y -= size.height / 2; // y axis now points to the top of the screen\n\n            y *= -1;\n          }\n        }\n\n        epos[i].x = x;\n        epos[i].y = y;\n      }\n\n      switch (type) {\n        case 'mousewheel':\n          evt.wheel = getWheel(ge);\n          break;\n\n        case 'keydown':\n        case 'keyup':\n          Object.assign(evt, getKey(ge));\n          break;\n\n        case 'mouseup':\n          evt.isRightClick = isRightClick(ge);\n          break;\n\n        default:\n          break;\n      }\n\n      var cacheTarget;\n      Object.assign(evt, {\n        x: epos[0].x,\n        y: epos[0].y,\n        posArray: epos,\n        cache: false,\n        // stop event propagation\n        stop: function stop() {\n          _stop(ge);\n        },\n        // get the target element of the event\n        getTarget: function getTarget() {\n          if (cacheTarget) {\n            return cacheTarget;\n          }\n\n          return cacheTarget = opt.picking && scene.pick(origPos.x - pos.x, origPos.y - pos.y) || true;\n        }\n      }); // wrap native event\n\n      evt.event = ge;\n      return evt;\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      if (this.cacheSize) {\n        return this.size;\n      }\n\n      var domElem = this.domElem;\n      return {\n        width: domElem.width || domElem.offsetWidth,\n        height: domElem.height || domElem.offsetHeight\n      };\n    }\n  }, {\n    key: \"mouseup\",\n    value: function mouseup(e) {\n      if (!this.moved) {\n        if (e.isRightClick) {\n          this.callbacks.onRightClick(e, this.hovered);\n        } else {\n          this.callbacks.onClick(e, toO3D(this.pressed));\n        }\n      }\n\n      if (this.pressed) {\n        if (this.moved) {\n          this.callbacks.onDragEnd(e, toO3D(this.pressed));\n        } else {\n          this.callbacks.onDragCancel(e, toO3D(this.pressed));\n        }\n\n        this.pressed = this.moved = false;\n      }\n    }\n  }, {\n    key: \"mouseout\",\n    value: function mouseout(e) {\n      // mouseout canvas\n      var rt = e.relatedTarget;\n      var domElem = this.domElem;\n\n      while (rt && rt.parentNode) {\n        if (domElem === rt.parentNode) {\n          return;\n        }\n\n        rt = rt.parentNode;\n      }\n\n      if (this.hovered) {\n        this.callbacks.onMouseLeave(e, this.hovered);\n        this.hovered = false;\n      }\n\n      if (this.pressed && this.moved) {\n        this.callbacks.onDragEnd(e);\n        this.pressed = this.moved = false;\n      }\n    }\n  }, {\n    key: \"mouseover\",\n    value: function mouseover(e) {}\n  }, {\n    key: \"mousemove\",\n    value: function mousemove(e) {\n      if (this.pressed) {\n        this.moved = true;\n        this.callbacks.onDragMove(e, toO3D(this.pressed));\n        return;\n      }\n\n      if (this.hovered) {\n        var target = toO3D(e.getTarget());\n\n        if (!target || target.hash !== this.hash) {\n          this.callbacks.onMouseLeave(e, this.hovered);\n          this.hovered = target;\n          this.hash = target;\n\n          if (target) {\n            this.hash = target.hash;\n            this.callbacks.onMouseEnter(e, this.hovered);\n          }\n        } else {\n          this.callbacks.onMouseMove(e, this.hovered);\n        }\n      } else {\n        this.hovered = toO3D(e.getTarget());\n        this.hash = this.hovered;\n\n        if (this.hovered) {\n          this.hash = this.hovered.hash;\n          this.callbacks.onMouseEnter(e, this.hovered);\n        }\n      }\n\n      if (!this.opt.picking) {\n        this.callbacks.onMouseMove(e);\n      }\n    }\n  }, {\n    key: \"mousewheel\",\n    value: function mousewheel(e) {\n      this.callbacks.onMouseWheel(e);\n    }\n  }, {\n    key: \"mousedown\",\n    value: function mousedown(e) {\n      this.pressed = e.getTarget();\n      this.callbacks.onDragStart(e, toO3D(this.pressed));\n    }\n  }, {\n    key: \"touchstart\",\n    value: function touchstart(e) {\n      this.touched = e.getTarget();\n      this.touchedLastPosition = {\n        x: e.x,\n        y: e.y\n      };\n      this.callbacks.onTouchStart(e, toO3D(this.touched));\n    }\n  }, {\n    key: \"touchmove\",\n    value: function touchmove(e) {\n      if (this.touched) {\n        this.touchMoved = true;\n        this.callbacks.onTouchMove(e, toO3D(this.touched));\n      }\n    }\n  }, {\n    key: \"touchend\",\n    value: function touchend(e) {\n      if (this.touched) {\n        if (this.touchMoved) {\n          this.callbacks.onTouchEnd(e, toO3D(this.touched));\n        } else {\n          e.x = isNaN(e.x) ? this.touchedLastPosition.x : e.x;\n          e.y = isNaN(e.y) ? this.touchedLastPosition.y : e.y;\n          this.callbacks.onTap(e, toO3D(this.touched));\n          this.callbacks.onTouchCancel(e, toO3D(this.touched));\n        }\n\n        this.touched = this.touchMoved = false;\n      }\n    }\n  }, {\n    key: \"keydown\",\n    value: function keydown(e) {\n      this.callbacks.onKeyDown(e);\n    }\n  }, {\n    key: \"keyup\",\n    value: function keyup(e) {\n      this.callbacks.onKeyUp(e);\n    }\n  }]);\n\n  return EventsProxy;\n}();\nObject.assign(EventsProxy.prototype, {\n  hovered: false,\n  pressed: false,\n  touched: false,\n  touchedLastPosition: {\n    x: 0,\n    y: 0\n  },\n  touchMoved: false,\n  moved: false\n});\nvar DEFAULT_OPTS = {\n  cachePosition: true,\n  cacheSize: true,\n  relative: true,\n  centerOrigin: true,\n  disableContextMenu: true,\n  bind: false,\n  picking: false,\n  enableTouch: true,\n  enableMouse: true,\n  enableKeyboard: true,\n  onClick: noop,\n  onRightClick: noop,\n  onDragStart: noop,\n  onDragMove: noop,\n  onDragEnd: noop,\n  onDragCancel: noop,\n  onTouchStart: noop,\n  onTouchMove: noop,\n  onTouchEnd: noop,\n  onTouchCancel: noop,\n  onTap: noop,\n  onMouseMove: noop,\n  onMouseEnter: noop,\n  onMouseLeave: noop,\n  onMouseWheel: noop,\n  onKeyDown: noop,\n  onKeyUp: noop\n};\nexport var Keys = KEYS;\n\nfunction keyOf(code) {\n  var keyMap = Keys;\n\n  for (var name in keyMap) {\n    if (keyMap[name] === code) {\n      return name;\n    }\n  }\n\n  return null;\n}\n\nexport function addEvents(domElement) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = Object.assign({}, DEFAULT_OPTS, opt);\n  var bind = opt.bind;\n\n  if (bind) {\n    for (var name in opt) {\n      if (name.match(/^on[a-zA-Z0-9]+$/)) {\n        (function (fname, fn) {\n          opt[fname] = function f() {\n            fn.apply(bind, Array.prototype.slice.call(arguments));\n          };\n        })(name, opt[name]);\n      }\n    }\n  }\n\n  return new EventsProxy(domElement, opt);\n}\nexport function removeEvents(domElement) {\n  var opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = Object.assign({}, DEFAULT_OPTS, opt);\n  var bind = opt.bind;\n\n  if (bind) {\n    for (var name in opt) {\n      if (name.match(/^on[a-zA-Z0-9]+$/)) {\n        (function (fname, fn) {\n          opt[fname] = function f() {\n            fn.apply(bind, Array.prototype.slice.call(arguments));\n          };\n        })(name, opt[name]);\n      }\n    }\n  }\n\n  return new EventsProxy(domElement, opt);\n}","map":null,"metadata":{},"sourceType":"module"}