{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = extractJSXLayers;\n\nvar _react = _interopRequireWildcard(require(\"react\"));\n\nvar _inheritsFrom = require(\"./inherits-from\");\n\nvar _core = require(\"@deck.gl/core\");\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n} // recursively wrap render callbacks in `View`\n\n\nfunction wrapInView(node) {\n  if (!node) {\n    return node;\n  }\n\n  if (typeof node === 'function') {\n    // React.Children does not traverse functions.\n    // All render callbacks must be protected under a <View>\n    return (0, _react.createElement)(_core.View, {}, node);\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(wrapInView);\n  }\n\n  if ((0, _inheritsFrom.inheritsFrom)(node.type, _core.View)) {\n    return node;\n  }\n\n  return node;\n} // extracts any deck.gl layers masquerading as react elements from props.children\n\n\nfunction extractJSXLayers(_ref) {\n  var children = _ref.children,\n      layers = _ref.layers,\n      views = _ref.views;\n  var reactChildren = []; // extract real react elements (i.e. not deck.gl layers)\n\n  var jsxLayers = []; // extracted layer from react children, will add to deck.gl layer array\n\n  var jsxViews = {}; // React.children\n\n  _react.default.Children.forEach(wrapInView(children), function (reactElement) {\n    if (reactElement) {\n      // For some reason Children.forEach doesn't filter out `null`s\n      var ElementType = reactElement.type;\n\n      if ((0, _inheritsFrom.inheritsFrom)(ElementType, _core.Layer)) {\n        var layer = new ElementType(reactElement.props);\n        jsxLayers.push(layer);\n      } else {\n        reactChildren.push(reactElement);\n      } // empty id => default view\n\n\n      if (ElementType !== _core.View && (0, _inheritsFrom.inheritsFrom)(ElementType, _core.View) && reactElement.props.id) {\n        var view = new ElementType(reactElement.props);\n        jsxViews[view.id] = view;\n      }\n    }\n  }); // Avoid modifying views if no JSX views were found\n\n\n  if (Object.keys(jsxViews).length > 0) {\n    // If a view is specified in both views prop and JSX, use the one in views\n    if (Array.isArray(views)) {\n      views.forEach(function (view) {\n        jsxViews[view.id] = view;\n      });\n    } else if (views) {\n      jsxViews[views.id] = views;\n    }\n\n    views = Object.values(jsxViews);\n  } // Avoid modifying layers array if no JSX layers were found\n\n\n  layers = jsxLayers.length > 0 ? jsxLayers.concat(_toConsumableArray(layers)) : layers;\n  return {\n    layers: layers,\n    children: reactChildren,\n    views: views\n  };\n}","map":null,"metadata":{},"sourceType":"script"}