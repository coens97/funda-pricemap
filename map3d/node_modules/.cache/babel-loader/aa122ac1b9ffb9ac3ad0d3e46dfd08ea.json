{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport GL from './api';\nimport { assertWebGL2Context } from './context';\nimport { getGLTypeFromTypedArray, getTypedArrayFromGLType } from '../utils/typed-array-utils';\nimport Resource from './resource';\nimport assert from 'assert';\nvar ERR_BUFFER_PARAMS = 'Illegal or missing parameter to Buffer';\nvar GL_COPY_READ_BUFFER = 0x8F36;\nvar GL_COPY_WRITE_BUFFER = 0x8F37;\nvar GL_TRANSFORM_FEEDBACK_BUFFER = 0x8C8E;\nexport var BufferLayout =\n/*#__PURE__*/\n\n/**\n * @classdesc\n * Store characteristics of a data layout\n * This data can be used when updating vertex attributes with\n * the associated buffer, freeing the application from keeping\n * track of this metadata.\n *\n * @class\n * @param {GLuint} size - number of values per element (1-4)\n * @param {GLuint} type - type of values (e.g. gl.FLOAT)\n * @param {GLbool} normalized=false - normalize integers to [-1,1] or [0,1]\n * @param {GLuint} integer=false - WebGL2 only, int-to-float conversion\n * @param {GLuint} stride=0 - supports strided arrays\n * @param {GLuint} offset=0 - supports strided arrays\n */\nfunction BufferLayout() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      type = _ref.type,\n      _ref$size = _ref.size,\n      size = _ref$size === undefined ? 1 : _ref$size,\n      _ref$offset = _ref.offset,\n      offset = _ref$offset === undefined ? 0 : _ref$offset,\n      _ref$stride = _ref.stride,\n      stride = _ref$stride === undefined ? 0 : _ref$stride,\n      _ref$normalized = _ref.normalized,\n      normalized = _ref$normalized === undefined ? false : _ref$normalized,\n      _ref$integer = _ref.integer,\n      integer = _ref$integer === undefined ? false : _ref$integer,\n      _ref$instanced = _ref.instanced,\n      instanced = _ref$instanced === undefined ? 0 : _ref$instanced;\n\n  _classCallCheck(this, BufferLayout);\n\n  this.type = type;\n  this.size = size;\n  this.offset = offset;\n  this.stride = stride;\n  this.normalized = normalized;\n  this.integer = integer;\n  this.instanced = instanced;\n};\n\nvar Buffer =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Buffer, _Resource);\n\n  function Buffer(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Buffer); // In WebGL1, we need to make sure we use GL.ELEMENT_ARRAY_BUFFER when\n    // initializing element buffers, otherwise the buffer type will be locked\n    // to a generic (non-element) buffer.\n    // In WebGL2, we can use GL_COPY_READ_BUFFER which avoids locking the type here\n\n\n    var _this = _possibleConstructorReturn(this, (Buffer.__proto__ || Object.getPrototypeOf(Buffer)).call(this, gl, opts));\n\n    _this.target = opts.target || (_this.gl.webgl2 ? GL_COPY_READ_BUFFER : GL.ARRAY_BUFFER);\n    _this.index = null;\n\n    _this.setData(opts);\n\n    Object.seal(_this);\n    return _this;\n  } // Stores the layout of data with the buffer, makes it easy to e.g. set it as an attribute later\n\n\n  _createClass(Buffer, [{\n    key: 'setDataLayout',\n    value: function setDataLayout(_ref2) {\n      var layout = _ref2.layout,\n          type = _ref2.type,\n          _ref2$size = _ref2.size,\n          size = _ref2$size === undefined ? 1 : _ref2$size,\n          _ref2$offset = _ref2.offset,\n          offset = _ref2$offset === undefined ? 0 : _ref2$offset,\n          _ref2$stride = _ref2.stride,\n          stride = _ref2$stride === undefined ? 0 : _ref2$stride,\n          _ref2$normalized = _ref2.normalized,\n          normalized = _ref2$normalized === undefined ? false : _ref2$normalized,\n          _ref2$integer = _ref2.integer,\n          integer = _ref2$integer === undefined ? false : _ref2$integer,\n          _ref2$instanced = _ref2.instanced,\n          instanced = _ref2$instanced === undefined ? 0 : _ref2$instanced;\n      this.layout = layout || new BufferLayout({\n        type: type || this.type,\n        // Use autodeduced type if available\n        size: size,\n        offset: offset,\n        stride: stride,\n        normalized: normalized,\n        integer: integer,\n        instanced: instanced\n      });\n      return this;\n    } // Creates and initializes the buffer object's data store.\n\n  }, {\n    key: 'initialize',\n    value: function initialize() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          data = _ref3.data,\n          bytes = _ref3.bytes,\n          _ref3$usage = _ref3.usage,\n          usage = _ref3$usage === undefined ? GL.STATIC_DRAW : _ref3$usage,\n          layout = _ref3.layout,\n          type = _ref3.type,\n          _ref3$size = _ref3.size,\n          size = _ref3$size === undefined ? 1 : _ref3$size,\n          _ref3$offset = _ref3.offset,\n          offset = _ref3$offset === undefined ? 0 : _ref3$offset,\n          _ref3$stride = _ref3.stride,\n          stride = _ref3$stride === undefined ? 0 : _ref3$stride,\n          _ref3$normalized = _ref3.normalized,\n          normalized = _ref3$normalized === undefined ? false : _ref3$normalized,\n          _ref3$integer = _ref3.integer,\n          integer = _ref3$integer === undefined ? false : _ref3$integer,\n          _ref3$instanced = _ref3.instanced,\n          instanced = _ref3$instanced === undefined ? 0 : _ref3$instanced;\n\n      var opts = arguments[0];\n\n      if (!data) {\n        type = type || GL.FLOAT; // Workaround needed for Safari (#291):\n        // gl.bufferData with size (second argument) equal to 0 crashes.\n        // hence create zero sized array.\n\n        if (!bytes || bytes === 0) {\n          bytes = 0;\n          data = new Float32Array(0);\n        }\n      } else {\n        type = type || getGLTypeFromTypedArray(data);\n        bytes = data.byteLength;\n        assert(type, ERR_BUFFER_PARAMS);\n      }\n\n      this.bytes = bytes;\n      this.bytesUsed = bytes;\n      this.data = data;\n      this.type = type;\n      this.usage = usage; // Call after type is set\n\n      this.setDataLayout(Object.assign(opts)); // Create the buffer - binding it here for the first time locks the type\n      // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type\n\n      var target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;\n      this.gl.bindBuffer(target, this.handle);\n      this.gl.bufferData(target, data || bytes, usage);\n      this.gl.bindBuffer(target, null);\n      return this;\n    } // DEPRECATED - Can we change to call `subData`?\n\n  }, {\n    key: 'setData',\n    value: function setData(options) {\n      return this.initialize(options);\n    } // Updates a subset of a buffer object's data store.\n\n  }, {\n    key: 'subData',\n    value: function subData() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          data = _ref4.data,\n          _ref4$offset = _ref4.offset,\n          offset = _ref4$offset === undefined ? 0 : _ref4$offset,\n          _ref4$srcOffset = _ref4.srcOffset,\n          srcOffset = _ref4$srcOffset === undefined ? 0 : _ref4$srcOffset,\n          length = _ref4.length;\n\n      assert(data, ERR_BUFFER_PARAMS); // Create the buffer - binding it here for the first time locks the type\n      // In WebGL2, use GL_COPY_WRITE_BUFFER to avoid locking the type\n\n      var target = this.gl.webgl2 ? GL_COPY_WRITE_BUFFER : this.target;\n      this.gl.bindBuffer(target, this.handle); // WebGL2: subData supports additional srcOffset and length parameters\n\n      if (srcOffset !== 0 || length !== undefined) {\n        assertWebGL2Context(this.gl);\n        this.gl.bufferSubData(this.target, offset, data, srcOffset, length || 0);\n      } else {\n        this.gl.bufferSubData(target, offset, data);\n      }\n\n      this.gl.bindBuffer(target, null);\n      return this;\n    } // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n\n  }, {\n    key: 'copyData',\n    value: function copyData(_ref5) {\n      var sourceBuffer = _ref5.sourceBuffer,\n          _ref5$readOffset = _ref5.readOffset,\n          readOffset = _ref5$readOffset === undefined ? 0 : _ref5$readOffset,\n          _ref5$writeOffset = _ref5.writeOffset,\n          writeOffset = _ref5$writeOffset === undefined ? 0 : _ref5$writeOffset,\n          size = _ref5.size;\n      assertWebGL2Context(this.gl); // Use GL_COPY_READ_BUFFER+GL_COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n\n      this.gl.bindBuffer(GL_COPY_READ_BUFFER, sourceBuffer.handle);\n      this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, this.handle);\n      this.gl.copyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, readOffset, writeOffset, size);\n      this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);\n      this.gl.bindBuffer(GL_COPY_WRITE_BUFFER, null);\n      return this;\n    } // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n\n  }, {\n    key: 'getData',\n    value: function getData() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$dstData = _ref6.dstData,\n          dstData = _ref6$dstData === undefined ? null : _ref6$dstData,\n          _ref6$srcByteOffset = _ref6.srcByteOffset,\n          srcByteOffset = _ref6$srcByteOffset === undefined ? 0 : _ref6$srcByteOffset,\n          _ref6$dstOffset = _ref6.dstOffset,\n          dstOffset = _ref6$dstOffset === undefined ? 0 : _ref6$dstOffset,\n          _ref6$length = _ref6.length,\n          length = _ref6$length === undefined ? 0 : _ref6$length;\n\n      assertWebGL2Context(this.gl);\n      var ArrayType = getTypedArrayFromGLType(this.type, {\n        clamped: false\n      });\n\n      var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n      var dstAvailableElementCount = void 0;\n      var dstElementCount = void 0;\n      var dstElementOffset = dstOffset;\n\n      if (dstData) {\n        dstElementCount = dstData.length;\n        dstAvailableElementCount = dstElementCount - dstElementOffset;\n      } else {\n        // Allocate ArrayBufferView with enough size to copy all eligible data.\n        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);\n        dstElementCount = dstElementOffset + dstAvailableElementCount;\n      }\n\n      var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n      length = length || copyElementCount;\n      assert(length <= copyElementCount, 'Invalid srcByteOffset, dstOffset and length combination');\n      dstData = dstData || new ArrayType(dstElementCount); // Use GL_COPY_READ_BUFFER to avoid disturbing other targets and locking type\n\n      this.gl.bindBuffer(GL_COPY_READ_BUFFER, this.handle);\n      this.gl.getBufferSubData(GL_COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);\n      this.gl.bindBuffer(GL_COPY_READ_BUFFER, null);\n      return dstData;\n    }\n    /**\n     * Binds a buffer to a given binding point (target).\n     *   GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n     *\n     * @param {Glenum} target - target for the bind operation.\n     *\n     * @param {GLuint} index= - the index of the target.\n     *   - GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n     * @param {GLuint} offset=0 - the index of the target.\n     *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n     * @param {GLuint} size= - the index of the target.\n     *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n     * @returns {Buffer} - Returns itself for chaining.\n     */\n\n  }, {\n    key: 'bind',\n    value: function bind() {\n      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref7$target = _ref7.target,\n          target = _ref7$target === undefined ? this.target : _ref7$target,\n          _ref7$index = _ref7.index,\n          index = _ref7$index === undefined ? this.index : _ref7$index,\n          _ref7$offset = _ref7.offset,\n          offset = _ref7$offset === undefined ? 0 : _ref7$offset,\n          size = _ref7.size; // NOTE: While GL_TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n      // be used as direct binding points, they will not affect transform feedback or\n      // uniform buffer state. Instead indexed bindings need to be made.\n\n\n      var type = target === GL.UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER ? size !== undefined ? 'ranged' : ' indexed' : 'non-indexed';\n\n      switch (type) {\n        case 'non-indexed':\n          this.gl.bindBuffer(target, this.handle);\n          break;\n\n        case 'indexed':\n          assertWebGL2Context(this.gl);\n          assert(offset === 0, ERR_BUFFER_PARAMS); // Make sure offset wasn't supplied\n\n          this.gl.bindBufferBase(target, index, this.handle);\n          break;\n\n        case 'ranged':\n          assertWebGL2Context(this.gl);\n          this.gl.bindBufferRange(target, index, this.handle, offset, size);\n          break;\n\n        default:\n          throw new Error(ERR_BUFFER_PARAMS);\n      }\n\n      return this;\n    }\n  }, {\n    key: 'unbind',\n    value: function unbind() {\n      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref8$target = _ref8.target,\n          target = _ref8$target === undefined ? this.target : _ref8$target,\n          _ref8$index = _ref8.index,\n          index = _ref8$index === undefined ? this.index : _ref8$index;\n\n      var isIndexedBuffer = target === GL.UNIFORM_BUFFER || target === GL_TRANSFORM_FEEDBACK_BUFFER;\n\n      if (isIndexedBuffer) {\n        this.gl.bindBufferBase(target, index, null);\n      } else {\n        this.gl.bindBuffer(target, null);\n      }\n\n      return this;\n    } // TODO - is this the right place?\n    // gl.TRANSFORM_FEEDBACK_BUFFER_BINDING: Returns a WebGLBuffer.\n    // gl.TRANSFORM_FEEDBACK_BUFFER_SIZE: Returns a GLsizeiptr.\n    // gl.TRANSFORM_FEEDBACK_BUFFER_START: Returns a GLintptr.\n    // gl.UNIFORM_BUFFER_BINDING: Returns a WebGLBuffer.\n    // gl.UNIFORM_BUFFER_SIZE: Returns a GLsizeiptr.\n    // gl.UNIFORM_BUFFER_START: Returns a GLintptr.\n\n  }, {\n    key: 'getIndexedParameter',\n    value: function getIndexedParameter(binding, index) {\n      // Create the buffer - if binding it here for the first time, this locks the type\n      // In WebGL2, use GL_COPY_READ_BUFFER to avoid locking the type\n      var target = this.gl.webgl2 ? GL_COPY_READ_BUFFER : this.target;\n      this.gl.bindBuffer(target, index);\n      return this.gl.getIndexedParameter(binding, index);\n    } // RESOURCE METHODS\n\n  }, {\n    key: '_createHandle',\n    value: function _createHandle() {\n      return this.gl.createBuffer();\n    }\n  }, {\n    key: '_deleteHandle',\n    value: function _deleteHandle() {\n      this.gl.deleteBuffer(this.handle);\n    }\n  }, {\n    key: '_getParameter',\n    value: function _getParameter(pname) {\n      this.gl.bindBuffer(this.target, this.handle);\n      var value = this.gl.getBufferParameter(this.target, pname);\n      this.gl.bindBuffer(this.target, null);\n      return value;\n    }\n  }, {\n    key: '_getAvailableElementCount',\n    value: function _getAvailableElementCount(srcByteOffset) {\n      var ArrayType = getTypedArrayFromGLType(this.type, {\n        clamped: false\n      });\n      var sourceElementCount = this.bytes / ArrayType.BYTES_PER_ELEMENT;\n      var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n      return sourceElementCount - sourceElementOffset;\n    }\n  }]);\n\n  return Buffer;\n}(Resource);\n\nexport default Buffer;","map":null,"metadata":{},"sourceType":"module"}