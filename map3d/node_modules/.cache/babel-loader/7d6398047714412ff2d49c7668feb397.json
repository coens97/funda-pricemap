{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { Layer } from '@deck.gl/core';\nimport GL from 'luma.gl/constants';\nimport { Model, Geometry, fp64 } from 'luma.gl';\nvar fp64LowPart = fp64.fp64LowPart;\nimport vs from './path-layer-vertex.glsl';\nimport vs64 from './path-layer-vertex-64.glsl';\nimport fs from './path-layer-fragment.glsl';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  widthScale: 1,\n  // stroke width in meters\n  widthMinPixels: 0,\n  //  min stroke width in pixels\n  widthMaxPixels: Number.MAX_SAFE_INTEGER,\n  // max stroke width in pixels\n  rounded: false,\n  miterLimit: 4,\n  fp64: false,\n  dashJustified: false,\n  getPath: function getPath(object) {\n    return object.path;\n  },\n  getColor: DEFAULT_COLOR,\n  getWidth: 1,\n  getDashArray: null\n};\n\nvar isClosed = function isClosed(path) {\n  var firstPoint = path[0];\n  var lastPoint = path[path.length - 1];\n  return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];\n};\n\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar PathLayer =\n/*#__PURE__*/\nfunction (_Layer) {\n  _inherits(PathLayer, _Layer);\n\n  function PathLayer() {\n    _classCallCheck(this, PathLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathLayer).apply(this, arguments));\n  }\n\n  _createClass(PathLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return this.use64bitProjection() ? {\n        vs: vs64,\n        fs: fs,\n        modules: ['project64', 'picking']\n      } : {\n        vs: vs,\n        fs: fs,\n        modules: ['picking']\n      }; // 'project' module added by default.\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var attributeManager = this.getAttributeManager();\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instanceStartPositions: {\n          size: 3,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateStartPositions\n        },\n        instanceEndPositions: {\n          size: 3,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateEndPositions\n        },\n        instanceStartEndPositions64xyLow: {\n          size: 4,\n          update: this.calculateInstanceStartEndPositions64xyLow\n        },\n        instanceLeftDeltas: {\n          size: 3,\n          update: this.calculateLeftDeltas\n        },\n        instanceRightDeltas: {\n          size: 3,\n          update: this.calculateRightDeltas\n        },\n        instanceStrokeWidths: {\n          size: 1,\n          accessor: 'getWidth',\n          transition: ATTRIBUTE_TRANSITION,\n          update: this.calculateStrokeWidths,\n          defaultValue: 1\n        },\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray',\n          update: this.calculateDashArrays\n        },\n        instanceColors: {\n          size: 4,\n          type: GL.UNSIGNED_BYTE,\n          accessor: 'getColor',\n          transition: ATTRIBUTE_TRANSITION,\n          update: this.calculateColors,\n          defaultValue: DEFAULT_COLOR\n        },\n        instancePickingColors: {\n          size: 3,\n          type: GL.UNSIGNED_BYTE,\n          update: this.calculatePickingColors\n        }\n      });\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      _get(_getPrototypeOf(PathLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      var getPath = this.props.getPath;\n      var attributeManager = this.getAttributeManager();\n\n      if (props.fp64 !== oldProps.fp64) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model.delete();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        attributeManager.invalidateAll();\n      }\n\n      var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n      if (geometryChanged) {\n        // this.state.paths only stores point positions in each path\n        var paths = props.data.map(getPath);\n        var bufferLayout = paths.map(function (path) {\n          return path.length - 1;\n        });\n        var numInstances = bufferLayout.reduce(function (count, segments) {\n          return count + segments;\n        }, 0);\n        this.setState({\n          paths: paths,\n          numInstances: numInstances,\n          bufferLayout: bufferLayout\n        });\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props = this.props,\n          rounded = _this$props.rounded,\n          miterLimit = _this$props.miterLimit,\n          widthScale = _this$props.widthScale,\n          widthMinPixels = _this$props.widthMinPixels,\n          widthMaxPixels = _this$props.widthMaxPixels,\n          dashJustified = _this$props.dashJustified;\n      this.state.model.render(Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        alignMode: Number(dashJustified),\n        widthScale: widthScale,\n        miterLimit: miterLimit,\n        widthMinPixels: widthMinPixels,\n        widthMaxPixels: widthMaxPixels\n      }));\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      /*\n       *       _\n       *        \"-_ 1                   3                       5\n       *     _     \"o---------------------o-------------------_-o\n       *       -   / \"\"--..__              '.             _.-' /\n       *   _     \"@- - - - - \"\"--..__- - - - x - - - -_.@'    /\n       *    \"-_  /                   \"\"--..__ '.  _,-` :     /\n       *       \"o----------------------------\"\"-o'    :     /\n       *      0,2                            4 / '.  :     /\n       *                                      /   '.:     /\n       *                                     /     :'.   /\n       *                                    /     :  ', /\n       *                                   /     :     o\n       */\n      var SEGMENT_INDICES = [// start corner\n      0, 2, 1, // body\n      1, 2, 4, 1, 4, 3, // end corner\n      3, 4, 5]; // [0] position on segment - 0: start, 1: end\n      // [1] side of path - -1: left, 0: center, 1: right\n      // [2] role - 0: offset point 1: joint point\n\n      var SEGMENT_POSITIONS = [// bevel start corner\n      0, 0, 1, // start inner corner\n      0, -1, 0, // start outer corner\n      0, 1, 0, // end inner corner\n      1, -1, 0, // end outer corner\n      1, 1, 0, // bevel end corner\n      1, 0, 1];\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: GL.TRIANGLES,\n          attributes: {\n            indices: new Uint16Array(SEGMENT_INDICES),\n            positions: new Float32Array(SEGMENT_POSITIONS)\n          }\n        }),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      }));\n    } // \"Experimental\" method indended to make it easier to support non-nested arrays in subclasses\n\n  }, {\n    key: \"_getPathLength\",\n    value: function _getPathLength(path) {\n      return path.length;\n    }\n  }, {\n    key: \"calculateStartPositions\",\n    value: function calculateStartPositions(attribute) {\n      var _this$state = this.state,\n          paths = _this$state.paths,\n          bufferLayout = _this$state.bufferLayout;\n      var value = attribute.value;\n      attribute.bufferLayout = bufferLayout;\n      var i = 0;\n      paths.forEach(function (path) {\n        var numSegments = path.length - 1;\n\n        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n          var point = path[ptIndex];\n          value[i++] = point[0];\n          value[i++] = point[1];\n          value[i++] = point[2] || 0;\n        }\n      });\n    }\n  }, {\n    key: \"calculateEndPositions\",\n    value: function calculateEndPositions(attribute) {\n      var _this$state2 = this.state,\n          paths = _this$state2.paths,\n          bufferLayout = _this$state2.bufferLayout;\n      var value = attribute.value;\n      attribute.bufferLayout = bufferLayout;\n      var i = 0;\n      paths.forEach(function (path) {\n        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {\n          var point = path[ptIndex];\n          value[i++] = point[0];\n          value[i++] = point[1];\n          value[i++] = point[2] || 0;\n        }\n      });\n    }\n  }, {\n    key: \"calculateInstanceStartEndPositions64xyLow\",\n    value: function calculateInstanceStartEndPositions64xyLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(4);\n        return;\n      }\n\n      var paths = this.state.paths;\n      var value = attribute.value;\n      var i = 0;\n      paths.forEach(function (path) {\n        var numSegments = path.length - 1;\n\n        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n          var startPoint = path[ptIndex];\n          var endPoint = path[ptIndex + 1];\n          value[i++] = fp64LowPart(startPoint[0]);\n          value[i++] = fp64LowPart(startPoint[1]);\n          value[i++] = fp64LowPart(endPoint[0]);\n          value[i++] = fp64LowPart(endPoint[1]);\n        }\n      });\n    }\n  }, {\n    key: \"calculateLeftDeltas\",\n    value: function calculateLeftDeltas(attribute) {\n      var paths = this.state.paths;\n      var value = attribute.value;\n      var i = 0;\n      paths.forEach(function (path) {\n        var numSegments = path.length - 1;\n        var prevPoint = isClosed(path) ? path[path.length - 2] : path[0];\n\n        for (var ptIndex = 0; ptIndex < numSegments; ptIndex++) {\n          var point = path[ptIndex];\n          value[i++] = point[0] - prevPoint[0];\n          value[i++] = point[1] - prevPoint[1];\n          value[i++] = point[2] - prevPoint[2] || 0;\n          prevPoint = point;\n        }\n      });\n    }\n  }, {\n    key: \"calculateRightDeltas\",\n    value: function calculateRightDeltas(attribute) {\n      var paths = this.state.paths;\n      var value = attribute.value;\n      var i = 0;\n      paths.forEach(function (path) {\n        for (var ptIndex = 1; ptIndex < path.length; ptIndex++) {\n          var point = path[ptIndex];\n          var nextPoint = path[ptIndex + 1];\n\n          if (!nextPoint) {\n            nextPoint = isClosed(path) ? path[1] : point;\n          }\n\n          value[i++] = nextPoint[0] - point[0];\n          value[i++] = nextPoint[1] - point[1];\n          value[i++] = nextPoint[2] - point[2] || 0;\n        }\n      });\n    }\n  }, {\n    key: \"calculateStrokeWidths\",\n    value: function calculateStrokeWidths(attribute) {\n      var _this = this;\n\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getWidth = _this$props2.getWidth;\n      var _this$state3 = this.state,\n          paths = _this$state3.paths,\n          bufferLayout = _this$state3.bufferLayout;\n      var value = attribute.value;\n      attribute.bufferLayout = bufferLayout;\n      var i = 0;\n      paths.forEach(function (path, index) {\n        var width = getWidth(data[index], index);\n\n        var pathLength = _this._getPathLength(path);\n\n        for (var ptIndex = 1; ptIndex < pathLength; ptIndex++) {\n          value[i++] = width;\n        }\n      });\n    }\n  }, {\n    key: \"calculateDashArrays\",\n    value: function calculateDashArrays(attribute) {\n      var _this2 = this;\n\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          getDashArray = _this$props3.getDashArray;\n\n      if (!getDashArray) {\n        return;\n      }\n\n      var paths = this.state.paths;\n      var value = attribute.value;\n      var i = 0;\n      paths.forEach(function (path, index) {\n        var dashArray = getDashArray(data[index], index);\n\n        var pathLength = _this2._getPathLength(path);\n\n        for (var ptIndex = 1; ptIndex < pathLength; ptIndex++) {\n          value[i++] = dashArray[0];\n          value[i++] = dashArray[1];\n        }\n      });\n    }\n  }, {\n    key: \"calculateColors\",\n    value: function calculateColors(attribute) {\n      var _this3 = this;\n\n      var _this$props4 = this.props,\n          data = _this$props4.data,\n          getColor = _this$props4.getColor;\n      var _this$state4 = this.state,\n          paths = _this$state4.paths,\n          bufferLayout = _this$state4.bufferLayout;\n      var value = attribute.value;\n      attribute.bufferLayout = bufferLayout;\n      var i = 0;\n      paths.forEach(function (path, index) {\n        var pointColor = getColor(data[index], index);\n\n        if (isNaN(pointColor[3])) {\n          pointColor[3] = 255;\n        }\n\n        var pathLength = _this3._getPathLength(path);\n\n        for (var ptIndex = 1; ptIndex < pathLength; ptIndex++) {\n          value[i++] = pointColor[0];\n          value[i++] = pointColor[1];\n          value[i++] = pointColor[2];\n          value[i++] = pointColor[3];\n        }\n      });\n    } // Override the default picking colors calculation\n\n  }, {\n    key: \"calculatePickingColors\",\n    value: function calculatePickingColors(attribute) {\n      var _this4 = this;\n\n      var paths = this.state.paths;\n      var value = attribute.value;\n      var i = 0;\n      paths.forEach(function (path, index) {\n        var pickingColor = _this4.encodePickingColor(index);\n\n        var pathLength = _this4._getPathLength(path);\n\n        for (var ptIndex = 1; ptIndex < pathLength; ptIndex++) {\n          value[i++] = pickingColor[0];\n          value[i++] = pickingColor[1];\n          value[i++] = pickingColor[2];\n        }\n      });\n    }\n  }]);\n\n  return PathLayer;\n}(Layer);\n\nexport { PathLayer as default };\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}