{"ast":null,"code":"import assert from 'assert';\nimport { Matrix4 } from 'math.gl';\nimport { fp64 as fp64Utils } from 'luma.gl';\nimport { COORDINATE_SYSTEM } from '../../../lib/constants';\nvar fp64LowPart = fp64Utils.fp64LowPart;\nvar R_EARTH = 6378000; // Takes data and aggregation params and returns aggregated data.\n\nexport function pointToDensityGridData(_ref) {\n  var data = _ref.data,\n      getPosition = _ref.getPosition,\n      cellSizeMeters = _ref.cellSizeMeters,\n      gpuGridAggregator = _ref.gpuGridAggregator,\n      gpuAggregation = _ref.gpuAggregation,\n      _ref$fp = _ref.fp64,\n      fp64 = _ref$fp === void 0 ? false : _ref$fp,\n      _ref$coordinateSystem = _ref.coordinateSystem,\n      coordinateSystem = _ref$coordinateSystem === void 0 ? COORDINATE_SYSTEM.LNGLAT : _ref$coordinateSystem,\n      _ref$viewport = _ref.viewport,\n      viewport = _ref$viewport === void 0 ? null : _ref$viewport;\n\n  var gridData = _parseGridData(data, getPosition);\n\n  var cellSize = [cellSizeMeters, cellSizeMeters];\n  var worldOrigin = [0, 0];\n  assert(coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.IDENTITY);\n\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n    // TODO: also for COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL ?\n    var gridOffset = _getGridOffset(gridData, cellSizeMeters);\n\n    cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n    worldOrigin = [-180, -90]; // Origin used to define grid cell boundaries\n  } else {\n    // Other co-ordiante sytems are not verified yet.\n    assert(coordinateSystem === COORDINATE_SYSTEM.IDENTITY);\n    var width = viewport.width,\n        height = viewport.height;\n    worldOrigin = [-width / 2, -height / 2]; // Origin used to define grid cell boundaries\n  }\n\n  var opts = _getGPUAggregationParams({\n    gridData: gridData,\n    cellSize: cellSize,\n    worldOrigin: worldOrigin\n  });\n\n  var aggregatedData = gpuGridAggregator.run({\n    positions: gridData.positions,\n    positions64xyLow: gridData.positions64xyLow,\n    weights: gridData.weights,\n    cellSize: cellSize,\n    width: opts.width,\n    height: opts.height,\n    gridTransformMatrix: opts.gridTransformMatrix,\n    useGPU: gpuAggregation,\n    fp64: fp64\n  });\n  return {\n    countsBuffer: aggregatedData.countsBuffer,\n    maxCountBuffer: aggregatedData.maxCountBuffer,\n    countsData: aggregatedData.countsData,\n    maxCountData: aggregatedData.maxCountData,\n    gridSize: opts.gridSize,\n    gridOrigin: opts.gridOrigin,\n    cellSize: cellSize\n  };\n} // Parse input data to build positions, wights and bounding box.\n\nfunction _parseGridData(data, getPosition) {\n  var getWeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  assert(data && getPosition);\n  var positions = [];\n  var positions64xyLow = [];\n  var weights = [];\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var y;\n  var x;\n\n  for (var p = 0; p < data.length; p++) {\n    var position = getPosition(data[p]);\n    x = position[0];\n    y = position[1];\n    positions.push(x, y);\n    positions64xyLow.push(fp64LowPart(x), fp64LowPart(y));\n    var weight = getWeight ? getWeight(data[p]) : 1.0;\n    weights.push(weight);\n\n    if (Number.isFinite(y) && Number.isFinite(x)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  return {\n    positions: positions,\n    positions64xyLow: positions64xyLow,\n    weights: weights,\n    yMin: yMin,\n    yMax: yMax,\n    xMin: xMin,\n    xMax: xMax\n  };\n}\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} gridData - contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @returns {yOffset, xOffset} - cellSize size lng/lat (degree) space.\n */\n\n\nfunction _getGridOffset(gridData, cellSize) {\n  var yMin = gridData.yMin,\n      yMax = gridData.yMax;\n  var latMin = yMin;\n  var latMax = yMax;\n  var centerLat = (latMin + latMax) / 2;\n  return _calculateGridLatLonOffset(cellSize, centerLat);\n}\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\n\n\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  var yOffset = _calculateLatOffset(cellSize);\n\n  var xOffset = _calculateLonOffset(latitude, cellSize);\n\n  return {\n    yOffset: yOffset,\n    xOffset: xOffset\n  };\n}\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\n\n\nfunction _calculateLatOffset(dy) {\n  return dy / R_EARTH * (180 / Math.PI);\n}\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\n\n\nfunction _calculateLonOffset(lat, dx) {\n  return dx / R_EARTH * (180 / Math.PI) / Math.cos(lat * Math.PI / 180);\n} // Aligns `inValue` to given `cellSize`\n\n\nexport function _alignToCell(inValue, cellSize) {\n  var sign = inValue < 0 ? -1 : 1;\n  var value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n  value = Math.floor(value / cellSize) * cellSize;\n  return value * sign;\n} // Calculate grid parameters\n\nfunction _getGPUAggregationParams(_ref2) {\n  var gridData = _ref2.gridData,\n      cellSize = _ref2.cellSize,\n      worldOrigin = _ref2.worldOrigin;\n  var yMin = gridData.yMin,\n      yMax = gridData.yMax,\n      xMin = gridData.xMin,\n      xMax = gridData.xMax; // NOTE: this alignment will match grid cell boundaries with existing CPU implementation\n  // this gurantees identical aggregation results when switching between CPU and GPU aggregation.\n  // Also gurantees same cell boundaries, when overlapping between two different layers (like ScreenGrid and Contour)\n  // We first move worldOrigin to [0, 0], align the lower bounding box , then move worldOrigin to its original value.\n\n  var originX = _alignToCell(xMin - worldOrigin[0], cellSize[0]) + worldOrigin[0];\n  var originY = _alignToCell(yMin - worldOrigin[1], cellSize[1]) + worldOrigin[1]; // Setup transformation matrix so that every point is in +ve range\n\n  var gridTransformMatrix = new Matrix4().translate([-1 * originX, -1 * originY, 0]); // const cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n\n  var gridOrigin = [originX, originY];\n  var width = xMax - xMin + cellSize[0];\n  var height = yMax - yMin + cellSize[1];\n  var gridSize = [Math.ceil(width / cellSize[0]), Math.ceil(height / cellSize[1])];\n  return {\n    gridOrigin: gridOrigin,\n    gridSize: gridSize,\n    width: width,\n    height: height,\n    gridTransformMatrix: gridTransformMatrix\n  };\n}","map":null,"metadata":{},"sourceType":"module"}