{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return _get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n/* eslint-disable no-inline-comments */\n\n\nimport GL from '../constants';\nimport VertexArray from './vertex-array';\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport { parseUniformName, getUniformSetter } from './uniforms';\nimport { VertexShader, FragmentShader } from './shader';\nimport Buffer from './buffer';\nimport { withParameters } from '../webgl-context/context-state';\nimport { assertWebGL2Context, isWebGL2 } from '../webgl-utils';\nimport { getPrimitiveDrawMode } from '../webgl-utils/attribute-utils';\nimport { log, uid, isObjectEmpty } from '../utils';\nimport assert from '../utils/assert';\nvar LOG_PROGRAM_PERF_PRIORITY = 3; // const GL_TRANSFORM_FEEDBACK_BUFFER_MODE = 0x8C7F;\n// const GL_TRANSFORM_FEEDBACK_VARYINGS = 0x8C83;\n// MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS : 0x8C80,\n// TRANSFORM_FEEDBACK_BUFFER_START: 0x8C84,\n// TRANSFORM_FEEDBACK_BUFFER_SIZE : 0x8C85,\n// TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8C88,\n// MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8C8A,\n// MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8C8B,\n\nvar GL_INTERLEAVED_ATTRIBS = 0x8C8C;\nvar GL_SEPARATE_ATTRIBS = 0x8C8D;\n\nvar Program =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Program, _Resource);\n\n  function Program(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Program);\n\n    _this = _possibleConstructorReturn(this, (Program.__proto__ || Object.getPrototypeOf(Program)).call(this, gl, opts));\n\n    _this.initialize(opts);\n\n    _this.vertexAttributes = VertexArray.getDefaultArray(gl);\n    Object.seal(_assertThisInitialized(_this));\n\n    _this._setId(opts.id);\n\n    return _this;\n  }\n\n  _createClass(Program, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          vs = _ref.vs,\n          fs = _ref.fs,\n          defaultUniforms = _ref.defaultUniforms,\n          varyings = _ref.varyings,\n          _ref$bufferMode = _ref.bufferMode,\n          bufferMode = _ref$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _ref$bufferMode; // Create shaders if needed\n\n\n      this.vs = typeof vs === 'string' ? new VertexShader(this.gl, vs) : vs;\n      this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, fs) : fs;\n      assert(_instanceof(this.vs, VertexShader), 'Program: bad vertex shader');\n      assert(_instanceof(this.fs, FragmentShader), 'Program: bad fragment shader');\n      this.defaultUniforms = defaultUniforms; // Setup varyings if supplied\n\n      if (varyings) {\n        assertWebGL2Context(this.gl);\n        this.varyings = varyings;\n        this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n        this.varyingMap = getVaryingMap(varyings, bufferMode);\n      } else {\n        this.varyingMap = {};\n      }\n\n      this._compileAndLink(); // Experimental flag to avoid deleting Program object while it is cached\n\n\n      this._isCached = false;\n      return this;\n    } // Generates warning if a vertex shader attribute is not setup.\n\n  }, {\n    key: \"checkAttributeBindings\",\n    value: function checkAttributeBindings(_ref2) {\n      var vertexArray = _ref2.vertexArray;\n      var filledLocations = vertexArray ? vertexArray.filledLocations : this.vertexAttributes.filledLocations;\n\n      for (var attributeName in this._attributeToLocationMap) {\n        var location = this._attributeToLocationMap[attributeName];\n\n        if (!filledLocations[location] && !this._warnedLocations[location]) {\n          // throw new Error(`Program ${this.id}: ` +\n          //   `Attribute ${location}:${attributeName} not supplied`);\n          log.warn(\"Program \".concat(this.id, \": Attribute \").concat(location, \":\").concat(attributeName, \" not supplied\"))();\n          this._warnedLocations[location] = true;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._isCached) {\n        // This object is cached, do not delete\n        return this;\n      }\n\n      return _get(Program.prototype.__proto__ || Object.getPrototypeOf(Program.prototype), \"delete\", this).call(this, opts);\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.unsetBuffers(); // TODO - reset uniforms and attributes to initial state\n    }\n  }, {\n    key: \"use\",\n    value: function use() {\n      this.gl.useProgram(this.handle);\n      return this;\n    } // A good thing about webGL is that there are so many ways to draw things,\n    // e.g. depending on whether data is indexed and/or isInstanced.\n    // This function unifies those into a single call with simple parameters\n    // that have sane defaults.\n\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var _this2 = this;\n\n      var _ref3$drawMode = _ref3.drawMode,\n          drawMode = _ref3$drawMode === void 0 ? GL.TRIANGLES : _ref3$drawMode,\n          vertexCount = _ref3.vertexCount,\n          _ref3$offset = _ref3.offset,\n          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n          start = _ref3.start,\n          end = _ref3.end,\n          _ref3$isIndexed = _ref3.isIndexed,\n          isIndexed = _ref3$isIndexed === void 0 ? false : _ref3$isIndexed,\n          _ref3$indexType = _ref3.indexType,\n          indexType = _ref3$indexType === void 0 ? GL.UNSIGNED_SHORT : _ref3$indexType,\n          _ref3$isInstanced = _ref3.isInstanced,\n          isInstanced = _ref3$isInstanced === void 0 ? false : _ref3$isInstanced,\n          _ref3$instanceCount = _ref3.instanceCount,\n          instanceCount = _ref3$instanceCount === void 0 ? 0 : _ref3$instanceCount,\n          _ref3$vertexArray = _ref3.vertexArray,\n          vertexArray = _ref3$vertexArray === void 0 ? null : _ref3$vertexArray,\n          _ref3$transformFeedba = _ref3.transformFeedback,\n          transformFeedback = _ref3$transformFeedba === void 0 ? null : _ref3$transformFeedba,\n          _ref3$uniforms = _ref3.uniforms,\n          uniforms = _ref3$uniforms === void 0 ? {} : _ref3$uniforms,\n          _ref3$samplers = _ref3.samplers,\n          samplers = _ref3$samplers === void 0 ? {} : _ref3$samplers,\n          _ref3$parameters = _ref3.parameters,\n          parameters = _ref3$parameters === void 0 ? {} : _ref3$parameters;\n      vertexArray = vertexArray || VertexArray.getDefaultArray(this.gl);\n      vertexArray.bind(function () {\n        _this2.gl.useProgram(_this2.handle);\n\n        if (transformFeedback) {\n          var primitiveMode = getPrimitiveDrawMode(drawMode);\n          transformFeedback.begin(primitiveMode);\n        }\n\n        _this2.setUniforms(uniforms, samplers);\n\n        withParameters(_this2.gl, parameters, function () {\n          // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension\n          if (isIndexed && isInstanced) {\n            _this2.ext.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n          } else if (isIndexed && isWebGL2(_this2.gl) && !isNaN(start) && !isNaN(end)) {\n            _this2.gl.drawElementsRange(drawMode, start, end, vertexCount, indexType, offset);\n          } else if (isIndexed) {\n            _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);\n          } else if (isInstanced) {\n            _this2.ext.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n          } else {\n            _this2.gl.drawArrays(drawMode, offset, vertexCount);\n          }\n        }); // this.gl.useProgram(null);\n\n        if (transformFeedback) {\n          transformFeedback.end();\n        }\n      });\n      return this;\n    }\n    /**\n     * Attach a map of Buffers values to a program\n     * Only attributes with names actually present in the linked program\n     * will be updated. Other supplied buffers will be ignored.\n     *\n     * @param {Object} attributes - An object map with attribute names being keys\n     *  and values are expected to be instances of Attribute.\n     * @returns {Program} Returns itself for chaining.\n     */\n\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attributes) {\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref4$clear = _ref4.clear,\n          clear = _ref4$clear === void 0 ? true : _ref4$clear,\n          _ref4$drawParams = _ref4.drawParams,\n          drawParams = _ref4$drawParams === void 0 ? {} : _ref4$drawParams;\n\n      if (clear) {\n        this.vertexAttributes.clearBindings();\n      } // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER\n      // index type is saved for drawElement calls\n\n\n      drawParams.isInstanced = false;\n      drawParams.isIndexed = false;\n      drawParams.indexType = null;\n\n      var _sortBuffersByLocatio = this._sortBuffersByLocation(attributes),\n          locations = _sortBuffersByLocatio.locations,\n          elements = _sortBuffersByLocatio.elements; // Process locations in order\n\n\n      for (var location = 0; location < locations.length; ++location) {\n        var attributeName = locations[location];\n        var attribute = attributes[attributeName]; // DISABLE MISSING ATTRIBUTE\n\n        if (!attribute) {\n          this.vertexAttributes.disable(location);\n        } else if (attribute.isGeneric) {\n          this._setAttributeToGeneric({\n            location: location,\n            array: attribute.value\n          });\n        } else {\n          this._setAttributeToBuffer({\n            location: location,\n            buffer: attribute.getBuffer(),\n            layout: attribute\n          });\n\n          Object.assign(drawParams, {\n            isInstanced: attribute.instanced > 0\n          });\n        }\n      } // SET ELEMENTS ARRAY BUFFER\n\n\n      if (elements) {\n        var _attribute = attributes[elements];\n\n        _attribute.getBuffer().bind();\n\n        drawParams.isIndexed = true;\n        drawParams.indexType = _attribute.type;\n      }\n\n      return this;\n    }\n    /**\n     * Attach a map of Buffers values to a program\n     * Only attributes with names actually present in the linked program\n     * will be updated. Other supplied buffers will be ignored.\n     *\n     * @param {Object} buffers - An object map with attribute names being keys\n     *  and values are expected to be instances of Buffer.\n     * @returns {Program} Returns itself for chaining.\n     */\n\n    /* eslint-disable max-statements */\n\n  }, {\n    key: \"setBuffers\",\n    value: function setBuffers(buffers) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref5$clear = _ref5.clear,\n          clear = _ref5$clear === void 0 ? true : _ref5$clear,\n          _ref5$drawParams = _ref5.drawParams,\n          drawParams = _ref5$drawParams === void 0 ? {} : _ref5$drawParams;\n\n      log.deprecated('Program: `setBuffers`', '`setAttributes`');\n\n      if (clear) {\n        this.vertexAttributes.clearBindings();\n      } // indexing is autodetected - buffer with target gl.ELEMENT_ARRAY_BUFFER\n      // index type is saved for drawElement calls\n\n\n      drawParams.isInstanced = false;\n      drawParams.isIndexed = false;\n      drawParams.indexType = null;\n\n      var _sortBuffersByLocatio2 = this._sortBuffersByLocation(buffers),\n          locations = _sortBuffersByLocatio2.locations,\n          elements = _sortBuffersByLocatio2.elements; // Process locations in order\n\n\n      for (var location = 0; location < locations.length; ++location) {\n        var bufferName = locations[location];\n        var buffer = buffers[bufferName]; // DISABLE MISSING ATTRIBUTE\n\n        if (!buffer) {\n          this.vertexAttributes.disable(location);\n        } else if (_instanceof(buffer, Buffer)) {\n          this._setAttributeToBuffer({\n            location: location,\n            buffer: buffer,\n            layout: buffer.layout\n          });\n\n          Object.assign(drawParams, {\n            isInstanced: buffer.layout.instanced > 0\n          });\n        } else {\n          this._setAttributeToGeneric({\n            location: location,\n            array: buffer\n          });\n        }\n      } // SET ELEMENTS ARRAY BUFFER\n\n\n      if (elements) {\n        var _buffer = buffers[elements];\n\n        _buffer.bind();\n\n        drawParams.isIndexed = true;\n        drawParams.indexType = _buffer.layout.type;\n      }\n\n      return this;\n    }\n    /* eslint-enable max-statements */\n\n    /*\n     * @returns {Program} Returns itself for chaining.\n     */\n\n  }, {\n    key: \"unsetBuffers\",\n    value: function unsetBuffers() {\n      var length = this._attributeCount;\n\n      for (var i = 1; i < length; ++i) {\n        // this.vertexAttributes.setDivisor(i, 0);\n        this.vertexAttributes.disable(i);\n      } // Clear elements buffer\n\n\n      this.gl.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, null);\n      return this;\n    }\n    /**\n     * Apply a set of uniform values to a program\n     * Only uniforms with names actually present in the linked program\n     * will be updated.\n     * other uniforms will be ignored\n     *\n     * @param {Object} uniformMap - An object with names being keys\n     * @returns {Program} - returns itself for chaining.\n     */\n\n    /* eslint-disable max-depth */\n\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(uniforms) {\n      var samplers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      for (var uniformName in uniforms) {\n        var uniform = uniforms[uniformName];\n        var uniformSetter = this._uniformSetters[uniformName];\n        var sampler = samplers[uniformName];\n\n        if (uniformSetter) {\n          if (_instanceof(uniform, Framebuffer)) {\n            uniform = uniform.texture;\n          }\n\n          if (_instanceof(uniform, Texture)) {\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            } // Bind texture to index\n\n\n            var texture = uniform;\n            var textureIndex = uniformSetter.textureIndex;\n            texture.bind(textureIndex); // Bind a sampler (if supplied) to index\n\n            if (sampler) {\n              sampler.bind(textureIndex);\n            } // Set the uniform sampler to the texture index\n\n\n            uniformSetter(textureIndex);\n          } else {\n            // Just set the value\n            uniformSetter(uniform);\n          }\n        }\n      }\n\n      return this;\n    }\n    /* eslint-enable max-depth */\n    // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)\n\n  }, {\n    key: \"uniformBlockBinding\",\n    value: function uniformBlockBinding(blockIndex, blockBinding) {\n      assertWebGL2Context(this.gl);\n      this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n    } // setTransformFeedbackBuffers(buffers) {\n    //   for (const buffer of buffers) {\n    //     buffer.bindBase()\n    //   }\n    // }\n\n    /**\n     * ATTRIBUTES API\n     * (Locations are numeric indices)\n     * @return {Number} count\n     */\n\n  }, {\n    key: \"getAttributeCount\",\n    value: function getAttributeCount() {\n      return this._getParameter(GL.ACTIVE_ATTRIBUTES);\n    }\n    /**\n     * Returns location (index) of a name\n     * @param {String} attributeName - name of an attribute\n     *   (matches name in a linked shader)\n     * @returns {Number} - // array of actual attribute names from shader linking\n     */\n\n  }, {\n    key: \"getAttributeLocation\",\n    value: function getAttributeLocation(attributeName) {\n      return this.gl.getAttribLocation(this.handle, attributeName);\n    }\n    /**\n     * Returns an object with info about attribute at index \"location\"/\n     * @param {int} location - index of an attribute\n     * @returns {WebGLActiveInfo} - info about an active attribute\n     *   fields: {name, size, type}\n     */\n\n  }, {\n    key: \"getAttributeInfo\",\n    value: function getAttributeInfo(location) {\n      return this.gl.getActiveAttrib(this.handle, location);\n    }\n    /**\n     * UNIFORMS API\n     * (Locations are numeric indices)\n     * @return {Number} count\n     */\n\n  }, {\n    key: \"getUniformCount\",\n    value: function getUniformCount() {\n      return this._getParameter(GL.ACTIVE_UNIFORMS);\n    }\n    /*\n     * @returns {WebGLActiveInfo} - object with {name, size, type}\n     */\n\n  }, {\n    key: \"getUniformInfo\",\n    value: function getUniformInfo(index) {\n      return this.gl.getActiveUniform(this.handle, index);\n    }\n    /*\n     * @returns {WebGLUniformLocation} - opaque object representing location\n     * of uniform, used by setter methods\n     */\n\n  }, {\n    key: \"getUniformLocation\",\n    value: function getUniformLocation(name) {\n      return this.gl.getUniformLocation(this.handle, name);\n    }\n  }, {\n    key: \"getUniformValue\",\n    value: function getUniformValue(location) {\n      return this.gl.getUniform(this.handle, location);\n    }\n    /* eslint-disable max-len */\n    // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)\n    // For valid `pname` values check :\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms\n\n  }, {\n    key: \"getActiveUniforms\",\n    value: function getActiveUniforms(uniformIndices, pname) {\n      return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);\n    }\n    /* eslint-enable max-len */\n    // WebGL2\n\n    /**\n     * @param {GLuint} index\n     * @return {WebGLActiveInfo} - object with {name, size, type}\n     */\n\n  }, {\n    key: \"getVarying\",\n    value: function getVarying(program, index) {\n      var result = this.gl.getTransformFeedbackVarying(program, index);\n      return result;\n    } // Retrieves the assigned color number binding for the user-defined varying\n    // out variable name for program. program must have previously been linked.\n\n  }, {\n    key: \"getFragDataLocation\",\n    value: function getFragDataLocation(varyingName) {\n      assertWebGL2Context(this.gl);\n      return this.gl.getFragDataLocation(this.handle, varyingName);\n    } // @returns {WebGLShader[]} - array of attached WebGLShader objects\n\n  }, {\n    key: \"getAttachedShaders\",\n    value: function getAttachedShaders() {\n      return this.gl.getAttachedShaders(this.handle);\n    } // Retrieves the index of a uniform block\n\n  }, {\n    key: \"getUniformBlockIndex\",\n    value: function getUniformBlockIndex(blockName) {\n      assertWebGL2Context(this.gl);\n      return this.gl.getUniformBlockIndex(this.handle, blockName);\n    }\n    /* eslint-disable max-len */\n    // Retrieves information about an active uniform block (`blockIndex`)\n    // For valid `pname` values check :\n    // https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter\n\n  }, {\n    key: \"getActiveUniformBlockParameter\",\n    value: function getActiveUniformBlockParameter(blockIndex, pname) {\n      assertWebGL2Context(this.gl);\n      return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n    }\n    /* eslint-enable max-len */\n    // PRIVATE METHODS\n\n  }, {\n    key: \"_setAttributeToGeneric\",\n    value: function _setAttributeToGeneric(_ref6) {\n      var location = _ref6.location,\n          array = _ref6.array;\n      this.vertexAttributes.setGeneric({\n        location: location,\n        array: array\n      });\n      this.vertexAttributes.disable(location, true);\n    }\n  }, {\n    key: \"_setAttributeToBuffer\",\n    value: function _setAttributeToBuffer(_ref7) {\n      var location = _ref7.location,\n          buffer = _ref7.buffer,\n          layout = _ref7.layout;\n      var divisor = layout.instanced ? 1 : 0;\n      this.vertexAttributes.setBuffer({\n        location: location,\n        buffer: buffer,\n        layout: layout\n      });\n      this.vertexAttributes.setDivisor(location, divisor);\n      this.vertexAttributes.enable(location);\n    }\n  }, {\n    key: \"_compileAndLink\",\n    value: function _compileAndLink() {\n      var gl = this.gl;\n      gl.attachShader(this.handle, this.vs.handle);\n      gl.attachShader(this.handle, this.fs.handle);\n      log.time(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n      gl.linkProgram(this.handle);\n      log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))(); // Avoid checking program linking error in production\n\n      if (gl.debug || log.priority > 0) {\n        gl.validateProgram(this.handle);\n        var linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);\n\n        if (!linked) {\n          throw new Error(\"Error linking \".concat(gl.getProgramInfoLog(this.handle)));\n        }\n      }\n\n      this._queryAttributeLocations();\n\n      this._queryUniformLocations();\n    }\n  }, {\n    key: \"_sortBuffersByLocation\",\n    value: function _sortBuffersByLocation(buffers) {\n      var elements = null;\n      var locations = []; // Reutrn early if no buffers to be bound.\n\n      if (isObjectEmpty(buffers)) {\n        return {\n          locations: locations,\n          elements: elements\n        };\n      }\n\n      locations = new Array(this._attributeCount);\n\n      for (var bufferName in buffers) {\n        var buffer = buffers[bufferName];\n        var location = this._attributeToLocationMap[bufferName];\n\n        if (location === undefined) {\n          if (buffer.target === GL.ELEMENT_ARRAY_BUFFER && elements) {\n            throw new Error(\"\".concat(this._print(bufferName), \" duplicate GL.ELEMENT_ARRAY_BUFFER\"));\n          } else if (buffer.target === GL.ELEMENT_ARRAY_BUFFER) {\n            elements = bufferName;\n          } else if (!this._warnedLocations[location]) {\n            log.log(2, \"\".concat(this._print(bufferName), \" not used\"))();\n            this._warnedLocations[location] = true;\n          }\n        } else {\n          if (buffer.target === GL.ELEMENT_ARRAY_BUFFER) {\n            throw new Error(\"\".concat(this._print(bufferName), \":\").concat(location, \" \") + 'has both location and type gl.ELEMENT_ARRAY_BUFFER');\n          }\n\n          locations[location] = bufferName;\n        }\n      }\n\n      return {\n        locations: locations,\n        elements: elements\n      };\n    } // Check that all active attributes are enabled\n\n  }, {\n    key: \"_areAllAttributesEnabled\",\n    value: function _areAllAttributesEnabled() {\n      var length = this._attributeCount;\n\n      for (var i = 0; i < length; ++i) {\n        if (!this.vertexAttributes.isEnabled(i)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_print\",\n    value: function _print(bufferName) {\n      return \"Program \".concat(this.id, \": Attribute \").concat(bufferName);\n    }\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createProgram();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteProgram(this.handle);\n    }\n  }, {\n    key: \"_getName\",\n    value: function _getName() {\n      var programName = this.vs.getName() || this.fs.getName();\n      programName = programName.replace(/shader/i, '');\n      programName = programName ? \"\".concat(programName, \"-program\") : 'program';\n      return programName;\n    }\n  }, {\n    key: \"_getOptionsFromHandle\",\n    value: function _getOptionsFromHandle(handle) {\n      var shaderHandles = this.gl.getAttachedShaders(handle);\n      var opts = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = shaderHandles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var shaderHandle = _step.value;\n          var type = this.gl.getShaderParameter(this.handle, GL.SHADER_TYPE);\n\n          switch (type) {\n            case GL.VERTEX_SHADER:\n              opts.vs = new VertexShader({\n                handle: shaderHandle\n              });\n              break;\n\n            case GL.FRAGMENT_SHADER:\n              opts.fs = new FragmentShader({\n                handle: shaderHandle\n              });\n              break;\n\n            default:\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return opts;\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      return this.gl.getProgramParameter(this.handle, pname);\n    } // query attribute locations and build name to location map.\n\n  }, {\n    key: \"_queryAttributeLocations\",\n    value: function _queryAttributeLocations() {\n      this._attributeToLocationMap = {};\n      this._attributeCount = this.getAttributeCount();\n\n      for (var location = 0; location < this._attributeCount; location++) {\n        var name = this.getAttributeInfo(location).name;\n        this._attributeToLocationMap[name] = this.getAttributeLocation(name);\n      }\n\n      this._warnedLocations = {};\n    } // query uniform locations and build name to setter map.\n\n  }, {\n    key: \"_queryUniformLocations\",\n    value: function _queryUniformLocations() {\n      var gl = this.gl;\n      this._uniformSetters = {};\n      this._uniformCount = this.getUniformCount();\n\n      for (var i = 0; i < this._uniformCount; i++) {\n        var info = this.getUniformInfo(i);\n        var parsedName = parseUniformName(info.name);\n        var location = this.getUniformLocation(parsedName.name);\n        this._uniformSetters[parsedName.name] = getUniformSetter(gl, location, info, parsedName.isArray);\n      }\n\n      this._textureIndexCounter = 0;\n    }\n  }, {\n    key: \"_setId\",\n    value: function _setId(id) {\n      // If program is not named, name it after shader names\n      if (!id) {\n        var programName = this._getName(); // TODO - this.id will already have been initialized\n\n\n        this.id = uid(programName);\n      }\n    }\n  }]);\n\n  return Program;\n}(Resource); // create uniform setters\n// Map of uniform names to setter functions\n\n\nexport { Program as default };\nexport function getUniformDescriptors(gl, program) {\n  var uniformDescriptors = {};\n  var length = program.getUniformCount();\n\n  for (var i = 0; i < length; i++) {\n    var info = program.getUniformInfo(i);\n    var location = program.getUniformLocation(info.name);\n    var descriptor = getUniformSetter(gl, location, info);\n    uniformDescriptors[descriptor.name] = descriptor;\n  }\n\n  return uniformDescriptors;\n} // Get a map of buffer indices\n\nexport function getVaryingMap(varyings, bufferMode) {\n  var varyingMap = {};\n  var index = 0;\n  assert(bufferMode === GL_SEPARATE_ATTRIBS || bufferMode === GL_INTERLEAVED_ATTRIBS);\n  var indexIncrement = bufferMode === GL_SEPARATE_ATTRIBS ? 1 : 0;\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = varyings[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var varying = _step2.value;\n      varyingMap[varying] = index;\n      index += indexIncrement;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return varyingMap;\n}","map":null,"metadata":{},"sourceType":"module"}