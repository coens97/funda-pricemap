{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n/* global requestAnimationFrame, cancelAnimationFrame */\n\n\nimport LinearInterpolator from '../transitions/linear-interpolator';\nimport Transition from '../transitions/transition';\nimport assert from '../utils/assert';\n\nvar noop = function noop() {};\n\nexport var TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\n\nvar TransitionManager =\n/*#__PURE__*/\nfunction () {\n  function TransitionManager(ControllerState) {\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TransitionManager);\n\n    assert(ControllerState);\n    this.ControllerState = ControllerState;\n    this.props = Object.assign({}, DEFAULT_PROPS, props);\n    this.animation = null;\n    this.propsInTransition = null;\n    this.transition = new Transition();\n    this.onViewStateChange = props.onViewStateChange;\n    this._onTransitionFrame = this._onTransitionFrame.bind(this);\n    this._onTransitionUpdate = this._onTransitionUpdate.bind(this);\n  }\n\n  _createClass(TransitionManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      cancelAnimationFrame(this.animation);\n    } // Returns current transitioned viewport.\n\n  }, {\n    key: \"getViewportInTransition\",\n    value: function getViewportInTransition() {\n      return this.propsInTransition;\n    } // Process the vewiport change, either ignore or trigger a new transition.\n    // Return true if a new transition is triggered, false otherwise.\n\n  }, {\n    key: \"processViewStateChange\",\n    value: function processViewStateChange(nextProps) {\n      var transitionTriggered = false;\n      var currentProps = this.props; // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n\n      nextProps = Object.assign({}, DEFAULT_PROPS, nextProps);\n      this.props = nextProps; // NOTE: Be cautious re-ordering statements in this function.\n\n      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return transitionTriggered;\n      }\n\n      if (this._isTransitionEnabled(nextProps)) {\n        var startProps = Object.assign({}, currentProps, this.transition.interruption === TRANSITION_EVENTS.SNAP_TO_END ? this.transition.endProps : this.propsInTransition || currentProps);\n\n        this._triggerTransition(startProps, nextProps);\n\n        transitionTriggered = true;\n      } else {\n        this.transition.cancel();\n      }\n\n      return transitionTriggered;\n    } // Helper methods\n\n  }, {\n    key: \"_isTransitionEnabled\",\n    value: function _isTransitionEnabled(props) {\n      return props.transitionDuration > 0 && props.transitionInterpolator;\n    }\n  }, {\n    key: \"_isUpdateDueToCurrentTransition\",\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.transition.inProgress) {\n        return this.transition.interpolator.arePropsEqual(props, this.propsInTransition);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_shouldIgnoreViewportChange\",\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (this.transition.inProgress) {\n        // Ignore update if it is requested to be ignored\n        return this.transition.interruption === TRANSITION_EVENTS.IGNORE || // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps);\n      } else if (this._isTransitionEnabled(nextProps)) {\n        // Ignore if none of the viewport props changed.\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_triggerTransition\",\n    value: function _triggerTransition(startProps, endProps) {\n      assert(this._isTransitionEnabled(endProps), 'Transition is not enabled');\n      cancelAnimationFrame(this.animation);\n      var startViewstate = new this.ControllerState(startProps);\n      var endViewStateProps = new this.ControllerState(endProps).shortestPathFrom(startViewstate);\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endViewStateProps);\n      this.propsInTransition = {};\n      this.transition.start({\n        duration: endProps.transitionDuration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        onStart: endProps.onTransitionStart,\n        onUpdate: this._onTransitionUpdate,\n        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),\n        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)\n      });\n\n      this._onTransitionFrame();\n    }\n  }, {\n    key: \"_onTransitionFrame\",\n    value: function _onTransitionFrame() {\n      // _updateViewport() may cancel the animation\n      this.animation = requestAnimationFrame(this._onTransitionFrame);\n      this.transition.update(Date.now());\n    }\n  }, {\n    key: \"_onTransitionEnd\",\n    value: function _onTransitionEnd(callback) {\n      var _this = this;\n\n      return function (transition) {\n        cancelAnimationFrame(_this.animation);\n        _this.propsInTransition = null;\n        callback(transition);\n      };\n    }\n  }, {\n    key: \"_onTransitionUpdate\",\n    value: function _onTransitionUpdate(transition) {\n      // NOTE: Be cautious re-ordering statements in this function.\n      var interpolator = transition.interpolator,\n          startProps = transition.startProps,\n          endProps = transition.endProps,\n          time = transition.time;\n      var viewport = interpolator.interpolateProps(startProps, endProps, time); // This gurantees all props (e.g. bearing, longitude) are normalized\n      // So when viewports are compared they are in same range.\n\n      this.propsInTransition = new this.ControllerState(Object.assign({}, this.props, viewport)).getViewportProps();\n\n      if (this.onViewStateChange) {\n        this.onViewStateChange({\n          viewState: this.propsInTransition,\n          interactionState: {\n            inTransition: true\n          }\n        });\n      }\n    }\n  }]);\n\n  return TransitionManager;\n}();\n\nexport { TransitionManager as default };\nTransitionManager.defaultProps = DEFAULT_PROPS;","map":null,"metadata":{},"sourceType":"module"}