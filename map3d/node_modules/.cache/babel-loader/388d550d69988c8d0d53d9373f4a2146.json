{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport { clamp } from 'math.gl';\nimport Controller from './controller';\nimport OrbitViewport from '../deprecated/orbit-viewport';\nimport assert from '../utils/assert';\nimport LinearInterpolator from '../transitions/linear-interpolator';\nimport { TRANSITION_EVENTS } from './transition-manager';\nvar ZOOM_TRANSITION_PROPS = {\n  transitionDuration: 300,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(['zoom']),\n  transitionInterruption: TRANSITION_EVENTS.BREAK\n};\nvar defaultState = {\n  lookAt: [0, 0, 0],\n  rotationX: 0,\n  rotationOrbit: 0,\n  fov: 50,\n  near: 1,\n  far: 100,\n  translationX: 0,\n  translationY: 0,\n  zoom: 1\n};\nvar defaultConstraints = {\n  minZoom: 0,\n  maxZoom: Infinity\n};\n/* Helpers */\n\nfunction ensureFinite(value, fallbackValue) {\n  return Number.isFinite(value) ? value : fallbackValue;\n}\n\nvar OrbitState =\n/*#__PURE__*/\nfunction () {\n  function OrbitState(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        distance = _ref.distance,\n        rotationX = _ref.rotationX,\n        rotationOrbit = _ref.rotationOrbit,\n        orbitAxis = _ref.orbitAxis,\n        bounds = _ref.bounds,\n        lookAt = _ref.lookAt,\n        fov = _ref.fov,\n        near = _ref.near,\n        far = _ref.far,\n        translationX = _ref.translationX,\n        translationY = _ref.translationY,\n        zoom = _ref.zoom,\n        minZoom = _ref.minZoom,\n        maxZoom = _ref.maxZoom,\n        startPanViewport = _ref.startPanViewport,\n        startPanPos = _ref.startPanPos,\n        isPanning = _ref.isPanning,\n        startRotateViewport = _ref.startRotateViewport,\n        isRotating = _ref.isRotating,\n        startZoomViewport = _ref.startZoomViewport,\n        startZoomPos = _ref.startZoomPos;\n\n    _classCallCheck(this, OrbitState);\n\n    assert(Number.isFinite(width), '`width` must be supplied');\n    assert(Number.isFinite(height), '`height` must be supplied');\n    assert(Number.isFinite(distance), '`distance` must be supplied');\n    this._viewportProps = this._applyConstraints({\n      width: width,\n      height: height,\n      distance: distance,\n      rotationX: ensureFinite(rotationX, defaultState.rotationX),\n      rotationOrbit: ensureFinite(rotationOrbit, defaultState.rotationOrbit),\n      orbitAxis: orbitAxis,\n      bounds: bounds,\n      lookAt: lookAt || defaultState.lookAt,\n      fov: ensureFinite(fov, defaultState.fov),\n      near: ensureFinite(near, defaultState.near),\n      far: ensureFinite(far, defaultState.far),\n      translationX: ensureFinite(translationX, defaultState.translationX),\n      translationY: ensureFinite(translationY, defaultState.translationY),\n      zoom: ensureFinite(zoom, defaultState.zoom),\n      minZoom: ensureFinite(minZoom, defaultConstraints.minZoom),\n      maxZoom: ensureFinite(maxZoom, defaultConstraints.maxZoom)\n    });\n    this._interactiveState = {\n      startPanViewport: startPanViewport,\n      startPanPos: startPanPos,\n      isPanning: isPanning,\n      startRotateViewport: startRotateViewport,\n      isRotating: isRotating,\n      startZoomViewport: startZoomViewport,\n      startZoomPos: startZoomPos\n    };\n  }\n  /* Public API */\n\n\n  _createClass(OrbitState, [{\n    key: \"getViewportProps\",\n    value: function getViewportProps() {\n      return this._viewportProps;\n    }\n  }, {\n    key: \"getInteractiveState\",\n    value: function getInteractiveState() {\n      return this._interactiveState;\n    }\n    /**\n     * Start panning\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n\n  }, {\n    key: \"panStart\",\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      var viewport = new OrbitViewport(this._viewportProps);\n      return this._getUpdatedOrbitState({\n        startPanPos: pos,\n        startPanViewport: viewport\n      });\n    }\n    /**\n     * Pan\n     * @param {[Number, Number]} pos - position on screen where the pointer is\n     */\n\n  }, {\n    key: \"pan\",\n    value: function pan(_ref3) {\n      var pos = _ref3.pos,\n          startPos = _ref3.startPos;\n\n      if (this._interactiveState.isRotating) {\n        return this._getUpdatedOrbitState();\n      }\n\n      var startPanPos = this._interactiveState.startPanPos || startPos;\n      assert(startPanPos, '`startPanPos` props is required');\n      var viewport = this._interactiveState.startPanViewport || new OrbitViewport(this._viewportProps);\n      var deltaX = pos[0] - startPanPos[0];\n      var deltaY = pos[1] - startPanPos[1];\n      var center = viewport.project(viewport.lookAt);\n      var newLookAt = viewport.unproject([center[0] - deltaX, center[1] - deltaY, center[2]]);\n      return this._getUpdatedOrbitState({\n        lookAt: newLookAt,\n        isPanning: true\n      });\n    }\n    /**\n     * End panning\n     * Must call if `panStart()` was called\n     */\n\n  }, {\n    key: \"panEnd\",\n    value: function panEnd() {\n      return this._getUpdatedOrbitState({\n        startPanViewport: null,\n        startPanPos: null,\n        isPanning: null\n      });\n    }\n    /**\n     * Start rotating\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n\n  }, {\n    key: \"rotateStart\",\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos; // Rotation center should be the worldspace position at the center of the\n      // the screen. If not found, use the last one.\n\n      var viewport = new OrbitViewport(this._viewportProps);\n      return this._getUpdatedOrbitState({\n        startRotateViewport: viewport\n      });\n    }\n    /**\n     * Rotate\n     * @param {[Number, Number]} pos - position on screen where the pointer is\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(_ref5) {\n      var deltaScaleX = _ref5.deltaScaleX,\n          deltaScaleY = _ref5.deltaScaleY;\n\n      if (this._interactiveState.isPanning) {\n        return this._getUpdatedOrbitState();\n      }\n\n      var startRotateViewport = this._interactiveState.startRotateViewport;\n\n      var _ref6 = startRotateViewport || {},\n          rotationX = _ref6.rotationX,\n          rotationOrbit = _ref6.rotationOrbit;\n\n      rotationX = ensureFinite(rotationX, this._viewportProps.rotationX);\n      rotationOrbit = ensureFinite(rotationOrbit, this._viewportProps.rotationOrbit);\n      var newRotationX = clamp(rotationX - deltaScaleY * 180, -89.999, 89.999);\n      var newRotationOrbit = (rotationOrbit - deltaScaleX * 180) % 360;\n      return this._getUpdatedOrbitState({\n        rotationX: newRotationX,\n        rotationOrbit: newRotationOrbit,\n        isRotating: true\n      });\n    }\n    /**\n     * End rotating\n     * Must call if `rotateStart()` was called\n     */\n\n  }, {\n    key: \"rotateEnd\",\n    value: function rotateEnd() {\n      return this._getUpdatedOrbitState({\n        startRotateViewport: null,\n        isRotating: null\n      });\n    } // default implementation of shortest path between two view states\n\n  }, {\n    key: \"shortestPathFrom\",\n    value: function shortestPathFrom(viewState) {\n      var props = Object.assign({}, this._viewportProps);\n      return props;\n    }\n    /**\n     * Start zooming\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n\n  }, {\n    key: \"zoomStart\",\n    value: function zoomStart(_ref7) {\n      var pos = _ref7.pos;\n      var viewport = new OrbitViewport(this._viewportProps);\n      return this._getUpdatedOrbitState({\n        startZoomViewport: viewport,\n        startZoomPos: pos\n      });\n    }\n    /**\n     * Zoom\n     * @param {[Number, Number]} pos - position on screen where the current center is\n     * @param {[Number, Number]} startPos - the center position at\n     *   the start of the operation. Must be supplied of `zoomStart()` was not called\n     * @param {Number} scale - a number between [0, 1] specifying the accumulated\n     *   relative scale.\n     */\n\n  }, {\n    key: \"zoom\",\n    value: function zoom(_ref8) {\n      var pos = _ref8.pos,\n          startPos = _ref8.startPos,\n          scale = _ref8.scale;\n      var _this$_viewportProps = this._viewportProps,\n          zoom = _this$_viewportProps.zoom,\n          minZoom = _this$_viewportProps.minZoom,\n          maxZoom = _this$_viewportProps.maxZoom,\n          width = _this$_viewportProps.width,\n          height = _this$_viewportProps.height;\n      var startZoomPos = this._interactiveState.startZoomPos || startPos || pos;\n      var viewport = this._interactiveState.startZoomViewport || new OrbitViewport(this._viewportProps);\n      var newZoom = clamp(zoom * scale, minZoom, maxZoom);\n      var deltaX = pos[0] - startZoomPos[0];\n      var deltaY = pos[1] - startZoomPos[1]; // Zoom around the center position\n\n      var cx = startZoomPos[0] - width / 2;\n      var cy = height / 2 - startZoomPos[1];\n      var center = viewport.project(viewport.lookAt);\n      var newCenterX = center[0] - cx + cx * newZoom / zoom + deltaX;\n      var newCenterY = center[1] + cy - cy * newZoom / zoom - deltaY;\n      var newLookAt = viewport.unproject([newCenterX, newCenterY, center[2]]);\n      return this._getUpdatedOrbitState({\n        lookAt: newLookAt,\n        zoom: newZoom\n      });\n    }\n    /**\n     * End zooming\n     * Must call if `zoomStart()` was called\n     */\n\n  }, {\n    key: \"zoomEnd\",\n    value: function zoomEnd() {\n      return this._getUpdatedOrbitState({\n        startZoomPos: null\n      });\n    }\n    /* Private methods */\n\n  }, {\n    key: \"_getUpdatedOrbitState\",\n    value: function _getUpdatedOrbitState(newProps) {\n      // Update _viewportProps\n      return new OrbitState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));\n    } // Apply any constraints (mathematical or defined by _viewportProps) to map state\n\n  }, {\n    key: \"_applyConstraints\",\n    value: function _applyConstraints(props) {\n      // Ensure zoom is within specified range\n      var maxZoom = props.maxZoom,\n          minZoom = props.minZoom,\n          zoom = props.zoom;\n      props.zoom = zoom > maxZoom ? maxZoom : zoom;\n      props.zoom = zoom < minZoom ? minZoom : zoom;\n      return props;\n    }\n  }]);\n\n  return OrbitState;\n}();\n\nvar OrbitController =\n/*#__PURE__*/\nfunction (_Controller) {\n  _inherits(OrbitController, _Controller);\n\n  function OrbitController(props) {\n    _classCallCheck(this, OrbitController);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(OrbitController).call(this, OrbitState, props));\n  }\n\n  _createClass(OrbitController, [{\n    key: \"_getTransitionProps\",\n    value: function _getTransitionProps() {\n      // Enable transitions for zoom change\n      return ZOOM_TRANSITION_PROPS;\n    }\n  }]);\n\n  return OrbitController;\n}(Controller);\n\nexport { OrbitController as default };","map":null,"metadata":{},"sourceType":"module"}