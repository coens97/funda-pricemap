{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport Geometry from './geometry';\nimport { uid } from '../utils';\n\nvar SphereGeometry =\n/*#__PURE__*/\nfunction (_Geometry) {\n  _inherits(SphereGeometry, _Geometry);\n\n  function SphereGeometry() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, SphereGeometry);\n\n    var _opts$nlat = opts.nlat,\n        nlat = _opts$nlat === undefined ? 10 : _opts$nlat,\n        _opts$nlong = opts.nlong,\n        nlong = _opts$nlong === undefined ? 10 : _opts$nlong,\n        _opts$radius = opts.radius,\n        radius = _opts$radius === undefined ? 1 : _opts$radius,\n        _opts$id = opts.id,\n        id = _opts$id === undefined ? uid('sphere-geometry') : _opts$id;\n    return _possibleConstructorReturn(this, (SphereGeometry.__proto__ || Object.getPrototypeOf(SphereGeometry)).call(this, Object.assign({}, opts, {\n      id: id,\n      attributes: getSphereAttributes(nlat, nlong, radius)\n    })));\n  }\n\n  return SphereGeometry;\n}(Geometry); // Primitives inspired by TDL http://code.google.com/p/webglsamples/,\n// copyright 2011 Google Inc. new BSD License\n// (http://www.opensource.org/licenses/bsd-license.php).\n\n/* eslint-disable max-statements, complexity */\n\n\nexport default SphereGeometry;\n\nfunction getSphereAttributes(nlat, nlong, radius) {\n  var startLat = 0;\n  var endLat = Math.PI;\n  var latRange = endLat - startLat;\n  var startLong = 0;\n  var endLong = 2 * Math.PI;\n  var longRange = endLong - startLong;\n  var numVertices = (nlat + 1) * (nlong + 1);\n\n  if (typeof radius === 'number') {\n    var value = radius;\n\n    radius = function radius(n1, n2, n3, u, v) {\n      return value;\n    };\n  }\n\n  var positions = new Float32Array(numVertices * 3);\n  var normals = new Float32Array(numVertices * 3);\n  var texCoords = new Float32Array(numVertices * 2);\n  var indices = new Uint16Array(nlat * nlong * 6); // Create positions, normals and texCoords\n\n  for (var y = 0; y <= nlat; y++) {\n    for (var x = 0; x <= nlong; x++) {\n      var u = x / nlong;\n      var v = y / nlat;\n      var index = x + y * (nlong + 1);\n      var i2 = index * 2;\n      var i3 = index * 3;\n      var theta = longRange * u;\n      var phi = latRange * v;\n      var sinTheta = Math.sin(theta);\n      var cosTheta = Math.cos(theta);\n      var sinPhi = Math.sin(phi);\n      var cosPhi = Math.cos(phi);\n      var ux = cosTheta * sinPhi;\n      var uy = cosPhi;\n      var uz = sinTheta * sinPhi;\n      var r = radius(ux, uy, uz, u, v);\n      positions[i3 + 0] = r * ux;\n      positions[i3 + 1] = r * uy;\n      positions[i3 + 2] = r * uz;\n      normals[i3 + 0] = ux;\n      normals[i3 + 1] = uy;\n      normals[i3 + 2] = uz;\n      texCoords[i2 + 0] = u;\n      texCoords[i2 + 1] = v;\n    }\n  } // Create indices\n\n\n  var numVertsAround = nlat + 1;\n\n  for (var _x2 = 0; _x2 < nlat; _x2++) {\n    for (var _y = 0; _y < nlong; _y++) {\n      var _index = (_x2 * nlong + _y) * 6;\n\n      indices[_index + 0] = _y * numVertsAround + _x2;\n      indices[_index + 1] = _y * numVertsAround + _x2 + 1;\n      indices[_index + 2] = (_y + 1) * numVertsAround + _x2;\n      indices[_index + 3] = (_y + 1) * numVertsAround + _x2;\n      indices[_index + 4] = _y * numVertsAround + _x2 + 1;\n      indices[_index + 5] = (_y + 1) * numVertsAround + _x2 + 1;\n    }\n  }\n\n  return {\n    positions: positions,\n    indices: indices,\n    normals: normals,\n    texCoords: texCoords\n  };\n}","map":null,"metadata":{},"sourceType":"module"}