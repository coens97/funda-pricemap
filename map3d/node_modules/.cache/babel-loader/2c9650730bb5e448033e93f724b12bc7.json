{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/* global requestAnimationFrame, cancelAnimationFrame */\n\n\nimport LinearInterpolator from '../transitions/linear-interpolator';\nimport { extractViewportFrom } from '../transitions/transition-utils';\nimport assert from 'assert';\n\nvar noop = function noop() {};\n\nexport var TRANSITION_EVENTS = {\n  BREAK: 1,\n  SNAP_TO_END: 2,\n  IGNORE: 3\n};\nvar DEFAULT_PROPS = {\n  transitionDuration: 0,\n  transitionEasing: function transitionEasing(t) {\n    return t;\n  },\n  transitionInterpolator: new LinearInterpolator(),\n  transitionInterruption: TRANSITION_EVENTS.BREAK,\n  onTransitionStart: noop,\n  onTransitionInterrupt: noop,\n  onTransitionEnd: noop\n};\nvar DEFAULT_STATE = {\n  animation: null,\n  propsInTransition: null,\n  startProps: null,\n  endProps: null\n};\n\nvar TransitionManager = function () {\n  function TransitionManager(props) {\n    _classCallCheck(this, TransitionManager);\n\n    this.props = props;\n    this.state = DEFAULT_STATE;\n    this._onTransitionFrame = this._onTransitionFrame.bind(this);\n  } // Returns current transitioned viewport.\n\n\n  _createClass(TransitionManager, [{\n    key: 'getViewportInTransition',\n    value: function getViewportInTransition() {\n      return this.state.propsInTransition;\n    } // Process the vewiport change, either ignore or trigger a new transiton.\n    // Return true if a new transition is triggered, false otherwise.\n\n  }, {\n    key: 'processViewportChange',\n    value: function processViewportChange(nextProps) {\n      var transitionTriggered = false;\n      var currentProps = this.props; // Set this.props here as '_triggerTransition' calls '_updateViewport' that uses this.props.\n\n      this.props = nextProps; // NOTE: Be cautious re-ordering statements in this function.\n\n      if (this._shouldIgnoreViewportChange(currentProps, nextProps)) {\n        return transitionTriggered;\n      }\n\n      var isTransitionInProgress = this._isTransitionInProgress();\n\n      if (this._isTransitionEnabled(nextProps)) {\n        var startProps = Object.assign({}, currentProps, this.state.interruption === TRANSITION_EVENTS.SNAP_TO_END ? this.state.endProps : this.state.propsInTransition || currentProps);\n\n        if (isTransitionInProgress) {\n          currentProps.onTransitionInterrupt();\n        }\n\n        nextProps.onTransitionStart();\n\n        this._triggerTransition(startProps, nextProps);\n\n        transitionTriggered = true;\n      } else if (isTransitionInProgress) {\n        currentProps.onTransitionInterrupt();\n\n        this._endTransition();\n      }\n\n      return transitionTriggered;\n    } // Helper methods\n\n  }, {\n    key: '_isTransitionInProgress',\n    value: function _isTransitionInProgress() {\n      return this.state.propsInTransition;\n    }\n  }, {\n    key: '_isTransitionEnabled',\n    value: function _isTransitionEnabled(props) {\n      return props.transitionDuration > 0 && props.transitionInterpolator;\n    }\n  }, {\n    key: '_isUpdateDueToCurrentTransition',\n    value: function _isUpdateDueToCurrentTransition(props) {\n      if (this.state.propsInTransition) {\n        return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);\n      }\n\n      return false;\n    }\n  }, {\n    key: '_shouldIgnoreViewportChange',\n    value: function _shouldIgnoreViewportChange(currentProps, nextProps) {\n      if (this._isTransitionInProgress()) {\n        // Ignore update if it is requested to be ignored\n        return this.state.interruption === TRANSITION_EVENTS.IGNORE || // Ignore update if it is due to current active transition.\n        this._isUpdateDueToCurrentTransition(nextProps);\n      } else if (this._isTransitionEnabled(nextProps)) {\n        // Ignore if none of the viewport props changed.\n        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);\n      }\n\n      return true;\n    }\n  }, {\n    key: '_triggerTransition',\n    value: function _triggerTransition(startProps, endProps) {\n      assert(this._isTransitionEnabled(endProps), 'Transition is not enabled');\n      cancelAnimationFrame(this.state.animation);\n      var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);\n      this.state = {\n        // Save current transition props\n        duration: endProps.transitionDuration,\n        easing: endProps.transitionEasing,\n        interpolator: endProps.transitionInterpolator,\n        interruption: endProps.transitionInterruption,\n        startTime: Date.now(),\n        startProps: initialProps.start,\n        endProps: initialProps.end,\n        animation: null,\n        propsInTransition: {}\n      };\n\n      this._onTransitionFrame();\n    }\n  }, {\n    key: '_onTransitionFrame',\n    value: function _onTransitionFrame() {\n      // _updateViewport() may cancel the animation\n      this.state.animation = requestAnimationFrame(this._onTransitionFrame);\n\n      this._updateViewport();\n    }\n  }, {\n    key: '_endTransition',\n    value: function _endTransition() {\n      cancelAnimationFrame(this.state.animation);\n      this.state = DEFAULT_STATE;\n    }\n  }, {\n    key: '_updateViewport',\n    value: function _updateViewport() {\n      // NOTE: Be cautious re-ordering statements in this function.\n      var currentTime = Date.now();\n      var _state = this.state,\n          startTime = _state.startTime,\n          duration = _state.duration,\n          easing = _state.easing,\n          interpolator = _state.interpolator,\n          startProps = _state.startProps,\n          endProps = _state.endProps;\n      var shouldEnd = false;\n      var t = (currentTime - startTime) / duration;\n\n      if (t >= 1) {\n        t = 1;\n        shouldEnd = true;\n      }\n\n      t = easing(t);\n      var viewport = interpolator.interpolateProps(startProps, endProps, t); // This extractViewportFrom gurantees angle props (bearing, longitude) are normalized\n      // So when viewports are compared they are in same range.\n\n      this.state.propsInTransition = extractViewportFrom(Object.assign({}, this.props, viewport));\n\n      if (this.props.onViewportChange) {\n        this.props.onViewportChange(this.state.propsInTransition, {\n          inTransition: true\n        });\n      }\n\n      if (shouldEnd) {\n        this._endTransition();\n\n        this.props.onTransitionEnd();\n      }\n    }\n  }]);\n\n  return TransitionManager;\n}();\n\nexport default TransitionManager;\nTransitionManager.defaultProps = DEFAULT_PROPS;","map":null,"metadata":{},"sourceType":"module"}