{"ast":null,"code":"// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport { drawPickingBuffer, getPixelRatio } from './draw-layers';\nimport log from '../utils/log';\nimport assert from 'assert';\nvar NO_PICKED_OBJECT = {\n  pickedColor: null,\n  pickedLayer: null,\n  pickedObjectIndex: -1\n};\n/* eslint-disable max-depth, max-statements */\n// Pick the closest object at the given (x,y) coordinate\n\nexport function pickObject(gl, _ref) {\n  var layers = _ref.layers,\n      viewports = _ref.viewports,\n      x = _ref.x,\n      y = _ref.y,\n      radius = _ref.radius,\n      layerFilter = _ref.layerFilter,\n      mode = _ref.mode,\n      onViewportActive = _ref.onViewportActive,\n      pickingFBO = _ref.pickingFBO,\n      lastPickedInfo = _ref.lastPickedInfo,\n      useDevicePixels = _ref.useDevicePixels; // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n\n  var pixelRatio = getPixelRatio({\n    useDevicePixels: useDevicePixels\n  });\n  var deviceX = Math.round(x * pixelRatio);\n  var deviceY = Math.round(gl.canvas.height - y * pixelRatio);\n  var deviceRadius = Math.round(radius * pixelRatio);\n  var deviceRect = getPickingRect({\n    deviceX: deviceX,\n    deviceY: deviceY,\n    deviceRadius: deviceRadius,\n    deviceWidth: pickingFBO.width,\n    deviceHeight: pickingFBO.height\n  });\n  var pickedColors = deviceRect && drawAndSamplePickingBuffer(gl, {\n    layers: layers,\n    viewports: viewports,\n    onViewportActive: onViewportActive,\n    useDevicePixels: useDevicePixels,\n    pickingFBO: pickingFBO,\n    deviceRect: deviceRect,\n    layerFilter: layerFilter,\n    redrawReason: mode\n  });\n  var pickInfo = pickedColors && getClosestFromPickingBuffer(gl, {\n    pickedColors: pickedColors,\n    layers: layers,\n    deviceX: deviceX,\n    deviceY: deviceY,\n    deviceRadius: deviceRadius,\n    deviceRect: deviceRect\n  }) || NO_PICKED_OBJECT;\n  return processPickInfo({\n    pickInfo: pickInfo,\n    lastPickedInfo: lastPickedInfo,\n    mode: mode,\n    layers: layers,\n    viewports: viewports,\n    x: x,\n    y: y,\n    deviceX: deviceX,\n    deviceY: deviceY,\n    pixelRatio: pixelRatio\n  });\n} // Pick all objects within the given bounding box\n\nexport function pickVisibleObjects(gl, _ref2) {\n  var layers = _ref2.layers,\n      viewports = _ref2.viewports,\n      x = _ref2.x,\n      y = _ref2.y,\n      width = _ref2.width,\n      height = _ref2.height,\n      mode = _ref2.mode,\n      layerFilter = _ref2.layerFilter,\n      onViewportActive = _ref2.onViewportActive,\n      pickingFBO = _ref2.pickingFBO,\n      useDevicePixels = _ref2.useDevicePixels; // Convert from canvas top-left to WebGL bottom-left coordinates\n  // And compensate for pixelRatio\n\n  var pixelRatio = getPixelRatio({\n    useDevicePixels: useDevicePixels\n  });\n  var deviceLeft = Math.round(x * pixelRatio);\n  var deviceBottom = Math.round(gl.canvas.height - y * pixelRatio);\n  var deviceRight = Math.round((x + width) * pixelRatio);\n  var deviceTop = Math.round(gl.canvas.height - (y + height) * pixelRatio);\n  var deviceRect = {\n    x: deviceLeft,\n    y: deviceTop,\n    width: deviceRight - deviceLeft,\n    height: deviceBottom - deviceTop\n  };\n  var pickedColors = drawAndSamplePickingBuffer(gl, {\n    layers: layers,\n    viewports: viewports,\n    onViewportActive: onViewportActive,\n    pickingFBO: pickingFBO,\n    useDevicePixels: useDevicePixels,\n    deviceRect: deviceRect,\n    layerFilter: layerFilter,\n    redrawReason: mode\n  });\n  var pickInfos = getUniquesFromPickingBuffer(gl, {\n    pickedColors: pickedColors,\n    layers: layers\n  }); // Only return unique infos, identified by info.object\n\n  var uniqueInfos = new Map();\n  pickInfos.forEach(function (pickInfo) {\n    var viewport = getViewportFromCoordinates({\n      viewports: viewports\n    }); // TODO - add coords\n\n    var info = createInfo([pickInfo.x / pixelRatio, pickInfo.y / pixelRatio], viewport);\n    info.devicePixel = [pickInfo.x, pickInfo.y];\n    info.pixelRatio = pixelRatio;\n    info.color = pickInfo.pickedColor;\n    info.index = pickInfo.pickedObjectIndex;\n    info.picked = true;\n    info = getLayerPickingInfo({\n      layer: pickInfo.pickedLayer,\n      info: info,\n      mode: mode\n    });\n\n    if (!uniqueInfos.has(info.object)) {\n      uniqueInfos.set(info.object, info);\n    }\n  });\n  return Array.from(uniqueInfos.values());\n} // HELPER METHODS\n// returns pickedColor or null if no pickable layers found.\n\nfunction drawAndSamplePickingBuffer(gl, _ref3) {\n  var layers = _ref3.layers,\n      viewports = _ref3.viewports,\n      onViewportActive = _ref3.onViewportActive,\n      useDevicePixels = _ref3.useDevicePixels,\n      pickingFBO = _ref3.pickingFBO,\n      deviceRect = _ref3.deviceRect,\n      layerFilter = _ref3.layerFilter,\n      redrawReason = _ref3.redrawReason;\n  assert(deviceRect);\n  assert(Number.isFinite(deviceRect.width) && deviceRect.width > 0, '`width` must be > 0');\n  assert(Number.isFinite(deviceRect.height) && deviceRect.height > 0, '`height` must be > 0');\n  var pickableLayers = layers.filter(function (layer) {\n    return layer.isPickable();\n  });\n\n  if (pickableLayers.length < 1) {\n    return null;\n  }\n\n  drawPickingBuffer(gl, {\n    layers: layers,\n    viewports: viewports,\n    onViewportActive: onViewportActive,\n    useDevicePixels: useDevicePixels,\n    pickingFBO: pickingFBO,\n    deviceRect: deviceRect,\n    layerFilter: layerFilter,\n    redrawReason: redrawReason\n  }); // Read from an already rendered picking buffer\n  // Returns an Uint8ClampedArray of picked pixels\n\n  var x = deviceRect.x,\n      y = deviceRect.y,\n      width = deviceRect.width,\n      height = deviceRect.height;\n  var pickedColors = new Uint8Array(width * height * 4);\n  pickingFBO.readPixels({\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    pixelArray: pickedColors\n  });\n  return pickedColors;\n} // Indentifies which viewport, if any corresponds to x and y\n// Returns first viewport if no match\n// TODO - need to determine which viewport we are in\n// TODO - document concept of \"primary viewport\" that matches all coords?\n// TODO - static method on Viewport class?\n\n\nfunction getViewportFromCoordinates(_ref4) {\n  var viewports = _ref4.viewports;\n  var viewport = viewports[0];\n  return viewport;\n} // Calculate a picking rect centered on deviceX and deviceY and clipped to device\n// Returns null if pixel is outside of device\n\n\nfunction getPickingRect(_ref5) {\n  var deviceX = _ref5.deviceX,\n      deviceY = _ref5.deviceY,\n      deviceRadius = _ref5.deviceRadius,\n      deviceWidth = _ref5.deviceWidth,\n      deviceHeight = _ref5.deviceHeight;\n  var valid = deviceX >= 0 && deviceY >= 0 && deviceX < deviceWidth && deviceY < deviceHeight; // x, y out of bounds.\n\n  if (!valid) {\n    return null;\n  } // Create a box of size `radius * 2 + 1` centered at [deviceX, deviceY]\n\n\n  var x = Math.max(0, deviceX - deviceRadius);\n  var y = Math.max(0, deviceY - deviceRadius);\n  var width = Math.min(deviceWidth, deviceX + deviceRadius) - x + 1;\n  var height = Math.min(deviceHeight, deviceY + deviceRadius) - y + 1;\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n} // TODO - break this monster function into 3+ parts\n\n\nfunction processPickInfo(_ref6) {\n  var pickInfo = _ref6.pickInfo,\n      lastPickedInfo = _ref6.lastPickedInfo,\n      mode = _ref6.mode,\n      layers = _ref6.layers,\n      viewports = _ref6.viewports,\n      x = _ref6.x,\n      y = _ref6.y,\n      deviceX = _ref6.deviceX,\n      deviceY = _ref6.deviceY,\n      pixelRatio = _ref6.pixelRatio;\n  var pickedColor = pickInfo.pickedColor,\n      pickedLayer = pickInfo.pickedLayer,\n      pickedObjectIndex = pickInfo.pickedObjectIndex;\n  var affectedLayers = pickedLayer ? [pickedLayer] : [];\n\n  if (mode === 'hover') {\n    // only invoke onHover events if picked object has changed\n    var lastPickedObjectIndex = lastPickedInfo.index;\n    var lastPickedLayerId = lastPickedInfo.layerId;\n    var pickedLayerId = pickedLayer && pickedLayer.props.id; // proceed only if picked object changed\n\n    if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedObjectIndex) {\n      if (pickedLayerId !== lastPickedLayerId) {\n        // We cannot store a ref to lastPickedLayer in the context because\n        // the state of an outdated layer is no longer valid\n        // and the props may have changed\n        var lastPickedLayer = layers.find(function (layer) {\n          return layer.props.id === lastPickedLayerId;\n        });\n\n        if (lastPickedLayer) {\n          // Let leave event fire before enter event\n          affectedLayers.unshift(lastPickedLayer);\n        }\n      } // Update layer manager context\n\n\n      lastPickedInfo.layerId = pickedLayerId;\n      lastPickedInfo.index = pickedObjectIndex;\n    }\n  }\n\n  var viewport = getViewportFromCoordinates({\n    viewports: viewports\n  }); // TODO - add coords\n\n  var baseInfo = createInfo([x, y], viewport);\n  baseInfo.devicePixel = [deviceX, deviceY];\n  baseInfo.pixelRatio = pixelRatio; // Use a Map to store all picking infos.\n  // The following two forEach loops are the result of\n  // https://github.com/uber/deck.gl/issues/443\n  // Please be very careful when changing this pattern\n\n  var infos = new Map();\n  affectedLayers.forEach(function (layer) {\n    var info = Object.assign({}, baseInfo);\n\n    if (layer === pickedLayer) {\n      info.color = pickedColor;\n      info.index = pickedObjectIndex;\n      info.picked = true;\n    }\n\n    info = getLayerPickingInfo({\n      layer: layer,\n      info: info,\n      mode: mode\n    }); // This guarantees that there will be only one copy of info for\n    // one composite layer\n\n    if (info) {\n      infos.set(info.layer.id, info);\n    }\n\n    var pickingSelectedColor = layer.props.autoHighlight && pickedLayer === layer ? pickedColor : null;\n    var pickingParameters = {\n      pickingSelectedColor: pickingSelectedColor\n    };\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = layer.getModels()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var model = _step.value;\n        model.updateModuleSettings(pickingParameters);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  var unhandledPickInfos = callLayerPickingCallbacks(infos, mode);\n  return unhandledPickInfos;\n} // Per-layer event handlers (e.g. onClick, onHover) are provided by the\n// user and out of deck.gl's control. It's very much possible that\n// the user calls React lifecycle methods in these function, such as\n// ReactComponent.setState(). React lifecycle methods sometimes induce\n// a re-render and re-generation of props of deck.gl and its layers,\n// which invalidates all layers currently passed to this very function.\n// Therefore, per-layer event handlers must be invoked at the end\n// of the picking operation. NO operation that relies on the states of current\n// layers should be called after this code.\n\n\nfunction callLayerPickingCallbacks(infos, mode) {\n  var unhandledPickInfos = [];\n  infos.forEach(function (info) {\n    var handled = false;\n\n    switch (mode) {\n      case 'click':\n        handled = info.layer.props.onClick(info);\n        break;\n\n      case 'hover':\n        handled = info.layer.props.onHover(info);\n        break;\n\n      case 'query':\n        break;\n\n      default:\n        throw new Error('unknown pick type');\n    }\n\n    if (!handled) {\n      unhandledPickInfos.push(info);\n    }\n  });\n  return unhandledPickInfos;\n}\n/**\n * Pick at a specified pixel with a tolerance radius\n * Returns the closest object to the pixel in shape `{pickedColor, pickedLayer, pickedObjectIndex}`\n */\n\n\nexport function getClosestFromPickingBuffer(gl, _ref7) {\n  var pickedColors = _ref7.pickedColors,\n      layers = _ref7.layers,\n      deviceX = _ref7.deviceX,\n      deviceY = _ref7.deviceY,\n      deviceRadius = _ref7.deviceRadius,\n      deviceRect = _ref7.deviceRect;\n  assert(pickedColors); // Traverse all pixels in picking results and find the one closest to the supplied\n  // [deviceX, deviceY]\n\n  var x = deviceRect.x,\n      y = deviceRect.y,\n      width = deviceRect.width,\n      height = deviceRect.height;\n  var minSquareDistanceToCenter = deviceRadius * deviceRadius;\n  var closestPixelIndex = -1;\n  var i = 0;\n\n  for (var row = 0; row < height; row++) {\n    var dy = row + y - deviceY;\n    var dy2 = dy * dy;\n\n    if (dy2 > minSquareDistanceToCenter) {\n      // skip this row\n      i += 4 * width;\n    } else {\n      for (var col = 0; col < width; col++) {\n        // Decode picked layer from color\n        var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n        if (pickedLayerIndex >= 0) {\n          var dx = col + x - deviceX;\n          var d2 = dx * dx + dy2;\n\n          if (d2 <= minSquareDistanceToCenter) {\n            minSquareDistanceToCenter = d2;\n            closestPixelIndex = i;\n          }\n        }\n\n        i += 4;\n      }\n    }\n  }\n\n  if (closestPixelIndex >= 0) {\n    // Decode picked object index from color\n    var _pickedLayerIndex = pickedColors[closestPixelIndex + 3] - 1;\n\n    var pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);\n    var pickedLayer = layers[_pickedLayerIndex];\n\n    if (pickedLayer) {\n      var pickedObjectIndex = pickedLayer.decodePickingColor(pickedColor);\n      return {\n        pickedColor: pickedColor,\n        pickedLayer: pickedLayer,\n        pickedObjectIndex: pickedObjectIndex\n      };\n    }\n\n    log.error('Picked non-existent layer. Is picking buffer corrupt?');\n  }\n\n  return NO_PICKED_OBJECT;\n}\n/* eslint-enable max-depth, max-statements */\n\n/**\n * Examines a picking buffer for unique colors\n * Returns array of unique objects in shape `{x, y, pickedColor, pickedLayer, pickedObjectIndex}`\n */\n\nfunction getUniquesFromPickingBuffer(gl, _ref8) {\n  var pickedColors = _ref8.pickedColors,\n      layers = _ref8.layers;\n  var uniqueColors = new Map(); // Traverse all pixels in picking results and get unique colors\n\n  if (pickedColors) {\n    for (var i = 0; i < pickedColors.length; i += 4) {\n      // Decode picked layer from color\n      var pickedLayerIndex = pickedColors[i + 3] - 1;\n\n      if (pickedLayerIndex >= 0) {\n        var pickedColor = pickedColors.slice(i, i + 4);\n        var colorKey = pickedColor.join(','); // eslint-disable-next-line\n\n        if (!uniqueColors.has(colorKey)) {\n          var pickedLayer = layers[pickedLayerIndex]; // eslint-disable-next-line\n\n          if (pickedLayer) {\n            uniqueColors.set(colorKey, {\n              pickedColor: pickedColor,\n              pickedLayer: pickedLayer,\n              pickedObjectIndex: pickedLayer.decodePickingColor(pickedColor)\n            });\n          } else {\n            log.error('Picked non-existent layer. Is picking buffer corrupt?');\n          }\n        }\n      }\n    }\n  }\n\n  return Array.from(uniqueColors.values());\n}\n\nfunction createInfo(pixel, viewport) {\n  // Assign a number of potentially useful props to the \"info\" object\n  return {\n    color: null,\n    layer: null,\n    index: -1,\n    picked: false,\n    x: pixel[0],\n    y: pixel[1],\n    pixel: pixel,\n    lngLat: viewport.unproject(pixel)\n  };\n} // Walk up the layer composite chain to populate the info object\n\n\nfunction getLayerPickingInfo(_ref9) {\n  var layer = _ref9.layer,\n      info = _ref9.info,\n      mode = _ref9.mode;\n\n  while (layer && info) {\n    // For a composite layer, sourceLayer will point to the sublayer\n    // where the event originates from.\n    // It provides additional context for the composite layer's\n    // getPickingInfo() method to populate the info object\n    var sourceLayer = info.layer || layer;\n    info.layer = layer; // layer.pickLayer() function requires a non-null ```layer.state```\n    // object to funtion properly. So the layer refereced here\n    // must be the \"current\" layer, not an \"out-dated\" / \"invalidated\" layer\n\n    info = layer.pickLayer({\n      info: info,\n      mode: mode,\n      sourceLayer: sourceLayer\n    });\n    layer = layer.parentLayer;\n  }\n\n  return info;\n}","map":null,"metadata":{},"sourceType":"module"}