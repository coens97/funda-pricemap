{"ast":null,"code":"function _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Support for listening to context state changes and intercepting state queries\n//\n// NOTE: this system does not handle buffer bindings\n\n\nimport GL from '../constants';\nimport { setParameters, getParameters, GL_PARAMETER_DEFAULTS } from './set-parameters';\nimport polyfillContext from './polyfill-context';\nimport assert from '../utils/assert';\nexport var clone = function clone(x) {\n  return Array.isArray(x) || ArrayBuffer.isView(x) ? x.slice() : x;\n};\nexport var deepEqual = function deepEqual(x, y) {\n  var isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);\n  var isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);\n\n  if (isArrayX && isArrayY && x.length === y.length) {\n    for (var i = 0; i < x.length; ++i) {\n      if (x[i] !== y[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return x === y;\n}; // interceptors for WEBGL FUNCTIONS that set WebGLRenderingContext state\n// These \"setters\" map functions to gl parameters\n\nvar GL_STATE_SETTERS = {\n  // GENERIC SETTERS\n  enable: function enable(update, cap) {\n    return update(_defineProperty({}, cap, true));\n  },\n  disable: function disable(update, cap) {\n    return update(_defineProperty({}, cap, false));\n  },\n  pixelStorei: function pixelStorei(update, pname, param) {\n    return update(_defineProperty({}, pname, param));\n  },\n  hint: function hint(update, pname, _hint) {\n    return update(_defineProperty({}, pname, _hint));\n  },\n  // SPECIFIC SETTERS\n  bindFramebuffer: function bindFramebuffer(update, target, fb) {\n    var _update5;\n\n    switch (target) {\n      case GL.FRAMEBUFFER:\n        return update((_update5 = {}, _defineProperty(_update5, GL.DRAW_FRAMEBUFFER_BINDING, fb), _defineProperty(_update5, GL.READ_FRAMEBUFFER_BINDING, fb), _update5));\n\n      case GL.DRAW_FRAMEBUFFER:\n        return update(_defineProperty({}, GL.DRAW_FRAMEBUFFER_BINDING, fb));\n\n      case GL.READ_FRAMEBUFFER:\n        return update(_defineProperty({}, GL.READ_FRAMEBUFFER_BINDING, fb));\n\n      default:\n        return null;\n    }\n  },\n  blendColor: function blendColor(update, r, g, b, a) {\n    return update(_defineProperty({}, GL.BLEND_COLOR, new Float32Array([r, g, b, a])));\n  },\n  blendEquation: function blendEquation(update, mode) {\n    var _update9;\n\n    return update((_update9 = {}, _defineProperty(_update9, GL.BLEND_EQUATION_RGB, mode), _defineProperty(_update9, GL.BLEND_EQUATION_ALPHA, mode), _update9));\n  },\n  blendEquationSeparate: function blendEquationSeparate(update, modeRGB, modeAlpha) {\n    var _update10;\n\n    return update((_update10 = {}, _defineProperty(_update10, GL.BLEND_EQUATION_RGB, modeRGB), _defineProperty(_update10, GL.BLEND_EQUATION_ALPHA, modeAlpha), _update10));\n  },\n  blendFunc: function blendFunc(update, src, dst) {\n    var _update11;\n\n    return update((_update11 = {}, _defineProperty(_update11, GL.BLEND_SRC_RGB, src), _defineProperty(_update11, GL.BLEND_DST_RGB, dst), _defineProperty(_update11, GL.BLEND_SRC_ALPHA, src), _defineProperty(_update11, GL.BLEND_DST_ALPHA, dst), _update11));\n  },\n  blendFuncSeparate: function blendFuncSeparate(update, srcRGB, dstRGB, srcAlpha, dstAlpha) {\n    var _update12;\n\n    return update((_update12 = {}, _defineProperty(_update12, GL.BLEND_SRC_RGB, srcRGB), _defineProperty(_update12, GL.BLEND_DST_RGB, dstRGB), _defineProperty(_update12, GL.BLEND_SRC_ALPHA, srcAlpha), _defineProperty(_update12, GL.BLEND_DST_ALPHA, dstAlpha), _update12));\n  },\n  clearColor: function clearColor(update, r, g, b, a) {\n    return update(_defineProperty({}, GL.COLOR_CLEAR_VALUE, new Float32Array([r, g, b, a])));\n  },\n  clearDepth: function clearDepth(update, depth) {\n    return update(_defineProperty({}, GL.DEPTH_CLEAR_VALUE, depth));\n  },\n  clearStencil: function clearStencil(update, s) {\n    return update(_defineProperty({}, GL.STENCIL_CLEAR_VALUE, s));\n  },\n  colorMask: function colorMask(update, r, g, b, a) {\n    return update(_defineProperty({}, GL.COLOR_WRITEMASK, [r, g, b, a]));\n  },\n  cullFace: function cullFace(update, mode) {\n    return update(_defineProperty({}, GL.CULL_FACE_MODE, mode));\n  },\n  depthFunc: function depthFunc(update, func) {\n    return update(_defineProperty({}, GL.DEPTH_FUNC, func));\n  },\n  depthRange: function depthRange(update, zNear, zFar) {\n    return update(_defineProperty({}, GL.DEPTH_RANGE, new Float32Array([zNear, zFar])));\n  },\n  depthMask: function depthMask(update, mask) {\n    return update(_defineProperty({}, GL.DEPTH_WRITEMASK, mask));\n  },\n  frontFace: function frontFace(update, face) {\n    return update(_defineProperty({}, GL.FRONT_FACE, face));\n  },\n  lineWidth: function lineWidth(update, width) {\n    return update(_defineProperty({}, GL.LINE_WIDTH, width));\n  },\n  polygonOffset: function polygonOffset(update, factor, units) {\n    var _update23;\n\n    return update((_update23 = {}, _defineProperty(_update23, GL.POLYGON_OFFSET_FACTOR, factor), _defineProperty(_update23, GL.POLYGON_OFFSET_UNITS, units), _update23));\n  },\n  sampleCoverage: function sampleCoverage(update, value, invert) {\n    var _update24;\n\n    return update((_update24 = {}, _defineProperty(_update24, GL.SAMPLE_COVERAGE_VALUE, value), _defineProperty(_update24, GL.SAMPLE_COVERAGE_INVERT, invert), _update24));\n  },\n  scissor: function scissor(update, x, y, width, height) {\n    return update(_defineProperty({}, GL.SCISSOR_BOX, new Int32Array([x, y, width, height])));\n  },\n  stencilMask: function stencilMask(update, mask) {\n    var _update26;\n\n    return update((_update26 = {}, _defineProperty(_update26, GL.STENCIL_WRITEMASK, mask), _defineProperty(_update26, GL.STENCIL_BACK_WRITEMASK, mask), _update26));\n  },\n  stencilMaskSeparate: function stencilMaskSeparate(update, face, mask) {\n    return update(_defineProperty({}, face === GL.FRONT ? GL.STENCIL_WRITEMASK : GL.STENCIL_BACK_WRITEMASK, mask));\n  },\n  stencilFunc: function stencilFunc(update, func, ref, mask) {\n    var _update28;\n\n    return update((_update28 = {}, _defineProperty(_update28, GL.STENCIL_FUNC, func), _defineProperty(_update28, GL.STENCIL_REF, ref), _defineProperty(_update28, GL.STENCIL_VALUE_MASK, mask), _defineProperty(_update28, GL.STENCIL_BACK_FUNC, func), _defineProperty(_update28, GL.STENCIL_BACK_REF, ref), _defineProperty(_update28, GL.STENCIL_BACK_VALUE_MASK, mask), _update28));\n  },\n  stencilFuncSeparate: function stencilFuncSeparate(update, face, func, ref, mask) {\n    var _update29;\n\n    return update((_update29 = {}, _defineProperty(_update29, face === GL.FRONT ? GL.STENCIL_FUNC : GL.STENCIL_BACK_FUNC, func), _defineProperty(_update29, face === GL.FRONT ? GL.STENCIL_REF : GL.STENCIL_BACK_REF, ref), _defineProperty(_update29, face === GL.FRONT ? GL.STENCIL_VALUE_MASK : GL.STENCIL_BACK_VALUE_MASK, mask), _update29));\n  },\n  stencilOp: function stencilOp(update, fail, zfail, zpass) {\n    var _update30;\n\n    return update((_update30 = {}, _defineProperty(_update30, GL.STENCIL_FAIL, fail), _defineProperty(_update30, GL.STENCIL_PASS_DEPTH_FAIL, zfail), _defineProperty(_update30, GL.STENCIL_PASS_DEPTH_PASS, zpass), _defineProperty(_update30, GL.STENCIL_BACK_FAIL, fail), _defineProperty(_update30, GL.STENCIL_BACK_PASS_DEPTH_FAIL, zfail), _defineProperty(_update30, GL.STENCIL_BACK_PASS_DEPTH_PASS, zpass), _update30));\n  },\n  stencilOpSeparate: function stencilOpSeparate(update, face, fail, zfail, zpass) {\n    var _update31;\n\n    return update((_update31 = {}, _defineProperty(_update31, face === GL.FRONT ? GL.STENCIL_FAIL : GL.STENCIL_BACK_FAIL, fail), _defineProperty(_update31, face === GL.FRONT ? GL.STENCIL_PASS_DEPTH_FAIL : GL.STENCIL_BACK_PASS_DEPTH_FAIL, zfail), _defineProperty(_update31, face === GL.FRONT ? GL.STENCIL_PASS_DEPTH_PASS : GL.STENCIL_BACK_PASS_DEPTH_PASS, zpass), _update31));\n  },\n  viewport: function viewport(update, x, y, width, height) {\n    return update(_defineProperty({}, GL.VIEWPORT, new Int32Array([x, y, width, height])));\n  }\n}; // HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT\n// Overrides a WebGLRenderingContext state \"getter\" function\n// to return values directly from cache\n\nexport { GL_STATE_SETTERS };\n\nfunction installGetterOverride(gl, functionName) {\n  // Get the original function from the WebGLRenderingContext\n  var originalGetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called\n\n  gl[functionName] = function () {\n    var pname = arguments.length <= 0 ? undefined : arguments[0]; // WebGL limits are not prepopulated in the cache, we must\n    // query first time. They are all primitive (single value)\n\n    if (!(pname in gl.state.cache)) {\n      gl.state.cache[pname] = originalGetterFunc.apply(void 0, arguments);\n    } // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n\n\n    return gl.state.enable ? // Call the getter the params so that it can e.g. serve from a cache\n    gl.state.cache[pname] : // Optionally call the original function to do a \"hard\" query from the WebGLRenderingContext\n    originalGetterFunc.apply(void 0, arguments);\n  }; // Set the name of this anonymous function to help in debugging and profiling\n\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: \"\".concat(functionName, \"-from-cache\"),\n    configurable: false\n  });\n} // Overrides a WebGLRenderingContext state \"setter\" function\n// to call a setter spy before the actual setter. Allows us to keep a cache\n// updated with a copy of the WebGL context state.\n\n\nfunction installSetterSpy(gl, functionName, setter) {\n  // Get the original function from the WebGLRenderingContext\n  var originalSetterFunc = gl[functionName].bind(gl); // Wrap it with a spy so that we can update our state cache when it gets called\n\n  gl[functionName] = function () {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    } // Update the value\n    // Call the setter with the state cache and the params so that it can store the parameters\n\n\n    var _setter = setter.apply(void 0, [gl.state._updateCache].concat(params)),\n        valueChanged = _setter.valueChanged,\n        oldValue = _setter.oldValue; // Call the original WebGLRenderingContext func to make sure the context actually gets updated\n\n\n    if (valueChanged) {\n      var _gl$state;\n\n      (_gl$state = gl.state).log.apply(_gl$state, [\"gl.\".concat(functionName)].concat(params)); // eslint-disable-line\n\n\n      originalSetterFunc.apply(void 0, params);\n    } // Note: if the original function fails to set the value, our state cache will be bad\n    // No solution for this at the moment, but assuming that this is unlikely to be a real problem\n    // We could call the setter after the originalSetterFunc. Concern is that this would\n    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions\n\n\n    return oldValue;\n  }; // Set the name of this anonymous function to help in debugging and profiling\n\n\n  Object.defineProperty(gl[functionName], 'name', {\n    value: \"\".concat(functionName, \"-to-cache\"),\n    configurable: false\n  });\n} // HELPER CLASS - GLState\n\n/* eslint-disable no-shadow */\n\n\nvar GLState =\n/*#__PURE__*/\nfunction () {\n  function GLState(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$copyState = _ref.copyState,\n        copyState = _ref$copyState === void 0 ? false : _ref$copyState,\n        _ref$log = _ref.log,\n        log = _ref$log === void 0 ? function () {} : _ref$log;\n\n    _classCallCheck(this, GLState);\n\n    this.gl = gl;\n    this.stateStack = [];\n    this.enable = true;\n    this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);\n    this.log = log;\n    this._updateCache = this._updateCache.bind(this);\n    Object.seal(this);\n  }\n\n  _createClass(GLState, [{\n    key: \"push\",\n    value: function push() {\n      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.stateStack.push({});\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      assert(this.stateStack.length > 0); // Use the saved values in the state stack to restore parameters\n\n      var oldValues = this.stateStack[this.stateStack.length - 1];\n      setParameters(this.gl, oldValues, this.cache); // Don't pop until we have reset parameters (to make sure other \"stack frames\" are not affected)\n\n      this.stateStack.pop();\n    } // interceptor for context set functions - update our cache and our stack\n    // values (Object) - the key values for this setter\n\n  }, {\n    key: \"_updateCache\",\n    value: function _updateCache(values) {\n      var valueChanged = false;\n      var oldValue; // = undefined\n\n      var oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];\n\n      for (var key in values) {\n        assert(key !== undefined); // Check that value hasn't already been shadowed\n\n        if (!deepEqual(values[key], this.cache[key])) {\n          valueChanged = true;\n          oldValue = this.cache[key]; // First, save current value being shadowed\n          // If a state stack frame is active, save the current parameter values for pop\n          // but first check that value hasn't already been shadowed and saved\n\n          if (oldValues && !(key in oldValues)) {\n            oldValues[key] = this.cache[key];\n          } // Save current value being shadowed\n\n\n          this.cache[key] = values[key];\n        }\n      }\n\n      return {\n        valueChanged: valueChanged,\n        oldValue: oldValue\n      };\n    }\n  }]);\n\n  return GLState;\n}(); // PUBLIC API\n\n/**\n * Initialize WebGL state caching on a context\n * can be called multiple times to enable/disable\n * @param {WebGLRenderingContext} - context\n */\n// After calling this function, context state will be cached\n// gl.state.push() and gl.state.pop() will be available for saving,\n// temporarily modifying, and then restoring state.\n\n\nexport default function trackContextState(gl) {\n  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$enable = _ref2.enable,\n      enable = _ref2$enable === void 0 ? true : _ref2$enable,\n      copyState = _ref2.copyState;\n\n  assert(copyState !== undefined);\n\n  if (!gl.state) {\n    polyfillContext(gl); // Create a state cache\n\n    gl.state = new GLState(gl, {\n      copyState: copyState,\n      enable: enable\n    }); // intercept all setter functions in the table\n\n    for (var key in GL_STATE_SETTERS) {\n      var setter = GL_STATE_SETTERS[key];\n      installSetterSpy(gl, key, setter);\n    } // intercept all getter functions in the table\n\n\n    installGetterOverride(gl, 'getParameter');\n    installGetterOverride(gl, 'isEnabled');\n  }\n\n  gl.state.enable = enable;\n  return gl;\n}\nexport function pushContextState(gl) {\n  if (!gl.state) {\n    trackContextState(gl, {\n      copyState: false\n    });\n  }\n\n  gl.state.push();\n}\nexport function popContextState(gl) {\n  assert(gl.state);\n  gl.state.pop();\n}","map":null,"metadata":{},"sourceType":"module"}