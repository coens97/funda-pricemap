{"ast":null,"code":"import assert from 'assert';\nimport { combineInjects, getQualifierDetails, typeToChannelSuffix } from '../shadertools/src';\nvar SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nvar SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nvar VS_POS_VARIABLE = 'transform_position'; // Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for size and sampler\n// for texture target, get varying type and inject position instruction\n\nexport function updateForTextures(_ref) {\n  var vs = _ref.vs,\n      sourceTextureMap = _ref.sourceTextureMap,\n      targetTextureVarying = _ref.targetTextureVarying,\n      targetTexture = _ref.targetTexture;\n  var texAttributeNames = Object.keys(sourceTextureMap);\n  var sourceCount = texAttributeNames.length;\n  var targetTextureType = null;\n  var uniforms = {};\n  var samplerTextureMap = {};\n  var updatedVs = vs;\n  var finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    var vsLines = updatedVs.split('\\n');\n    var updateVsLines = vsLines.slice();\n    vsLines.forEach(function (line, index, lines) {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        var updated = processAttributeDefinition(line, sourceTextureMap);\n\n        if (updated) {\n          var updatedLine = updated.updatedLine,\n              inject = updated.inject;\n          updateVsLines[index] = updatedLine; // sampleInstructions.push(sampleInstruction);\n\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(uniforms, updated.uniforms);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      var sizeName = \"\".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);\n      var width = targetTexture.width,\n          height = targetTexture.height;\n      uniforms[sizeName] = [width, height];\n      var uniformDeclaration = \"uniform vec2 \".concat(sizeName, \";\\n\");\n      var posInstructions = \"     vec2 \".concat(VS_POS_VARIABLE, \" = transform_getPos(\").concat(sizeName, \");\\n     gl_Position = vec4(\").concat(VS_POS_VARIABLE, \", 0, 1.);\\n\");\n      var inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n\n    updatedVs = updateVsLines.join('\\n');\n  }\n\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // sampler size unitforms\n    uniforms: uniforms,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType: targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap: samplerTextureMap\n  };\n} // Checks if provided line is defining an attribute, if so returns details otherwise null\n\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  var samplerName = \"\".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);\n  var sizeName = \"\".concat(SIZE_UNIFORM_PREFIX).concat(textureName);\n  var uniformDeclerations = \"  uniform sampler2D \".concat(samplerName, \";\\n  uniform vec2 \").concat(sizeName, \";\");\n  return {\n    samplerName: samplerName,\n    sizeName: sizeName,\n    uniformDeclerations: uniformDeclerations\n  };\n} // Return size (float, vec2 etc) of a given varying, null if doens't exist.\n\n\nexport function getVaryingType(line, varying) {\n  var qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n\n  if (!qualaiferDetails) {\n    return null;\n  }\n\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n} // build required definitions, sample instructions and uniforms for each texture attribute\n\nexport function processAttributeDefinition(line, textureMap) {\n  var uniforms = {};\n  var samplerTextureMap = {};\n  var attributeData = getAttributeDefinition(line);\n\n  if (!attributeData) {\n    return null;\n  }\n\n  var type = attributeData.type,\n      name = attributeData.name;\n\n  if (name && textureMap[name]) {\n    var updatedLine = \"// \".concat(line, \" => Replaced by Transform with a sampler\");\n\n    var _getSamplerDecleratio = getSamplerDeclerations(name),\n        samplerName = _getSamplerDecleratio.samplerName,\n        sizeName = _getSamplerDecleratio.sizeName,\n        uniformDeclerations = _getSamplerDecleratio.uniformDeclerations;\n\n    var channels = typeToChannelSuffix(type);\n    var sampleInstruction = \"  \".concat(type, \" \").concat(name, \" = transform_getInput(\").concat(samplerName, \", \").concat(sizeName, \").\").concat(channels, \";\\n\");\n    var _textureMap$name = textureMap[name],\n        width = _textureMap$name.width,\n        height = _textureMap$name.height;\n    samplerTextureMap[samplerName] = name;\n    uniforms[sizeName] = [width, height];\n    var inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    }; // samplerNameMap\n\n    return {\n      // update vertex shader line.\n      updatedLine: updatedLine,\n      // inject object with sampler instructions.\n      inject: inject,\n      // sampler size uniforms\n      uniforms: uniforms,\n      // sampler name to texture name map\n      samplerTextureMap: samplerTextureMap\n    };\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}