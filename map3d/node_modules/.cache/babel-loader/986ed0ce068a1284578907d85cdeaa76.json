{"ast":null,"code":"function _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { get } from '../../../lib/utils';\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\n\nexport function getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  var type = get(geojson, 'type');\n\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'Polygon':\n    case 'MultiPolygon':\n    case 'GeometryCollection':\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{\n        type: 'Feature',\n        properties: {},\n        geometry: geojson\n      }];\n\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      return get(geojson, 'features');\n\n    default:\n      throw new Error('Unknown geojson type');\n  }\n}\n/*\n * converts a GeoJSON \"Feature\" object to a list of GeoJSON polygon-style coordinates\n * @param {Object | Array} data - geojson object or array of feature\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\n\nexport function featureToPolygons(feature) {\n  var geometry = get(feature, 'geometry'); // If no geometry field, assume that \"feature\" is the polygon list\n\n  if (geometry === undefined) {\n    return feature;\n  }\n\n  var type = get(geometry, 'type');\n  var coordinates = get(geometry, 'coordinates');\n  var polygons = void 0;\n\n  switch (type) {\n    case 'MultiPolygon':\n      polygons = coordinates;\n      break;\n\n    case 'Polygon':\n      polygons = [coordinates];\n      break;\n\n    case 'LineString':\n      // TODO - should lines really be handled in this switch?\n      polygons = [[coordinates]];\n      break;\n\n    case 'MultiLineString':\n      // TODO - should lines really be handled in this switch?\n      polygons = coordinates.map(function (coords) {\n        return [coords];\n      });\n      break;\n\n    default:\n      polygons = [];\n  }\n\n  return polygons;\n} // DEPRECATED - USED BY OLD CHOROPLETH LAYERS\n\n/*\n * converts list of features from a GeoJSON object to a list of GeoJSON\n * polygon-style coordinates\n * @param {Object} data - geojson object\n * @returns {[Number,Number,Number][][][]} array of choropleths\n */\n\nexport function extractPolygons(data) {\n  var normalizedGeojson = normalizeGeojson(data);\n  var features = get(normalizedGeojson, 'features');\n  var result = [];\n  features.forEach(function (feature, featureIndex) {\n    var choropleths = featureToPolygons(feature);\n    /* eslint-disable max-nested-callbacks */\n\n    choropleths = choropleths.map(function (choropleth) {\n      return choropleth.map(function (polygon) {\n        return polygon.map(function (coord) {\n          return [get(coord, 0), get(coord, 1), get(coord, 2) || 0];\n        });\n      });\n    });\n    /* eslint-enable max-nested-callbacks */\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = choropleths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var choropleth = _step.value;\n        choropleth.featureIndex = featureIndex;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    result.push.apply(result, _toConsumableArray(choropleths));\n  });\n  return result;\n}\n/**\n * \"Normalizes\" a GeoJSON geometry or \"Feature\" into a \"FeatureCollection\",\n * by wrapping it in an extra object/array.\n *\n * @param {object} geojson - geojson data\n * @return {object} - normalized geojson data\n */\n\nexport function normalizeGeojson(geojson) {\n  var type = get(geojson, 'type');\n\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'Polygon':\n    case 'MultiPolygon':\n    case 'GeometryCollection':\n      // Wrap the geometry object in a \"Feature\" and add the feature to a \"FeatureCollection\"\n      return {\n        type: 'FeatureCollection',\n        features: [{\n          type: 'Feature',\n          properties: {},\n          geometry: geojson\n        }]\n      };\n\n    case 'Feature':\n      // Add the feature to a \"FeatureCollection\"\n      return {\n        type: 'FeatureCollection',\n        features: [geojson]\n      };\n\n    case 'FeatureCollection':\n      // Just return the feature collection\n      return geojson;\n\n    default:\n      throw new Error('Unknown geojson type');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}