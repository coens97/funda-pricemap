{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport Resource from './resource';\nimport Accessor from './accessor';\nimport { assertWebGL2Context } from '../webgl-utils';\nimport { getGLTypeFromTypedArray, getTypedArrayFromGLType } from '../webgl-utils/typed-array-utils';\nimport { log } from '../utils';\nimport assert from '../utils/assert';\nvar DEBUG_DATA_LENGTH = 10;\n\nvar Buffer =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Buffer, _Resource);\n\n  function Buffer(gl) {\n    var _this;\n\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Buffer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Buffer).call(this, gl, props));\n\n    _this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']); // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers\n    // otherwise buffer type will lock to generic (non-element) buffer\n    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here\n\n\n    _this.target = props.target || (_this.gl.webgl2 ? 36662 : 34962);\n\n    _this._initialize(props);\n\n    Object.seal(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  } // returns number of elements in the buffer (assuming that the full buffer is used)\n\n\n  _createClass(Buffer, [{\n    key: \"getElementCount\",\n    value: function getElementCount() {\n      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));\n    } // returns number of vertices in the buffer (assuming that the full buffer is used)\n\n  }, {\n    key: \"getVertexCount\",\n    value: function getVertexCount() {\n      var accessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.accessor;\n      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));\n    } // Creates and initializes the buffer object's data store.\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(props) {\n      return this._initialize(props);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('data' in props) {\n        this.setData(props);\n      }\n\n      return this;\n    } // Stores the accessor of data with the buffer, makes it easy to e.g. set it as an attribute later\n    // {accessor,type,size = 1,offset = 0,stride = 0,normalized = false,integer = false,divisor = 0}\n\n  }, {\n    key: \"setAccessor\",\n    value: function setAccessor(opts) {\n      this.accessor = opts;\n      return this;\n    } // Allocate a bigger GPU buffer (if the current buffer is not big enough).\n    // If a reallocation is triggered it clears the buffer\n    // Returns:\n    //  `true`: buffer was reallocated, data was cleared\n    //  `false`: buffer was big enough, data is intact\n\n  }, {\n    key: \"reallocate\",\n    value: function reallocate(byteLength) {\n      if (byteLength > this.byteLength) {\n        this._setByteLength(byteLength);\n\n        return true;\n      }\n\n      this.bytesUsed = byteLength;\n      return false;\n    } // Update with new data\n\n  }, {\n    key: \"setData\",\n    value: function setData(opts) {\n      return this.initialize(opts);\n    } // Updates a subset of a buffer object's data store.\n    // Data (Typed Array or ArrayBuffer), length is inferred unless provided\n    // Offset into buffer\n    // WebGL2 only: Offset into srcData\n    // WebGL2 only: Number of bytes to be copied\n\n  }, {\n    key: \"subData\",\n    value: function subData(props) {\n      // Signature: buffer.subData(new Float32Array([...]))\n      if (ArrayBuffer.isView(props)) {\n        props = {\n          data: props\n        };\n      }\n\n      var _props = props,\n          data = _props.data,\n          _props$offset = _props.offset,\n          offset = _props$offset === void 0 ? 0 : _props$offset,\n          _props$srcOffset = _props.srcOffset,\n          srcOffset = _props$srcOffset === void 0 ? 0 : _props$srcOffset;\n      var byteLength = props.byteLength || props.length; // if (byteLength > this.byteLength) {\n      //   byteLength = this.byteLength;\n      // }\n\n      assert(data); // Create the buffer - binding it here for the first time locks the type\n      // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n\n      var target = this.gl.webgl2 ? 36663 : this.target;\n      this.gl.bindBuffer(target, this.handle); // WebGL2: subData supports additional srcOffset and length parameters\n\n      if (srcOffset !== 0 || byteLength !== undefined) {\n        assertWebGL2Context(this.gl);\n        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);\n      } else {\n        this.gl.bufferSubData(target, offset, data);\n      }\n\n      this.gl.bindBuffer(target, null); // TODO - update local `data` if offsets are right\n\n      this.debugData = null;\n\n      if (!this.accessor.type) {\n        this.setAccessor(new Accessor(this.accessor, {\n          type: getGLTypeFromTypedArray(data)\n        }));\n      }\n\n      return this;\n    } // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer\n\n  }, {\n    key: \"copyData\",\n    value: function copyData(_ref) {\n      var sourceBuffer = _ref.sourceBuffer,\n          _ref$readOffset = _ref.readOffset,\n          readOffset = _ref$readOffset === void 0 ? 0 : _ref$readOffset,\n          _ref$writeOffset = _ref.writeOffset,\n          writeOffset = _ref$writeOffset === void 0 ? 0 : _ref$writeOffset,\n          size = _ref.size;\n      var gl = this.gl;\n      assertWebGL2Context(gl); // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type\n\n      gl.bindBuffer(36662, sourceBuffer.handle);\n      gl.bindBuffer(36663, this.handle);\n      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size);\n      gl.bindBuffer(36662, null);\n      gl.bindBuffer(36663, null); // TODO - update local `data` if offsets are 0\n\n      this.debugData = null;\n      return this;\n    } // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.\n\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$dstData = _ref2.dstData,\n          dstData = _ref2$dstData === void 0 ? null : _ref2$dstData,\n          _ref2$srcByteOffset = _ref2.srcByteOffset,\n          srcByteOffset = _ref2$srcByteOffset === void 0 ? 0 : _ref2$srcByteOffset,\n          _ref2$dstOffset = _ref2.dstOffset,\n          dstOffset = _ref2$dstOffset === void 0 ? 0 : _ref2$dstOffset,\n          _ref2$length = _ref2.length,\n          length = _ref2$length === void 0 ? 0 : _ref2$length;\n\n      assertWebGL2Context(this.gl);\n      var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n        clamped: false\n      });\n\n      var sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);\n\n      var dstElementOffset = dstOffset;\n      var dstAvailableElementCount;\n      var dstElementCount;\n\n      if (dstData) {\n        dstElementCount = dstData.length;\n        dstAvailableElementCount = dstElementCount - dstElementOffset;\n      } else {\n        // Allocate ArrayBufferView with enough size to copy all eligible data.\n        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length || sourceAvailableElementCount);\n        dstElementCount = dstElementOffset + dstAvailableElementCount;\n      }\n\n      var copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);\n      length = length || copyElementCount;\n      assert(length <= copyElementCount);\n      dstData = dstData || new ArrayType(dstElementCount); // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type\n\n      this.gl.bindBuffer(36662, this.handle);\n      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length);\n      this.gl.bindBuffer(36662, null); // TODO - update local `data` if offsets are 0\n\n      return dstData;\n    }\n    /**\n     * Binds a buffer to a given binding point (target).\n     *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.\n     * @param {Glenum} target - target for the bind operation.\n     * @param {GLuint} index= - the index of the target.\n     *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state\n     * @param {GLuint} offset=0 - the index of the target.\n     *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.\n     * @param {GLuint} size= - the index of the target.\n     *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.\n     * @returns {Buffer} - Returns itself for chaining.\n     */\n\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$target = _ref3.target,\n          target = _ref3$target === void 0 ? this.target : _ref3$target,\n          _ref3$index = _ref3.index,\n          index = _ref3$index === void 0 ? this.accessor && this.accessor.index : _ref3$index,\n          _ref3$offset = _ref3.offset,\n          offset = _ref3$offset === void 0 ? 0 : _ref3$offset,\n          size = _ref3.size; // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could\n      // be used as direct binding points, they will not affect transform feedback or\n      // uniform buffer state. Instead indexed bindings need to be made.\n\n\n      if (target === 35345 || target === 35982) {\n        if (size !== undefined) {\n          this.gl.bindBufferRange(target, index, this.handle, offset, size);\n        } else {\n          assert(offset === 0); // Make sure offset wasn't supplied\n\n          this.gl.bindBufferBase(target, index, this.handle);\n        }\n      } else {\n        this.gl.bindBuffer(target, this.handle);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$target = _ref4.target,\n          target = _ref4$target === void 0 ? this.target : _ref4$target,\n          _ref4$index = _ref4.index,\n          index = _ref4$index === void 0 ? this.accessor && this.accessor.index : _ref4$index;\n\n      var isIndexedBuffer = target === 35345 || target === 35982;\n\n      if (isIndexedBuffer) {\n        this.gl.bindBufferBase(target, index, null);\n      } else {\n        this.gl.bindBuffer(target, null);\n      }\n\n      return this;\n    } // DEPRECATED/REMOVED METHODS\n\n  }, {\n    key: \"getDebugData\",\n    // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)\n    // Returns a short initial data array\n    value: function getDebugData() {\n      if (!this.debugData) {\n        this.debugData = this.getData({\n          length: DEBUG_DATA_LENGTH\n        });\n        return {\n          data: this.debugData,\n          changed: true\n        };\n      }\n\n      return {\n        data: this.debugData,\n        changed: false\n      };\n    }\n  }, {\n    key: \"invalidateDebugData\",\n    value: function invalidateDebugData() {\n      this.debugData = null;\n    } // PRIVATE METHODS\n    // Signature: `new Buffer(gl, {data: new Float32Array(...)})`\n    // Signature: `new Buffer(gl, new Float32Array(...))`\n    // Signature: `new Buffer(gl, 100)`\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Signature `new Buffer(gl, new Float32Array(...)`\n\n      if (ArrayBuffer.isView(props)) {\n        props = {\n          data: props\n        };\n      } // Signature: `new Buffer(gl, 100)`\n\n\n      if (Number.isFinite(props)) {\n        props = {\n          byteLength: props\n        };\n      }\n\n      if (props.bytes) {\n        log.deprecated('bytes', 'byteLength');\n      }\n\n      var byteLength = props.byteLength || props.bytes || 0; // assert(props.data || byteLength);\n\n      this.usage = props.usage || 35044; // DEPRECATE - remove `props` from this list in next major release\n\n      this.setAccessor(new Accessor(props, props.accessor));\n      return props.data ? this._setData(props.data) : this._setByteLength(byteLength);\n    } // Allocate a new buffer and initialize to contents of typed array\n\n  }, {\n    key: \"_setData\",\n    value: function _setData(data) {\n      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;\n      assert(ArrayBuffer.isView(data));\n\n      var target = this._getTarget();\n\n      this.gl.bindBuffer(target, this.handle);\n      this.gl.bufferData(target, data, usage);\n      this.gl.bindBuffer(target, null);\n      this.usage = usage;\n      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);\n      this.byteLength = data.byteLength;\n      this.bytesUsed = data.byteLength; // infer GL type from supplied typed array\n\n      var type = getGLTypeFromTypedArray(data);\n      assert(type);\n      this.setAccessor(new Accessor(this.accessor, {\n        type: type\n      }));\n      return this;\n    } // Allocate a GPU buffer of specified size.\n\n  }, {\n    key: \"_setByteLength\",\n    value: function _setByteLength(byteLength) {\n      var usage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.usage;\n      assert(byteLength >= 0); // Workaround needed for Safari (#291):\n      // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.\n\n      var data = byteLength;\n\n      if (byteLength === 0) {\n        data = new Float32Array(0);\n      }\n\n      var target = this._getTarget();\n\n      this.gl.bindBuffer(target, this.handle);\n      this.gl.bufferData(target, data, usage);\n      this.gl.bindBuffer(target, null);\n      this.usage = usage;\n      this.debugData = null;\n      this.byteLength = byteLength;\n      this.bytesUsed = byteLength;\n      return this;\n    } // Binding a buffer for the first time locks the type\n    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type\n\n  }, {\n    key: \"_getTarget\",\n    value: function _getTarget() {\n      return this.gl.webgl2 ? 36663 : this.target;\n    }\n  }, {\n    key: \"_getAvailableElementCount\",\n    value: function _getAvailableElementCount(srcByteOffset) {\n      var ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {\n        clamped: false\n      });\n      var sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;\n      return this.getElementCount() - sourceElementOffset;\n    } // RESOURCE METHODS\n\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createBuffer();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteBuffer(this.handle);\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      this.gl.bindBuffer(this.target, this.handle);\n      var value = this.gl.getBufferParameter(this.target, pname);\n      this.gl.bindBuffer(this.target, null);\n      return value;\n    } // DEPRECATED\n\n  }, {\n    key: \"updateAccessor\",\n    value: function updateAccessor(opts) {\n      log.deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)');\n      this.accessor = new Accessor(this.accessor, opts);\n      return this;\n    }\n  }, {\n    key: \"setByteLength\",\n    value: function setByteLength(byteLength) {\n      log.deprecated('setByteLength', 'reallocate');\n      return this.reallocate(byteLength);\n    }\n  }, {\n    key: \"data\",\n    get: function get() {\n      log.removed('Buffer.data', 'N/A', 'v6.0');\n    }\n  }, {\n    key: \"bytes\",\n    get: function get() {\n      log.deprecated('Buffer.bytes', 'Buffer.byteLength', 'v6.1');\n      return this.byteLength;\n    }\n  }]);\n\n  return Buffer;\n}(Resource);\n\nexport { Buffer as default };","map":null,"metadata":{},"sourceType":"module"}