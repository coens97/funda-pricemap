{"ast":null,"code":"function _instanceof(left, right) {\n  return null != right && \"undefined\" != typeof Symbol && right[Symbol.hasInstance] ? right[Symbol.hasInstance](left) : left instanceof right;\n}\n\nfunction _typeof(obj) {\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  return call && (\"object\" === _typeof(call) || \"function\" == typeof call) ? call : _assertThisInitialized(self);\n}\n\nfunction _defineProperties(target, props) {\n  for (var descriptor, i = 0; i < props.length; i++) {\n    descriptor = props[i], descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\");\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: !0,\n      configurable: !0\n    }\n  }), superClass && _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  return _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    return o.__proto__ = p, o;\n  }, _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return self;\n}\n\nimport { PureComponent, createElement } from \"react\";\nimport PropTypes from \"prop-types\";\nimport StaticMap from \"./static-map\";\nimport { MAPBOX_LIMITS } from \"../utils/map-state\";\nimport WebMercatorViewport from \"viewport-mercator-project\";\nimport TransitionManager from \"../utils/transition-manager\";\nimport { getInteractiveLayerIds } from \"../utils/style-utils\";\nimport { EventManager } from \"mjolnir.js\";\nimport MapControls from \"../utils/map-controls\";\nimport config from \"../config\";\nimport deprecateWarn from \"../utils/deprecate-warn\";\n\nvar propTypes = Object.assign({}, StaticMap.propTypes, {\n  maxZoom: PropTypes.number,\n  minZoom: PropTypes.number,\n  maxPitch: PropTypes.number,\n  minPitch: PropTypes.number,\n  onViewStateChange: PropTypes.func,\n  onViewportChange: PropTypes.func,\n  transitionDuration: PropTypes.number,\n  transitionInterpolator: PropTypes.object,\n  transitionInterruption: PropTypes.number,\n  transitionEasing: PropTypes.func,\n  onTransitionStart: PropTypes.func,\n  onTransitionInterrupt: PropTypes.func,\n  onTransitionEnd: PropTypes.func,\n  scrollZoom: PropTypes.bool,\n  dragPan: PropTypes.bool,\n  dragRotate: PropTypes.bool,\n  doubleClickZoom: PropTypes.bool,\n  touchZoom: PropTypes.bool,\n  touchRotate: PropTypes.bool,\n  keyboard: PropTypes.bool,\n  onHover: PropTypes.func,\n  onClick: PropTypes.func,\n  onContextMenu: PropTypes.func,\n  touchAction: PropTypes.string,\n  clickRadius: PropTypes.number,\n  getCursor: PropTypes.func,\n  mapControls: PropTypes.shape({\n    events: PropTypes.arrayOf(PropTypes.string),\n    handleEvent: PropTypes.func\n  })\n}),\n    getDefaultCursor = function getDefaultCursor(_ref) {\n  var isDragging = _ref.isDragging,\n      isHovering = _ref.isHovering;\n  return isDragging ? config.CURSOR.GRABBING : isHovering ? config.CURSOR.POINTER : config.CURSOR.GRAB;\n},\n    defaultProps = Object.assign({}, StaticMap.defaultProps, MAPBOX_LIMITS, TransitionManager.defaultProps, {\n  onViewStateChange: null,\n  onViewportChange: null,\n  onClick: null,\n  onHover: null,\n  onContextMenu: function onContextMenu(event) {\n    return event.preventDefault();\n  },\n  scrollZoom: !0,\n  dragPan: !0,\n  dragRotate: !0,\n  doubleClickZoom: !0,\n  touchAction: \"none\",\n  clickRadius: 0,\n  getCursor: getDefaultCursor\n}),\n    childContextTypes = {\n  viewport: PropTypes.instanceOf(WebMercatorViewport),\n  isDragging: PropTypes.bool,\n  eventManager: PropTypes.object\n},\n    InteractiveMap = function (_PureComponent) {\n  function InteractiveMap(props) {\n    var _this;\n\n    return _classCallCheck(this, InteractiveMap), _this = _possibleConstructorReturn(this, (InteractiveMap.__proto__ || Object.getPrototypeOf(InteractiveMap)).call(this, props)), deprecateWarn(props), _this.state = {\n      isDragging: !1,\n      isHovering: !1\n    }, _this._mapControls = props.mapControls || new MapControls(), _this._eventManager = new EventManager(null, {\n      legacyBlockScroll: !1,\n      touchAction: props.touchAction\n    }), _this._updateQueryParams(props.mapStyle), _this.getMap = _this.getMap.bind(_assertThisInitialized(_this)), _this.queryRenderedFeatures = _this.queryRenderedFeatures.bind(_assertThisInitialized(_this)), _this._getFeatures = _this._getFeatures.bind(_assertThisInitialized(_this)), _this._updateQueryParams = _this._updateQueryParams.bind(_assertThisInitialized(_this)), _this._onInteractiveStateChange = _this._onInteractiveStateChange.bind(_assertThisInitialized(_this)), _this._getPos = _this._getPos.bind(_assertThisInitialized(_this)), _this._eventCanvasLoaded = _this._eventCanvasLoaded.bind(_assertThisInitialized(_this)), _this._staticMapLoaded = _this._staticMapLoaded.bind(_assertThisInitialized(_this)), _this;\n  }\n\n  return _inherits(InteractiveMap, _PureComponent), _createClass(InteractiveMap, null, [{\n    key: \"supported\",\n    value: function supported() {\n      return StaticMap.supported();\n    }\n  }]), _createClass(InteractiveMap, [{\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      return {\n        viewport: new WebMercatorViewport(this.props),\n        isDragging: this.state.isDragging,\n        eventManager: this._eventManager\n      };\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var eventManager = this._eventManager;\n      eventManager.on({\n        mousemove: this._onMouseMove.bind(this),\n        click: this._onMouseClick.bind(this),\n        contextmenu: this._onContextMenu.bind(this)\n      }), this._mapControls.setOptions(Object.assign({}, this.props, this.props.viewState, {\n        onStateChange: this._onInteractiveStateChange,\n        eventManager: eventManager\n      })), this._transitionManager = new TransitionManager(this.props);\n    }\n  }, {\n    key: \"componentWillUpdate\",\n    value: function componentWillUpdate(nextProps) {\n      this.props.mapStyle !== nextProps.mapStyle && this._updateQueryParams(nextProps.mapStyle);\n      var nextPropsWithViewState = Object.assign({}, nextProps, nextProps.viewState);\n      this._mapControls.setOptions(nextPropsWithViewState), this._transitionManager.processViewportChange(nextPropsWithViewState);\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return this._map ? this._map.getMap() : null;\n    }\n  }, {\n    key: \"queryRenderedFeatures\",\n    value: function queryRenderedFeatures(geometry, options) {\n      return this._map.queryRenderedFeatures(geometry, options);\n    }\n  }, {\n    key: \"_getFeatures\",\n    value: function _getFeatures(_ref2) {\n      var features,\n          pos = _ref2.pos,\n          radius = _ref2.radius;\n\n      if (radius) {\n        var size = radius,\n            bbox = [[pos[0] - size, pos[1] + size], [pos[0] + size, pos[1] - size]];\n        features = this._map.queryRenderedFeatures(bbox, this._queryParams);\n      } else features = this._map.queryRenderedFeatures(pos, this._queryParams);\n\n      return features;\n    }\n  }, {\n    key: \"_updateQueryParams\",\n    value: function _updateQueryParams(mapStyle) {\n      var interactiveLayerIds = getInteractiveLayerIds(mapStyle);\n      this._queryParams = {\n        layers: interactiveLayerIds\n      };\n    }\n  }, {\n    key: \"_onInteractiveStateChange\",\n    value: function _onInteractiveStateChange(_ref3) {\n      var _ref3$isDragging = _ref3.isDragging,\n          isDragging = void 0 !== _ref3$isDragging && _ref3$isDragging;\n      isDragging !== this.state.isDragging && this.setState({\n        isDragging: isDragging\n      });\n    }\n  }, {\n    key: \"_getPos\",\n    value: function _getPos(event) {\n      var _event$offsetCenter = event.offsetCenter,\n          x = _event$offsetCenter.x,\n          y = _event$offsetCenter.y;\n      return [x, y];\n    }\n  }, {\n    key: \"_onMouseMove\",\n    value: function _onMouseMove(event) {\n      if (!this.state.isDragging) {\n        var pos = this._getPos(event),\n            features = this._getFeatures({\n          pos: pos,\n          radius: this.props.clickRadius\n        }),\n            isHovering = features && 0 < features.length;\n\n        if (isHovering !== this.state.isHovering && this.setState({\n          isHovering: isHovering\n        }), this.props.onHover) {\n          var viewport = new WebMercatorViewport(this.props);\n          event.lngLat = viewport.unproject(pos), event.features = features, this.props.onHover(event);\n        }\n      }\n    }\n  }, {\n    key: \"_onMouseClick\",\n    value: function _onMouseClick(event) {\n      if (this.props.onClick) {\n        var pos = this._getPos(event),\n            viewport = new WebMercatorViewport(this.props);\n\n        event.lngLat = viewport.unproject(pos), event.features = this._getFeatures({\n          pos: pos,\n          radius: this.props.clickRadius\n        }), this.props.onClick(event);\n      }\n    }\n  }, {\n    key: \"_onContextMenu\",\n    value: function _onContextMenu(event) {\n      this.props.onContextMenu && this.props.onContextMenu(event);\n    }\n  }, {\n    key: \"_eventCanvasLoaded\",\n    value: function _eventCanvasLoaded(ref) {\n      this._eventManager.setElement(ref);\n    }\n  }, {\n    key: \"_staticMapLoaded\",\n    value: function _staticMapLoaded(ref) {\n      this._map = ref;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          width = _this$props.width,\n          height = _this$props.height,\n          getCursor = _this$props.getCursor,\n          eventCanvasStyle = {\n        width: width,\n        height: height,\n        position: \"relative\",\n        cursor: getCursor(this.state)\n      };\n      return createElement(\"div\", {\n        key: \"map-controls\",\n        ref: this._eventCanvasLoaded,\n        style: eventCanvasStyle\n      }, createElement(StaticMap, Object.assign({}, this.props, this._transitionManager && this._transitionManager.getViewportInTransition(), {\n        ref: this._staticMapLoaded,\n        children: this.props.children\n      })));\n    }\n  }]), InteractiveMap;\n}(PureComponent);\n\nexport { InteractiveMap as default };\nInteractiveMap.displayName = \"InteractiveMap\", InteractiveMap.propTypes = propTypes, InteractiveMap.defaultProps = defaultProps, InteractiveMap.childContextTypes = childContextTypes;","map":null,"metadata":{},"sourceType":"module"}