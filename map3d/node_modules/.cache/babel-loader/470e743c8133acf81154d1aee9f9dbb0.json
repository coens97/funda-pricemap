{"ast":null,"code":"var _SHADER_TYPE, _MODULE_INJECTORS;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { resolveModules, getShaderModule } from './shader-modules';\nimport { getPlatformShaderDefines, getVersionDefines } from './platform-defines';\nimport { MODULE_INJECTORS_VS, MODULE_INJECTORS_FS } from '../modules/module-injectors';\nimport assert from 'assert';\nvar VERTEX_SHADER = 'vs';\nvar FRAGMENT_SHADER = 'fs';\nvar SHADER_TYPE = (_SHADER_TYPE = {}, _defineProperty(_SHADER_TYPE, VERTEX_SHADER, 'vertex'), _defineProperty(_SHADER_TYPE, FRAGMENT_SHADER, 'fragment'), _SHADER_TYPE);\nvar MODULE_INJECTORS = (_MODULE_INJECTORS = {}, _defineProperty(_MODULE_INJECTORS, VERTEX_SHADER, MODULE_INJECTORS_VS), _defineProperty(_MODULE_INJECTORS, FRAGMENT_SHADER, MODULE_INJECTORS_FS), _MODULE_INJECTORS); // Precision prologue to inject before functions are injected in shader\n// TODO - extract any existing prologue in the fragment source and move it up...\n\nvar FRAGMENT_SHADER_PROLOGUE = '#ifdef GL_ES\\nprecision highp float;\\n#endif\\n\\n'; // Generate \"glslify-compatible\" SHADER_NAME defines\n// These are understood by the GLSL error parsing function\n// If id is provided and no SHADER_NAME constant is present in source, create one\n\nfunction getShaderName(_ref) {\n  var id = _ref.id,\n      source = _ref.source,\n      type = _ref.type;\n  var injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;\n  return injectShaderName ? '\\n#define SHADER_NAME ' + id + '_' + SHADER_TYPE[type] + '\\n\\n' : '';\n} // Generates application defines from an object\n\n\nfunction getApplicationDefines() {\n  var defines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var count = 0;\n  var sourceText = '';\n\n  for (var define in defines) {\n    if (count === 0) {\n      sourceText += '\\n// APPLICATION DEFINES\\n';\n    }\n\n    count++;\n    sourceText += '#define ' + define.toUpperCase() + ' ' + defines[define] + '\\n';\n  }\n\n  if (count === 0) {\n    sourceText += '\\n';\n  }\n\n  return sourceText;\n} // Extracts the source code chunk for the specified shader type from the named shader module\n\n\nfunction getModuleSource(moduleName, type) {\n  var shaderModule = getShaderModule(moduleName);\n  var moduleSource = void 0;\n\n  switch (type) {\n    case VERTEX_SHADER:\n      moduleSource = shaderModule.vs || shaderModule.vertexShader;\n      break;\n\n    case FRAGMENT_SHADER:\n      moduleSource = shaderModule.fs || shaderModule.fragmentShader;\n      break;\n\n    default:\n      assert(false);\n  }\n\n  if (typeof moduleSource !== 'string') {\n    return '';\n  }\n\n  return '#define MODULE_' + moduleName.toUpperCase() + '\\n' + moduleSource + '// END MODULE_' + moduleName + '\\n\\n';\n} // Pulls together complete source code for either a vertex or a fragment shader\n// adding prologues, requested module chunks, and any final injections.\n\n\nfunction assembleShader(gl, _ref2) {\n  var id = _ref2.id,\n      source = _ref2.source,\n      type = _ref2.type,\n      _ref2$modules = _ref2.modules,\n      modules = _ref2$modules === undefined ? [] : _ref2$modules,\n      _ref2$defines = _ref2.defines,\n      defines = _ref2$defines === undefined ? {} : _ref2$defines;\n  assert(typeof source === 'string', 'shader source must be a string');\n  var sourceLines = source.split('\\n');\n  var versionLine = '';\n  var coreSource = source; // Extract any version directive string from source.\n  // TODO : keep all pre-processor statements at the begining of the shader.\n\n  if (sourceLines[0].indexOf('#version ') === 0) {\n    versionLine = sourceLines[0];\n    coreSource = sourceLines.slice(1).join('\\n');\n  } // Add platform defines (use these to work around platform-specific bugs and limitations)\n  // Add common defines (GLSL version compatibility, feature detection)\n  // Add precision declaration for fragment shaders\n\n\n  var assembledSource = getShaderName({\n    id: id,\n    source: source,\n    type: type\n  }) + '\\n' + getPlatformShaderDefines(gl) + '\\n' + getVersionDefines(gl) + '\\n' + getApplicationDefines(defines) + '\\n' + (type === FRAGMENT_SHADER ? FRAGMENT_SHADER_PROLOGUE : '') + '\\n'; // Add source of dependent modules in resolved order\n\n  var inject = false;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = modules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var moduleName = _step.value;\n\n      switch (moduleName) {\n        case 'inject':\n          inject = true;\n          break;\n\n        default:\n          // Add the module source, and a #define that declares it presence\n          assembledSource += getModuleSource(moduleName, type);\n      }\n    } // Add the version directive and actual source of this shader\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  assembledSource = versionLine + assembledSource + coreSource; // Finally, if requested, insert an automatic module injector chunk\n\n  if (inject) {\n    assembledSource.replace('}\\s*$', MODULE_INJECTORS);\n  }\n\n  return assembledSource;\n} // Returns a combined `getUniforms` covering the options for all the modules,\n// the created function will pass on options to the inidividual `getUniforms`\n// function of each shader module and combine the results into one object that\n// can be passed to setUniforms.\n\n\nfunction assembleGetUniforms(modules) {\n  return function getUniforms(opts) {\n    var uniforms = {};\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = modules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var moduleName = _step2.value;\n        var shaderModule = getShaderModule(moduleName);\n        var moduleUniforms = shaderModule.getUniforms ? shaderModule.getUniforms(opts) : {};\n        Object.assign(uniforms, moduleUniforms);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    return uniforms;\n  };\n} // Returns a map with module names as keys, resolving to their module definitions\n// The presence of a key indicates that the module is available in this program,\n// whether directly included, or through a dependency of some other module\n\n\nfunction assembleModuleMap(modules) {\n  var result = {};\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = modules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var moduleName = _step3.value;\n      var shaderModule = getShaderModule(moduleName);\n      result[moduleName] = shaderModule;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Apply set of modules\n */\n\n\nexport function assembleShaders(gl) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var vs = opts.vs,\n      fs = opts.fs;\n  var modules = resolveModules(opts.modules || []);\n  return {\n    gl: gl,\n    vs: assembleShader(gl, Object.assign({}, opts, {\n      source: vs,\n      type: VERTEX_SHADER,\n      modules: modules\n    })),\n    fs: assembleShader(gl, Object.assign({}, opts, {\n      source: fs,\n      type: FRAGMENT_SHADER,\n      modules: modules\n    })),\n    getUniforms: assembleGetUniforms(modules),\n    modules: assembleModuleMap(modules)\n  };\n}","map":null,"metadata":{},"sourceType":"module"}