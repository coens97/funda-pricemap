{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* eslint quotes: [\"error\", \"single\", { \"allowTemplateLiterals\": true }]*/\n// A scenegraph object node\n\n\nimport { GL, Buffer, Program, withParameters, checkUniformValues, isWebGL } from '../webgl'; // import {withParameters} from '../webgl/context-state';\n\nimport { getUniformsTable } from '../webgl/uniforms';\nimport { getDrawMode } from '../geometry/geometry';\nimport Object3D from '../core/object-3d';\nimport { log, formatValue } from '../utils';\nimport { MONOLITHIC_SHADERS, MODULAR_SHADERS } from '../shadertools/shaders';\nimport { assembleShaders } from '../shadertools';\nimport { addModel, removeModel, logModel, getOverrides } from '../debug/seer-integration';\nimport Query from '../webgl/query';\nimport assert from 'assert';\nvar MSG_INSTANCED_PARAM_DEPRECATED = 'Warning: Model constructor: parameter \"instanced\" renamed to \"isInstanced\".\\nThis will become a hard error in a future version of luma.gl.';\nvar ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount'; // Model abstract O3D Class\n\nvar Model =\n/*#__PURE__*/\nfunction (_Object3D) {\n  _inherits(Model, _Object3D);\n\n  function Model(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Model);\n\n    var _this = _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).call(this, opts));\n\n    if (isWebGL(gl)) {\n      // constructor signature 1: (gl, {...opts})\n      _this.gl = gl;\n    } else {\n      // Warning that we are using v3 style construction\n      log.deprecated('Model({gl, ...opts})', 'Model(gl, {...opts}'); // constructor signature 2: ({gl, ...opts})\n      // Note: A Model subclass may still have supplied opts, just use those as overrides\n\n      opts = Object.assign(gl, opts); // v3 compatibility: Auto extract gl from program if supplied\n\n      _this.gl = opts.gl || opts.program && opts.program.gl; // Verify that we have a valid context\n\n      assert(isWebGL(_this.gl), 'Not a WebGL context');\n    }\n\n    _this.init(opts);\n\n    return _this;\n  }\n  /* eslint-disable max-statements  */\n\n  /* eslint-disable complexity  */\n\n\n  _createClass(Model, [{\n    key: 'init',\n    value: function init() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$vs = _ref.vs,\n          vs = _ref$vs === undefined ? null : _ref$vs,\n          _ref$fs = _ref.fs,\n          fs = _ref$fs === undefined ? null : _ref$fs,\n          _ref$modules = _ref.modules,\n          modules = _ref$modules === undefined ? null : _ref$modules,\n          _ref$defines = _ref.defines,\n          defines = _ref$defines === undefined ? {} : _ref$defines,\n          _ref$moduleSettings = _ref.moduleSettings,\n          moduleSettings = _ref$moduleSettings === undefined ? {} : _ref$moduleSettings,\n          defaultUniforms = _ref.defaultUniforms,\n          _ref$program = _ref.program,\n          program = _ref$program === undefined ? null : _ref$program,\n          _ref$shaderCache = _ref.shaderCache,\n          shaderCache = _ref$shaderCache === undefined ? null : _ref$shaderCache,\n          _ref$isInstanced = _ref.isInstanced,\n          isInstanced = _ref$isInstanced === undefined ? false : _ref$isInstanced,\n          instanced = _ref.instanced,\n          _ref$vertexCount = _ref.vertexCount,\n          vertexCount = _ref$vertexCount === undefined ? undefined : _ref$vertexCount,\n          _ref$instanceCount = _ref.instanceCount,\n          instanceCount = _ref$instanceCount === undefined ? 0 : _ref$instanceCount,\n          drawMode = _ref.drawMode,\n          _ref$uniforms = _ref.uniforms,\n          uniforms = _ref$uniforms === undefined ? {} : _ref$uniforms,\n          _ref$attributes = _ref.attributes,\n          attributes = _ref$attributes === undefined ? {} : _ref$attributes,\n          _ref$geometry = _ref.geometry,\n          geometry = _ref$geometry === undefined ? null : _ref$geometry,\n          _ref$pickable = _ref.pickable,\n          pickable = _ref$pickable === undefined ? true : _ref$pickable,\n          _ref$pick = _ref.pick,\n          pick = _ref$pick === undefined ? null : _ref$pick,\n          _ref$render = _ref.render,\n          render = _ref$render === undefined ? null : _ref$render,\n          _ref$onBeforeRender = _ref.onBeforeRender,\n          onBeforeRender = _ref$onBeforeRender === undefined ? function () {} : _ref$onBeforeRender,\n          _ref$onAfterRender = _ref.onAfterRender,\n          onAfterRender = _ref$onAfterRender === undefined ? function () {} : _ref$onAfterRender,\n          _ref$timerQueryEnable = _ref.timerQueryEnabled,\n          timerQueryEnabled = _ref$timerQueryEnable === undefined ? false : _ref$timerQueryEnable;\n\n      this._initializeProgram({\n        vs: vs,\n        fs: fs,\n        modules: modules,\n        defines: defines,\n        moduleSettings: moduleSettings,\n        defaultUniforms: defaultUniforms,\n        program: program,\n        shaderCache: shaderCache\n      });\n\n      this.uniforms = {}; // Make sure we have some reasonable default uniforms in place\n\n      uniforms = Object.assign({}, this.program.defaultUniforms, uniforms);\n      this.setUniforms(uniforms); // Get all default uniforms\n\n      this.setUniforms(this.getModuleUniforms()); // Get unforms for supplied parameters\n\n      this.setUniforms(this.getModuleUniforms(moduleSettings));\n\n      if (instanced) {\n        /* global console */\n\n        /* eslint-disable no-console */\n        console.warn(MSG_INSTANCED_PARAM_DEPRECATED);\n        isInstanced = isInstanced || instanced;\n      } // TODO - remove?\n\n\n      this.buffers = {};\n      this.userData = {};\n      this.drawParams = {};\n      this.dynamic = false;\n      this.needsRedraw = true; // Attributes and buffers\n\n      this.setGeometry(geometry);\n      this.attributes = {};\n      this.setAttributes(attributes); // geometry might have set drawMode and vertexCount\n\n      if (drawMode !== undefined) {\n        this.drawMode = getDrawMode(drawMode);\n      }\n\n      if (vertexCount !== undefined) {\n        this.vertexCount = vertexCount;\n      }\n\n      this.isInstanced = isInstanced;\n      this.instanceCount = instanceCount; // picking options\n\n      this.pickable = Boolean(pickable);\n\n      this.pick = pick || function () {\n        return false;\n      };\n\n      this.onBeforeRender = onBeforeRender;\n      this.onAfterRender = onAfterRender; // assert(program || program instanceof Program);\n\n      assert(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);\n      this.timerQueryEnabled = timerQueryEnabled && Query.isSupported(this.gl, {\n        timer: true\n      });\n      this.timeElapsedQuery = undefined;\n      this.lastQueryReturned = true;\n      this.stats = {\n        accumulatedFrameTime: 0,\n        averageFrameTime: 0,\n        profileFrameCount: 0\n      };\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: '_initializeProgram',\n    value: function _initializeProgram(_ref2) {\n      var vs = _ref2.vs,\n          fs = _ref2.fs,\n          modules = _ref2.modules,\n          defines = _ref2.defines,\n          moduleSettings = _ref2.moduleSettings,\n          defaultUniforms = _ref2.defaultUniforms,\n          program = _ref2.program,\n          shaderCache = _ref2.shaderCache;\n\n      this.getModuleUniforms = function (x) {};\n\n      if (!program) {\n        // Assign default shaders if none are provided\n        if (!vs) {\n          vs = MODULAR_SHADERS.vs;\n        }\n\n        if (!fs) {\n          fs = MODULAR_SHADERS.fs;\n        } // Assign default uniforms (if any default shaders are being used)\n\n\n        if (vs === MONOLITHIC_SHADERS.vs || fs === MONOLITHIC_SHADERS.fs) {\n          log.warn(0, 'luma.gl: default shaders are deprecated and will be removed in a future version. Use shader modules instead.');\n          defaultUniforms = defaultUniforms || MONOLITHIC_SHADERS.defaultUniforms;\n        }\n\n        var assembleResult = assembleShaders(this.gl, {\n          vs: vs,\n          fs: fs,\n          modules: modules,\n          defines: defines\n        }); // Retrive compiled shaders from cache if exist, otherwise add to the cache.\n\n        vs = assembleResult.vs;\n        fs = assembleResult.fs;\n\n        if (shaderCache) {\n          vs = shaderCache.getVertexShader(this.gl, vs);\n          fs = shaderCache.getFragmentShader(this.gl, fs);\n        }\n\n        var getUniforms = assembleResult.getUniforms;\n\n        this.getModuleUniforms = getUniforms || function (x) {};\n\n        program = new Program(this.gl, {\n          vs: vs,\n          fs: fs\n        });\n      }\n\n      this.program = program;\n      assert(this.program instanceof Program, 'Model needs a program');\n    }\n    /* eslint-enable complexity */\n\n  }, {\n    key: 'destroy',\n    value: function destroy() {\n      this.delete();\n    }\n  }, {\n    key: 'delete',\n    value: function _delete() {\n      this.program.delete();\n      removeModel(this.id);\n    }\n  }, {\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = redraw;\n      return this;\n    }\n  }, {\n    key: 'getNeedsRedraw',\n    value: function getNeedsRedraw() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$clearRedrawFlag = _ref3.clearRedrawFlags,\n          clearRedrawFlags = _ref3$clearRedrawFlag === undefined ? false : _ref3$clearRedrawFlag;\n\n      var redraw = false;\n      redraw = redraw || this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n      redraw = redraw || this.geometry.getNeedsRedraw({\n        clearRedrawFlags: clearRedrawFlags\n      });\n      return redraw;\n    }\n  }, {\n    key: 'setDrawMode',\n    value: function setDrawMode(drawMode) {\n      this.drawMode = getDrawMode(drawMode);\n      return this;\n    }\n  }, {\n    key: 'getDrawMode',\n    value: function getDrawMode() {\n      return this.drawMode;\n    }\n  }, {\n    key: 'setVertexCount',\n    value: function setVertexCount(vertexCount) {\n      assert(Number.isFinite(vertexCount));\n      this.vertexCount = vertexCount;\n      return this;\n    }\n  }, {\n    key: 'getVertexCount',\n    value: function getVertexCount() {\n      return this.vertexCount;\n    }\n  }, {\n    key: 'setInstanceCount',\n    value: function setInstanceCount(instanceCount) {\n      assert(Number.isFinite(instanceCount));\n      this.instanceCount = instanceCount;\n      return this;\n    }\n  }, {\n    key: 'getInstanceCount',\n    value: function getInstanceCount() {\n      return this.instanceCount;\n    }\n  }, {\n    key: 'getProgram',\n    value: function getProgram() {\n      return this.program;\n    } // TODO - just set attributes, don't hold on to geometry\n\n  }, {\n    key: 'setGeometry',\n    value: function setGeometry(geometry) {\n      this.geometry = geometry;\n      this.vertexCount = geometry.getVertexCount();\n      this.drawMode = geometry.drawMode;\n\n      this._createBuffersFromAttributeDescriptors(this.geometry.getAttributes());\n\n      this.setNeedsRedraw();\n      return this;\n    }\n  }, {\n    key: 'getAttributes',\n    value: function getAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: 'setAttributes',\n    value: function setAttributes() {\n      var attributes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.assign(this.attributes, attributes);\n\n      this._createBuffersFromAttributeDescriptors(attributes);\n\n      this.setNeedsRedraw();\n      return this;\n    }\n  }, {\n    key: 'getUniforms',\n    value: function getUniforms() {\n      return this.uniforms;\n    } // TODO - should actually set the uniforms\n\n  }, {\n    key: 'setUniforms',\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      checkUniformValues(uniforms, this.id);\n      Object.assign(this.uniforms, uniforms);\n      this.setNeedsRedraw();\n      return this;\n    } // getModuleUniforms (already on object)\n\n  }, {\n    key: 'updateModuleSettings',\n    value: function updateModuleSettings(opts) {\n      var uniforms = this.getModuleUniforms(opts);\n      return this.setUniforms(uniforms);\n    } // TODO - uniform names are too strongly linked camera <=> default shaders\n    // At least all special handling is collected here.\n\n  }, {\n    key: 'addViewUniforms',\n    value: function addViewUniforms(uniforms) {\n      // TODO - special treatment of these parameters should be removed\n      var camera = uniforms.camera,\n          viewMatrix = uniforms.viewMatrix,\n          modelMatrix = uniforms.modelMatrix; // Camera exposes uniforms that can be used directly in shaders\n\n      var cameraUniforms = camera ? camera.getUniforms() : {};\n      var viewUniforms = viewMatrix ? this.getCoordinateUniforms(viewMatrix, modelMatrix) : {};\n      return Object.assign({}, uniforms, cameraUniforms, viewUniforms);\n    }\n  }, {\n    key: 'draw',\n    value: function draw() {\n      var _this2 = this;\n\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$uniforms = _ref4.uniforms,\n          uniforms = _ref4$uniforms === undefined ? {} : _ref4$uniforms,\n          _ref4$attributes = _ref4.attributes,\n          attributes = _ref4$attributes === undefined ? {} : _ref4$attributes,\n          _ref4$samplers = _ref4.samplers,\n          samplers = _ref4$samplers === undefined ? {} : _ref4$samplers,\n          _ref4$parameters = _ref4.parameters,\n          parameters = _ref4$parameters === undefined ? {} : _ref4$parameters,\n          settings = _ref4.settings,\n          _ref4$framebuffer = _ref4.framebuffer,\n          framebuffer = _ref4$framebuffer === undefined ? null : _ref4$framebuffer;\n\n      if (settings) {\n        log.deprecated('settings', 'parameters');\n        parameters = settings;\n      }\n\n      var gl = this.program.gl;\n\n      if (framebuffer) {\n        parameters = Object.assign(parameters, {\n          framebuffer: framebuffer\n        });\n      }\n\n      return withParameters(gl, parameters, function () {\n        return _this2.render(uniforms, attributes, samplers);\n      });\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var parameters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var samplers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      addModel(this);\n      var resolvedUniforms = this.addViewUniforms(uniforms);\n      getOverrides(this.id, resolvedUniforms);\n      this.setUniforms(resolvedUniforms);\n      log.log(2, '>>> RENDERING MODEL ' + this.id, this);\n      this.setProgramState();\n\n      this._logAttributesAndUniforms(3, resolvedUniforms);\n\n      this.onBeforeRender();\n      var drawParams = this.drawParams;\n\n      if (drawParams.isInstanced && !this.isInstanced) {\n        log.warn(0, 'Found instanced attributes on non-instanced model');\n      }\n\n      var isIndexed = drawParams.isIndexed,\n          indexType = drawParams.indexType;\n      var isInstanced = this.isInstanced,\n          instanceCount = this.instanceCount;\n\n      this._timerQueryStart();\n\n      this.program.draw({\n        drawMode: this.getDrawMode(),\n        vertexCount: this.getVertexCount(),\n        isIndexed: isIndexed,\n        indexType: indexType,\n        isInstanced: isInstanced,\n        instanceCount: instanceCount\n      });\n\n      this._timerQueryEnd();\n\n      this.onAfterRender();\n      this.unsetProgramState();\n      this.setNeedsRedraw(false);\n      log.log(2, '<<< RENDERING MODEL ' + this.id + ' - complete');\n      return this;\n    }\n  }, {\n    key: 'setProgramState',\n    value: function setProgramState() {\n      var program = this.program;\n      program.use();\n      this.drawParams = {};\n      program.setBuffers(this.buffers, {\n        drawParams: this.drawParams\n      });\n      program.setUniforms(this.uniforms, this.samplers);\n      return this;\n    }\n  }, {\n    key: 'unsetProgramState',\n    value: function unsetProgramState() {\n      // Ensures all vertex attributes are disabled and ELEMENT_ARRAY_BUFFER\n      // is unbound\n      this.program.unsetBuffers();\n      return this;\n    }\n  }, {\n    key: '_timerQueryStart',\n    value: function _timerQueryStart() {\n      if (this.timerQueryEnabled === true) {\n        if (!this.timeElapsedQuery) {\n          this.timeElapsedQuery = new Query(this.gl);\n        }\n\n        if (this.lastQueryReturned) {\n          this.lastQueryReturned = false;\n          this.timeElapsedQuery.beginTimeElapsedQuery();\n        }\n      }\n    }\n  }, {\n    key: '_timerQueryEnd',\n    value: function _timerQueryEnd() {\n      if (this.timerQueryEnabled === true) {\n        this.timeElapsedQuery.end(); // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false\n        // should this be incorporated into Query object?\n\n        if (this.timeElapsedQuery.isResultAvailable()) {\n          this.lastQueryReturned = true;\n          var elapsedTime = this.timeElapsedQuery.getResult(); // Update stats (e.g. for seer)\n\n          this.stats.lastFrameTime = elapsedTime;\n          this.stats.accumulatedFrameTime += elapsedTime;\n          this.stats.profileFrameCount++;\n          this.stats.averageFrameTime = this.stats.accumulatedFrameTime / this.stats.profileFrameCount; // Log stats\n\n          log.log(2, 'program.id: ', this.program.id);\n          log.log(2, 'last frame time: ' + this.stats.lastFrameTime + 'ms');\n          log.log(2, 'average frame time ' + this.stats.averageFrameTime + 'ms');\n          log.log(2, 'accumulated frame time: ' + this.stats.accumulatedFrameTime + 'ms');\n          log.log(2, 'profile frame count: ' + this.stats.profileFrameCount);\n        }\n      }\n    } // Makes sure buffers are created for all attributes\n    // and that the program is updated with those buffers\n    // TODO - do we need the separation between \"attributes\" and \"buffers\"\n    // couldn't apps just create buffers directly?\n\n  }, {\n    key: '_createBuffersFromAttributeDescriptors',\n    value: function _createBuffersFromAttributeDescriptors(attributes) {\n      var gl = this.program.gl;\n\n      for (var attributeName in attributes) {\n        var attribute = attributes[attributeName];\n\n        if (attribute instanceof Buffer) {\n          this.buffers[attributeName] = attribute;\n        } else {\n          // Autocreate a buffer\n          this.buffers[attributeName] = this.buffers[attributeName] || new Buffer(gl, {\n            target: attribute.isIndexed ? GL.ELEMENT_ARRAY_BUFFER : GL.ARRAY_BUFFER\n          });\n          var buffer = this.buffers[attributeName];\n          buffer.setData({\n            data: attribute.value\n          }).setDataLayout(attribute);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: '_logAttributesAndUniforms',\n    value: function _logAttributesAndUniforms() {\n      var priority = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;\n      var uniforms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (log.priority >= priority) {\n        var attributeTable = this._getAttributesTable({\n          header: 'Attributes ' + this.id,\n          program: this.program,\n          attributes: Object.assign({}, this.geometry.attributes, this.attributes)\n        });\n\n        log.table(priority, attributeTable);\n\n        var _getUniformsTable = getUniformsTable({\n          header: 'Uniforms ' + this.id,\n          program: this.program,\n          uniforms: Object.assign({}, this.uniforms, uniforms)\n        }),\n            table = _getUniformsTable.table,\n            unusedTable = _getUniformsTable.unusedTable,\n            unusedCount = _getUniformsTable.unusedCount;\n\n        log.table(priority, table);\n        log.log(priority, (unusedCount || 'No') + ' unused uniforms ', unusedTable);\n      }\n\n      logModel(this, uniforms);\n    } // Todo move to attributes manager\n\n  }, {\n    key: '_getAttributesTable',\n    value: function _getAttributesTable() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          attributes = _ref5.attributes,\n          _ref5$header = _ref5.header,\n          header = _ref5$header === undefined ? 'Attributes' : _ref5$header,\n          instanced = _ref5.instanced,\n          program = _ref5.program;\n\n      assert(program);\n      var attributeLocations = program._attributeLocations;\n\n      var table = _defineProperty({}, header, {}); // Add used attributes\n\n\n      for (var attributeName in attributeLocations) {\n        var attribute = attributes[attributeName];\n        var location = attributeLocations[attributeName];\n        table[attributeName] = this._getAttributeEntry(attribute, location);\n      } // Add any unused attributes\n\n\n      for (var _attributeName in attributes) {\n        var _attribute = attributes[_attributeName];\n\n        if (!table[_attributeName]) {\n          table[_attributeName] = this._getAttributeEntry(_attribute, null);\n        }\n      }\n\n      return table;\n    }\n  }, {\n    key: '_getAttributeEntry',\n    value: function _getAttributeEntry(attribute, location) {\n      var round = function round(num) {\n        return Math.round(num * 10) / 10;\n      };\n\n      var type = 'NOT PROVIDED';\n      var instanced = 0;\n      var size = 'N/A';\n      var verts = 'N/A';\n      var bytes = 'N/A';\n      var value = 'N/A';\n\n      if (attribute && location === null) {\n        location = attribute.isIndexed ? 'ELEMENT_ARRAY_BUFFER' : 'NOT USED';\n      }\n\n      if (attribute instanceof Buffer) {\n        var buffer = attribute;\n        type = buffer.layout.type;\n        instanced = buffer.layout.instanced;\n        size = buffer.layout.size;\n        verts = round(buffer.data.length / buffer.layout.size);\n        bytes = buffer.data.length * buffer.data.BYTES_PER_ELEMENT;\n      } else if (attribute) {\n        type = attribute.value.constructor.name;\n        instanced = attribute.instanced;\n        size = attribute.size;\n        verts = round(attribute.value.length / attribute.size);\n        bytes = attribute.value.length * attribute.value.BYTES_PER_ELEMENT;\n        value = attribute.value;\n      } // Generate a type name by dropping Array from Float32Array etc.\n\n\n      type = String(type).replace('Array', ''); // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array\n\n      var isInteger = type.indexOf('nt') !== -1;\n      return {\n        Location: '' + location + (instanced ? ' [instanced]' : ''),\n        'Type Size x Verts = Bytes': type + ' ' + size + ' x ' + verts + ' = ' + bytes,\n        Value: formatValue(value, {\n          size: size,\n          isInteger: isInteger\n        })\n      };\n    } // DEPRECATED / REMOVED\n\n  }, {\n    key: 'isPickable',\n    value: function isPickable() {\n      return this.pickable;\n    }\n  }, {\n    key: 'setPickable',\n    value: function setPickable() {\n      var pickable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.pickable = Boolean(pickable);\n      return this;\n    }\n  }, {\n    key: 'getGeometry',\n    value: function getGeometry() {\n      return this.geometry;\n    }\n  }]);\n\n  return Model;\n}(Object3D);\n\nexport default Model;","map":null,"metadata":{},"sourceType":"module"}