{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup'];\nvar EVENT_TYPE = 'pointermove';\n/**\n * Hammer.js swallows 'move' events (for pointer/touch/mouse)\n * when the pointer is not down. This class sets up a handler\n * specifically for these events to work around this limitation.\n * Note that this could be extended to more intelligently handle\n * move events across input types, e.g. storing multiple simultaneous\n * pointer/touch events, calculating speed/direction, etc.\n */\n\nvar MoveInput = function () {\n  function MoveInput(element, callback) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck3.default)(this, MoveInput);\n    this.element = element;\n    this.callback = callback;\n    this.pressed = false;\n    var events = MOUSE_EVENTS.concat(options.events || []);\n    this.options = (0, _assign2.default)({\n      enable: true\n    }, options, {\n      events: events\n    });\n    this.handleEvent = this.handleEvent.bind(this);\n    this.options.events.forEach(function (event) {\n      return element.addEventListener(event, _this.handleEvent);\n    });\n  }\n\n  (0, _createClass3.default)(MoveInput, [{\n    key: 'destroy',\n    value: function destroy() {\n      var _this2 = this;\n\n      this.options.events.forEach(function (event) {\n        return _this2.element.removeEventListener(event, _this2.handleEvent);\n      });\n    }\n  }, {\n    key: 'set',\n    value: function set(options) {\n      (0, _assign2.default)(this.options, options);\n    }\n    /**\n     * Enable this input (begin processing events)\n     * if the specified event type is among those handled by this input.\n     */\n\n  }, {\n    key: 'toggleIfEventSupported',\n    value: function toggleIfEventSupported(eventType, enabled) {\n      if (EVENT_TYPE === eventType) {\n        this.options.enable = enabled;\n      }\n    }\n  }, {\n    key: 'handleEvent',\n    value: function handleEvent(event) {\n      if (!this.options.enable) {\n        return;\n      }\n\n      switch (event.type) {\n        case 'mousedown':\n          if (event.button === 0) {\n            // Left button is down\n            this.pressed = true;\n          }\n\n          break;\n\n        case 'mousemove':\n          // Move events use `which` to track the button being pressed\n          if (event.which !== 1) {\n            // Left button is not down\n            this.pressed = false;\n          }\n\n          if (!this.pressed) {\n            // Drag events are emitted by hammer already\n            // we just need to emit the move event on hover\n            this.callback({\n              type: EVENT_TYPE,\n              srcEvent: event,\n              pointerType: 'mouse',\n              target: event.target\n            });\n          }\n\n          break;\n\n        case 'mouseup':\n          this.pressed = false;\n          break;\n\n        default:\n      }\n    }\n  }]);\n  return MoveInput;\n}();\n\nexports.default = MoveInput;","map":null,"metadata":{},"sourceType":"script"}