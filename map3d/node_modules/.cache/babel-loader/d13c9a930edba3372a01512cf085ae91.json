{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport log from '../utils/log';\nimport assert from '../utils/assert';\nvar EMPTY_PROPS = Object.freeze({});\n\nvar ComponentState =\n/*#__PURE__*/\nfunction () {\n  function ComponentState() {\n    var component = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, ComponentState);\n\n    this.component = component;\n    this.asyncProps = {}; // Prop values that the layer sees\n\n    this.onAsyncPropUpdated = function () {};\n\n    this.oldProps = EMPTY_PROPS; // Last props before update\n\n    this.oldAsyncProps = null; // Last props before update, with async values copied.\n  }\n\n  _createClass(ComponentState, [{\n    key: \"getOldProps\",\n    value: function getOldProps() {\n      return this.oldAsyncProps || this.oldProps;\n    }\n  }, {\n    key: \"resetOldProps\",\n    value: function resetOldProps() {\n      this.oldAsyncProps = null;\n      this.oldProps = this.component.props;\n    } // Whenever async props are changing, we need to make a copy of oldProps\n    // otherwise the prop rewriting will affect the value both in props and oldProps.\n    // While the copy is relatively expensive, this only happens on load completion.\n\n  }, {\n    key: \"freezeAsyncOldProps\",\n    value: function freezeAsyncOldProps() {\n      if (!this.oldAsyncProps) {\n        // Make sure oldProps is set\n        this.oldProps = this.oldProps || this.component.props; // Deep copy props (Object.assign only handles shallow props)\n        // TODO - Alternatively, just reconfigure the async prop descriptors to fixed values?\n\n        this.oldAsyncProps = {};\n\n        for (var propName in this.oldProps) {\n          this.oldAsyncProps[propName] = this.oldProps[propName];\n        }\n      }\n    } // ASYNC PROP HANDLING\n    //\n    // Checks if a prop is overridden\n\n  }, {\n    key: \"hasAsyncProp\",\n    value: function hasAsyncProp(propName) {\n      return propName in this.asyncProps;\n    } // Returns value of an overriden prop\n\n  }, {\n    key: \"getAsyncProp\",\n    value: function getAsyncProp(propName) {\n      var asyncProp = this.asyncProps[propName];\n      return asyncProp && asyncProp.resolvedValue;\n    }\n  }, {\n    key: \"isAsyncPropLoading\",\n    value: function isAsyncPropLoading(propName) {\n      var asyncProp = this.asyncProps[propName];\n      return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);\n    } // Updates all async/overridden props (when new props come in)\n    // Checks if urls have changed, starts loading, or removes override\n\n  }, {\n    key: \"setAsyncProps\",\n    value: function setAsyncProps(props) {\n      // NOTE: prop param and default values are only support for testing\n      var resolvedValues = props._asyncPropResolvedValues || {};\n      var originalValues = props._asyncPropOriginalValues || props;\n      var defaultValues = props._asyncPropDefaultValues || {}; // TODO - use async props from the layer's prop types\n\n      for (var propName in resolvedValues) {\n        var value = resolvedValues[propName];\n\n        this._createAsyncPropData(propName, value, defaultValues[propName]);\n\n        this._updateAsyncProp(propName, value);\n      }\n\n      for (var _propName in originalValues) {\n        var _value = originalValues[_propName]; // Makes sure a record exists for this prop\n\n        this._createAsyncPropData(_propName, _value, defaultValues[_propName]);\n\n        this._updateAsyncProp(_propName, _value);\n      }\n    } // Intercept strings (URLs) and Promises and activates loading and prop rewriting\n\n  }, {\n    key: \"_updateAsyncProp\",\n    value: function _updateAsyncProp(propName, value) {\n      if (!this._didAsyncInputValueChange(propName, value)) {\n        return;\n      } // interpret value string as url and start a new load tracked by a promise\n\n\n      if (typeof value === 'string') {\n        var fetch = this.layer.props.fetch;\n        var url = value;\n        value = fetch(url);\n      } // interprets promise and track the \"loading\"\n\n\n      if (value instanceof Promise) {\n        this._watchPromise(propName, value);\n\n        return;\n      } // else, normal, non-async value. Just store value for now\n\n\n      this._setPropValue(propName, value);\n    } // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)\n\n  }, {\n    key: \"_didAsyncInputValueChange\",\n    value: function _didAsyncInputValueChange(propName, value) {\n      var asyncProp = this.asyncProps[propName];\n\n      if (value === asyncProp.lastValue) {\n        return false;\n      }\n\n      asyncProp.lastValue = value;\n      return true;\n    } // Set normal, non-async value\n\n  }, {\n    key: \"_setPropValue\",\n    value: function _setPropValue(propName, value) {\n      var asyncProp = this.asyncProps[propName];\n      asyncProp.value = value;\n      asyncProp.resolvedValue = value;\n      asyncProp.pendingLoadCount++;\n      asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;\n    } // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously\n\n  }, {\n    key: \"_setAsyncPropValue\",\n    value: function _setAsyncPropValue(propName, value, loadCount) {\n      // Only update if loadCount is larger or equal to resolvedLoadCount\n      // otherwise a more recent load has already completed\n      var asyncProp = this.asyncProps[propName];\n\n      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount) {\n        assert(value !== undefined); // A chance to copy old props before updating\n\n        this.freezeAsyncOldProps();\n        value = this._postProcessValue(propName, value);\n        asyncProp.resolvedValue = value;\n        asyncProp.resolvedLoadCount = loadCount; // Call callback to inform listener\n\n        this.onAsyncPropUpdated(propName, value);\n      }\n    } // Tracks a promise, sets the prop when loaded, handles load count\n\n  }, {\n    key: \"_watchPromise\",\n    value: function _watchPromise(propName, promise) {\n      var _this = this;\n\n      var asyncProp = this.asyncProps[propName];\n      asyncProp.pendingLoadCount++;\n      var loadCount = asyncProp.pendingLoadCount;\n      promise.then(function (data) {\n        return _this._setAsyncPropValue(propName, data, loadCount);\n      }).catch(function (error) {\n        return log.error(error);\n      });\n    } // Give the app a chance to post process the loaded data\n\n  }, {\n    key: \"_postProcessValue\",\n    value: function _postProcessValue(propName, value) {\n      var _ref = this.component ? this.component.props : {},\n          dataTransform = _ref.dataTransform;\n\n      if (propName === 'data' && dataTransform) {\n        value = dataTransform(value);\n      }\n\n      return value;\n    } // Creating an asyncProp record if needed\n\n  }, {\n    key: \"_createAsyncPropData\",\n    value: function _createAsyncPropData(propName, value, defaultValue) {\n      var asyncProp = this.asyncProps[propName];\n\n      if (!asyncProp) {\n        // assert(defaultValue !== undefined);\n        this.asyncProps[propName] = {\n          lastValue: null,\n          // Supplied prop value (can be url/promise, not visible to layer)\n          resolvedValue: defaultValue,\n          // Resolved prop value (valid data, can be \"shown\" to layer)\n          pendingLoadCount: 0,\n          // How many loads have been issued\n          resolvedLoadCount: 0 // Latest resolved load, (earlier loads will be ignored)\n\n        };\n      }\n    }\n  }]);\n\n  return ComponentState;\n}();\n\nexport { ComponentState as default };","map":null,"metadata":{},"sourceType":"module"}