{"ast":null,"code":"// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\nimport { GL, withParameters, setParameters } from 'luma.gl';\nimport log from '../utils/log';\nimport assert from 'assert';\nvar LOG_PRIORITY_DRAW = 2;\nvar renderCount = 0; // TODO - Exported for pick-layers.js - Move to util?\n\nexport var getPixelRatio = function getPixelRatio(_ref) {\n  var useDevicePixels = _ref.useDevicePixels;\n  assert(typeof useDevicePixels === 'boolean', 'Invalid useDevicePixels');\n  return useDevicePixels && typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n}; // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n\nvar getGLViewport = function getGLViewport(gl, _ref2) {\n  var viewport = _ref2.viewport,\n      pixelRatio = _ref2.pixelRatio; // TODO - dummy default for node\n\n  var height = gl.canvas ? gl.canvas.clientHeight : 100; // Convert viewport top-left CSS coordinates to bottom up WebGL coordinates\n\n  var dimensions = viewport;\n  return [dimensions.x * pixelRatio, (height - dimensions.y - dimensions.height) * pixelRatio, dimensions.width * pixelRatio, dimensions.height * pixelRatio];\n}; // Helper functions\n\n\nfunction clearCanvas(gl, _ref3) {\n  var useDevicePixels = _ref3.useDevicePixels; // const pixelRatio = getPixelRatio({useDevicePixels});\n\n  var width = gl.drawingBufferWidth;\n  var height = gl.drawingBufferHeight; // clear depth and color buffers, restoring transparency\n\n  withParameters(gl, {\n    viewport: [0, 0, width, height]\n  }, function () {\n    gl.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);\n  });\n} // Draw a list of layers in a list of viewports\n\n\nexport function drawLayers(gl, _ref4) {\n  var layers = _ref4.layers,\n      viewports = _ref4.viewports,\n      onViewportActive = _ref4.onViewportActive,\n      useDevicePixels = _ref4.useDevicePixels,\n      _ref4$drawPickingColo = _ref4.drawPickingColors,\n      drawPickingColors = _ref4$drawPickingColo === undefined ? false : _ref4$drawPickingColo,\n      _ref4$deviceRect = _ref4.deviceRect,\n      deviceRect = _ref4$deviceRect === undefined ? null : _ref4$deviceRect,\n      _ref4$parameters = _ref4.parameters,\n      parameters = _ref4$parameters === undefined ? {} : _ref4$parameters,\n      _ref4$layerFilter = _ref4.layerFilter,\n      layerFilter = _ref4$layerFilter === undefined ? null : _ref4$layerFilter,\n      _ref4$pass = _ref4.pass,\n      pass = _ref4$pass === undefined ? 'draw' : _ref4$pass,\n      _ref4$redrawReason = _ref4.redrawReason,\n      redrawReason = _ref4$redrawReason === undefined ? '' : _ref4$redrawReason;\n  clearCanvas(gl, {\n    useDevicePixels: useDevicePixels\n  }); // effectManager.preDraw();\n\n  viewports.forEach(function (viewportOrDescriptor, i) {\n    var viewport = getViewportFromDescriptor(viewportOrDescriptor); // Update context to point to this viewport\n\n    onViewportActive(viewport); // render this viewport\n\n    drawLayersInViewport(gl, {\n      layers: layers,\n      viewport: viewport,\n      useDevicePixels: useDevicePixels,\n      drawPickingColors: drawPickingColors,\n      deviceRect: deviceRect,\n      parameters: parameters,\n      layerFilter: layerFilter,\n      pass: pass,\n      redrawReason: redrawReason\n    });\n  }); // effectManager.draw();\n} // Draws list of layers and viewports into the picking buffer\n// Note: does not sample the buffer, that has to be done by the caller\n\nexport function drawPickingBuffer(gl, _ref5) {\n  var layers = _ref5.layers,\n      viewports = _ref5.viewports,\n      onViewportActive = _ref5.onViewportActive,\n      useDevicePixels = _ref5.useDevicePixels,\n      pickingFBO = _ref5.pickingFBO,\n      _ref5$deviceRect = _ref5.deviceRect,\n      x = _ref5$deviceRect.x,\n      y = _ref5$deviceRect.y,\n      width = _ref5$deviceRect.width,\n      height = _ref5$deviceRect.height,\n      _ref5$layerFilter = _ref5.layerFilter,\n      layerFilter = _ref5$layerFilter === undefined ? null : _ref5$layerFilter,\n      _ref5$redrawReason = _ref5.redrawReason,\n      redrawReason = _ref5$redrawReason === undefined ? '' : _ref5$redrawReason; // Make sure we clear scissor test and fbo bindings in case of exceptions\n  // We are only interested in one pixel, no need to render anything else\n  // Note that the callback here is called synchronously.\n  // Set blend mode for picking\n  // always overwrite existing pixel with [r,g,b,layerIndex]\n\n  return withParameters(gl, {\n    framebuffer: pickingFBO,\n    scissorTest: true,\n    scissor: [x, y, width, height],\n    clearColor: [0, 0, 0, 0]\n  }, function () {\n    drawLayers(gl, {\n      layers: layers,\n      viewports: viewports,\n      onViewportActive: onViewportActive,\n      useDevicePixels: useDevicePixels,\n      drawPickingColors: true,\n      layerFilter: layerFilter,\n      pass: 'picking',\n      redrawReason: redrawReason,\n      parameters: {\n        blend: true,\n        blendFunc: [gl.ONE, gl.ZERO, gl.CONSTANT_ALPHA, gl.ZERO],\n        blendEquation: gl.FUNC_ADD,\n        blendColor: [0, 0, 0, 0]\n      }\n    });\n  });\n} // Draws a list of layers in one viewport\n// TODO - when picking we could completely skip rendering viewports that dont\n// intersect with the picking rect\n\nfunction drawLayersInViewport(gl, _ref6) {\n  var layers = _ref6.layers,\n      viewport = _ref6.viewport,\n      useDevicePixels = _ref6.useDevicePixels,\n      _ref6$drawPickingColo = _ref6.drawPickingColors,\n      drawPickingColors = _ref6$drawPickingColo === undefined ? false : _ref6$drawPickingColo,\n      _ref6$deviceRect = _ref6.deviceRect,\n      deviceRect = _ref6$deviceRect === undefined ? null : _ref6$deviceRect,\n      _ref6$parameters = _ref6.parameters,\n      parameters = _ref6$parameters === undefined ? {} : _ref6$parameters,\n      layerFilter = _ref6.layerFilter,\n      _ref6$pass = _ref6.pass,\n      pass = _ref6$pass === undefined ? 'draw' : _ref6$pass,\n      _ref6$redrawReason = _ref6.redrawReason,\n      redrawReason = _ref6$redrawReason === undefined ? '' : _ref6$redrawReason;\n  var pixelRatio = getPixelRatio({\n    useDevicePixels: useDevicePixels\n  });\n  var glViewport = getGLViewport(gl, {\n    viewport: viewport,\n    pixelRatio: pixelRatio\n  }); // render layers in normal colors\n\n  var renderStats = {\n    totalCount: layers.length,\n    visibleCount: 0,\n    compositeCount: 0,\n    pickableCount: 0\n  }; // const {x, y, width, height} = deviceRect || [];\n\n  setParameters(gl, parameters || {}); // render layers in normal colors\n\n  layers.forEach(function (layer, layerIndex) {\n    // Check if we should draw layer\n    var shouldDrawLayer = layer.props.visible;\n\n    if (drawPickingColors) {\n      shouldDrawLayer = shouldDrawLayer && layer.props.pickable;\n    }\n\n    if (shouldDrawLayer && layerFilter) {\n      shouldDrawLayer = layerFilter({\n        layer: layer,\n        viewport: viewport,\n        isPicking: drawPickingColors\n      });\n    } // Calculate stats\n\n\n    if (shouldDrawLayer && layer.props.pickable) {\n      renderStats.pickableCount++;\n    }\n\n    if (layer.isComposite) {\n      renderStats.compositeCount++;\n    } // Draw the layer\n\n\n    if (shouldDrawLayer) {\n      if (!layer.isComposite) {\n        renderStats.visibleCount++;\n      }\n\n      drawLayerInViewport({\n        gl: gl,\n        layer: layer,\n        layerIndex: layerIndex,\n        drawPickingColors: drawPickingColors,\n        glViewport: glViewport,\n        parameters: parameters\n      });\n    }\n  });\n  renderCount++;\n  logRenderStats({\n    renderStats: renderStats,\n    pass: pass,\n    redrawReason: redrawReason\n  });\n}\n\nfunction drawLayerInViewport(_ref7) {\n  var gl = _ref7.gl,\n      layer = _ref7.layer,\n      layerIndex = _ref7.layerIndex,\n      drawPickingColors = _ref7.drawPickingColors,\n      glViewport = _ref7.glViewport,\n      parameters = _ref7.parameters;\n  var moduleParameters = Object.assign({}, layer.props, {\n    viewport: layer.context.viewport,\n    pickingActive: drawPickingColors ? 1 : 0\n  });\n  var uniforms = Object.assign({}, layer.context.uniforms, {\n    layerIndex: layerIndex\n  }); // All parameter resolving is done here instead of the layer\n  // Blend parameters must not be overriden\n\n  var layerParameters = Object.assign({}, layer.props.parameters || {}, parameters);\n  Object.assign(layerParameters, {\n    viewport: glViewport\n  });\n\n  if (drawPickingColors) {\n    Object.assign(layerParameters, {\n      blendColor: [0, 0, 0, (layerIndex + 1) / 255]\n    });\n  } else {\n    Object.assign(moduleParameters, getObjectHighlightParameters(layer));\n  }\n\n  layer.drawLayer({\n    moduleParameters: moduleParameters,\n    uniforms: uniforms,\n    parameters: layerParameters\n  });\n}\n\nfunction logRenderStats(_ref8) {\n  var renderStats = _ref8.renderStats,\n      pass = _ref8.pass,\n      redrawReason = _ref8.redrawReason;\n\n  if (log.priority >= LOG_PRIORITY_DRAW) {\n    var totalCount = renderStats.totalCount,\n        visibleCount = renderStats.visibleCount,\n        compositeCount = renderStats.compositeCount,\n        pickableCount = renderStats.pickableCount;\n    var primitiveCount = totalCount - compositeCount;\n    var hiddenCount = primitiveCount - visibleCount;\n    var message = '';\n    message += 'RENDER #' + renderCount + ' ' + visibleCount + ' (of ' + totalCount + ' layers) to ' + pass + ' because ' + redrawReason + ' ';\n\n    if (log.priority > LOG_PRIORITY_DRAW) {\n      message += '(' + hiddenCount + ' hidden, ' + compositeCount + ' composite ' + pickableCount + ' unpickable)';\n    }\n\n    log.log(LOG_PRIORITY_DRAW, message);\n  }\n} // Get a viewport from a viewport descriptor (which can be a plain viewport)\n\n\nfunction getViewportFromDescriptor(viewportOrDescriptor) {\n  return viewportOrDescriptor.viewport ? viewportOrDescriptor.viewport : viewportOrDescriptor;\n}\n/**\n * Returns the picking color of currenlty selected object of the given 'layer'.\n * @return {Array} - the picking color or null if layers selected object is invalid.\n */\n\n\nfunction getObjectHighlightParameters(layer) {\n  // TODO - inefficient to update settings every render?\n  // TODO: Add warning if 'highlightedObjectIndex' is > numberOfInstances of the model.\n  // Update picking module settings if highlightedObjectIndex is set.\n  // This will overwrite any settings from auto highlighting.\n  if (Number.isInteger(layer.props.highlightedObjectIndex)) {\n    var pickingSelectedColor = layer.props.highlightedObjectIndex >= 0 ? layer.encodePickingColor(layer.props.highlightedObjectIndex) : null;\n    return {\n      pickingSelectedColor: pickingSelectedColor\n    };\n  }\n\n  return null;\n}","map":null,"metadata":{},"sourceType":"module"}