{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport MathArray from './lib/math-array';\nimport { checkNumber, clamp } from './lib/common';\nimport Matrix4 from './matrix4';\nimport Quaternion from './quaternion';\nimport Vector3 from './vector3';\nvar ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';\nvar ALMOST_ONE = 0.99999;\n\nfunction validateOrder(value) {\n  return value >= 0 && value < 6;\n}\n\nfunction checkOrder(value) {\n  if (value < 0 && value >= 6) {\n    throw new Error(ERR_UNKNOWN_ORDER);\n  }\n\n  return value;\n}\n\nvar Euler = function (_MathArray) {\n  _inherits(Euler, _MathArray);\n\n  _createClass(Euler, [{\n    key: \"ELEMENTS\",\n    get: function get() {\n      return 4;\n    }\n  }], [{\n    key: \"rotationOrder\",\n    value: function rotationOrder(order) {\n      return Euler.RotationOrders[order];\n    }\n  }, {\n    key: \"ZYX\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"YXZ\",\n    get: function get() {\n      return 1;\n    }\n  }, {\n    key: \"XZY\",\n    get: function get() {\n      return 2;\n    }\n  }, {\n    key: \"ZXY\",\n    get: function get() {\n      return 3;\n    }\n  }, {\n    key: \"YZX\",\n    get: function get() {\n      return 4;\n    }\n  }, {\n    key: \"XYZ\",\n    get: function get() {\n      return 5;\n    }\n  }, {\n    key: \"RollPitchYaw\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"DefaultOrder\",\n    get: function get() {\n      return Euler.ZYX;\n    }\n  }, {\n    key: \"RotationOrders\",\n    get: function get() {\n      return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];\n    }\n  }]);\n\n  function Euler() {\n    var _this;\n\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;\n\n    _classCallCheck(this, Euler);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Euler).call(this));\n\n    if (arguments.length > 0 && Array.isArray(arguments[0])) {\n      var _this2;\n\n      (_this2 = _this).fromVector3.apply(_this2, arguments);\n    } else {\n      _this.set(x, y, z, order);\n    }\n\n    return _this;\n  }\n\n  _createClass(Euler, [{\n    key: \"copy\",\n    value: function copy(array) {\n      for (var i = 0; i < 3; ++i) {\n        this[i] = array[i];\n      }\n\n      this[3] = Number.isFinite(array[3]) || this.order;\n      return this.check();\n    }\n  }, {\n    key: \"set\",\n    value: function set() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var order = arguments.length > 3 ? arguments[3] : undefined;\n      this[0] = x;\n      this[1] = y;\n      this[2] = z;\n      this[3] = Number.isFinite(order) ? order : this[3];\n      return this.check();\n    }\n  }, {\n    key: \"validate\",\n    value: function validate() {\n      return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this[0];\n      array[offset + 1] = this[1];\n      array[offset + 2] = this[2];\n      return array;\n    }\n  }, {\n    key: \"toArray4\",\n    value: function toArray4() {\n      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      array[offset] = this[0];\n      array[offset + 1] = this[1];\n      array[offset + 2] = this[2];\n      array[offset + 3] = this[3];\n      return array;\n    }\n  }, {\n    key: \"toVector3\",\n    value: function toVector3(optionalResult) {\n      if (optionalResult) {\n        return optionalResult.set(this[0], this[1], this[2]);\n      }\n\n      return new Vector3(this[0], this[1], this[2]);\n    }\n  }, {\n    key: \"fromVector3\",\n    value: function fromVector3(v, order) {\n      return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      this[0] = array[0 + offset];\n      this[1] = array[1 + offset];\n      this[2] = array[2 + offset];\n\n      if (array[3] !== undefined) {\n        this[3] = array[3];\n      }\n\n      return this.check();\n    }\n  }, {\n    key: \"fromRollPitchYaw\",\n    value: function fromRollPitchYaw(roll, pitch, yaw) {\n      return this.set(roll, pitch, yaw, Euler.ZYX);\n    }\n  }, {\n    key: \"fromQuaternion\",\n    value: function fromQuaternion(q, order) {\n      this._fromRotationMatrix(Matrix4.fromQuaternion(q), order);\n\n      return this.check();\n    }\n  }, {\n    key: \"fromRotationMatrix\",\n    value: function fromRotationMatrix(m) {\n      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;\n\n      this._fromRotationMatrix(m, order);\n\n      return this.check();\n    }\n  }, {\n    key: \"getRotationMatrix\",\n    value: function getRotationMatrix() {\n      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Matrix4();\n\n      this._getRotationMatrix(m);\n\n      return m;\n    }\n  }, {\n    key: \"getQuaternion\",\n    value: function getQuaternion() {\n      var q = new Quaternion();\n\n      switch (this[4]) {\n        case Euler.XYZ:\n          return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);\n\n        case Euler.YXZ:\n          return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);\n\n        case Euler.ZXY:\n          return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);\n\n        case Euler.ZYX:\n          return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);\n\n        case Euler.YZX:\n          return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);\n\n        case Euler.XZY:\n          return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);\n\n        default:\n          throw new Error(ERR_UNKNOWN_ORDER);\n      }\n    }\n  }, {\n    key: \"_fromRotationMatrix\",\n    value: function _fromRotationMatrix(m) {\n      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;\n      var te = m.elements;\n      var m11 = te[0],\n          m12 = te[4],\n          m13 = te[8];\n      var m21 = te[1],\n          m22 = te[5],\n          m23 = te[9];\n      var m31 = te[2],\n          m32 = te[6],\n          m33 = te[10];\n      order = order || this[3];\n\n      switch (order) {\n        case Euler.XYZ:\n          this[1] = Math.asin(clamp(m13, -1, 1));\n\n          if (Math.abs(m13) < ALMOST_ONE) {\n            this[0] = Math.atan2(-m23, m33);\n            this[2] = Math.atan2(-m12, m11);\n          } else {\n            this[0] = Math.atan2(m32, m22);\n            this[2] = 0;\n          }\n\n          break;\n\n        case Euler.YXZ:\n          this[0] = Math.asin(-clamp(m23, -1, 1));\n\n          if (Math.abs(m23) < ALMOST_ONE) {\n            this[1] = Math.atan2(m13, m33);\n            this[2] = Math.atan2(m21, m22);\n          } else {\n            this[1] = Math.atan2(-m31, m11);\n            this[2] = 0;\n          }\n\n          break;\n\n        case Euler.ZXY:\n          this[0] = Math.asin(clamp(m32, -1, 1));\n\n          if (Math.abs(m32) < ALMOST_ONE) {\n            this[1] = Math.atan2(-m31, m33);\n            this[2] = Math.atan2(-m12, m22);\n          } else {\n            this[1] = 0;\n            this[2] = Math.atan2(m21, m11);\n          }\n\n          break;\n\n        case Euler.ZYX:\n          this[1] = Math.asin(-clamp(m31, -1, 1));\n\n          if (Math.abs(m31) < ALMOST_ONE) {\n            this[0] = Math.atan2(m32, m33);\n            this[2] = Math.atan2(m21, m11);\n          } else {\n            this[0] = 0;\n            this[2] = Math.atan2(-m12, m22);\n          }\n\n          break;\n\n        case Euler.YZX:\n          this[2] = Math.asin(clamp(m21, -1, 1));\n\n          if (Math.abs(m21) < ALMOST_ONE) {\n            this[0] = Math.atan2(-m23, m22);\n            this[1] = Math.atan2(-m31, m11);\n          } else {\n            this[0] = 0;\n            this[1] = Math.atan2(m13, m33);\n          }\n\n          break;\n\n        case Euler.XZY:\n          this[2] = Math.asin(-clamp(m12, -1, 1));\n\n          if (Math.abs(m12) < ALMOST_ONE) {\n            this[0] = Math.atan2(m32, m22);\n            this[1] = Math.atan2(m13, m11);\n          } else {\n            this[0] = Math.atan2(-m23, m33);\n            this[1] = 0;\n          }\n\n          break;\n\n        default:\n          throw new Error(ERR_UNKNOWN_ORDER);\n      }\n\n      this[3] = order;\n      return this;\n    }\n  }, {\n    key: \"_getRotationMatrix\",\n    value: function _getRotationMatrix() {\n      var te = new Matrix4();\n      var x = this.x,\n          y = this.y,\n          z = this.z;\n      var a = Math.cos(x);\n      var c = Math.cos(y);\n      var e = Math.cos(z);\n      var b = Math.sin(x);\n      var d = Math.sin(y);\n      var f = Math.sin(z);\n\n      switch (this[3]) {\n        case Euler.XYZ:\n          {\n            var ae = a * e,\n                af = a * f,\n                be = b * e,\n                bf = b * f;\n            te[0] = c * e;\n            te[4] = -c * f;\n            te[8] = d;\n            te[1] = af + be * d;\n            te[5] = ae - bf * d;\n            te[9] = -b * c;\n            te[2] = bf - ae * d;\n            te[6] = be + af * d;\n            te[10] = a * c;\n            break;\n          }\n\n        case Euler.YXZ:\n          {\n            var ce = c * e,\n                cf = c * f,\n                de = d * e,\n                df = d * f;\n            te[0] = ce + df * b;\n            te[4] = de * b - cf;\n            te[8] = a * d;\n            te[1] = a * f;\n            te[5] = a * e;\n            te[9] = -b;\n            te[2] = cf * b - de;\n            te[6] = df + ce * b;\n            te[10] = a * c;\n            break;\n          }\n\n        case Euler.ZXY:\n          {\n            var _ce = c * e,\n                _cf = c * f,\n                _de = d * e,\n                _df = d * f;\n\n            te[0] = _ce - _df * b;\n            te[4] = -a * f;\n            te[8] = _de + _cf * b;\n            te[1] = _cf + _de * b;\n            te[5] = a * e;\n            te[9] = _df - _ce * b;\n            te[2] = -a * d;\n            te[6] = b;\n            te[10] = a * c;\n            break;\n          }\n\n        case Euler.ZYX:\n          {\n            var _ae = a * e,\n                _af = a * f,\n                _be = b * e,\n                _bf = b * f;\n\n            te[0] = c * e;\n            te[4] = _be * d - _af;\n            te[8] = _ae * d + _bf;\n            te[1] = c * f;\n            te[5] = _bf * d + _ae;\n            te[9] = _af * d - _be;\n            te[2] = -d;\n            te[6] = b * c;\n            te[10] = a * c;\n            break;\n          }\n\n        case Euler.YZX:\n          {\n            var ac = a * c,\n                ad = a * d,\n                bc = b * c,\n                bd = b * d;\n            te[0] = c * e;\n            te[4] = bd - ac * f;\n            te[8] = bc * f + ad;\n            te[1] = f;\n            te[5] = a * e;\n            te[9] = -b * e;\n            te[2] = -d * e;\n            te[6] = ad * f + bc;\n            te[10] = ac - bd * f;\n            break;\n          }\n\n        case Euler.XZY:\n          {\n            var _ac = a * c,\n                _ad = a * d,\n                _bc = b * c,\n                _bd = b * d;\n\n            te[0] = c * e;\n            te[4] = -f;\n            te[8] = d * e;\n            te[1] = _ac * f + _bd;\n            te[5] = a * e;\n            te[9] = _ad * f - _bc;\n            te[2] = _bc * f - _ad;\n            te[6] = b * e;\n            te[10] = _bd * f + _ac;\n            break;\n          }\n\n        default:\n          throw new Error(ERR_UNKNOWN_ORDER);\n      }\n\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n  }, {\n    key: \"x\",\n    get: function get() {\n      return this[0];\n    },\n    set: function set(value) {\n      return this[0] = checkNumber(value);\n    }\n  }, {\n    key: \"y\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(value) {\n      return this[1] = checkNumber(value);\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(value) {\n      return this[2] = checkNumber(value);\n    }\n  }, {\n    key: \"alpha\",\n    get: function get() {\n      return this[0];\n    },\n    set: function set(value) {\n      return this[0] = checkNumber(value);\n    }\n  }, {\n    key: \"beta\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(value) {\n      return this[1] = checkNumber(value);\n    }\n  }, {\n    key: \"gamma\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(value) {\n      return this[2] = checkNumber(value);\n    }\n  }, {\n    key: \"phi\",\n    get: function get() {\n      return this[0];\n    },\n    set: function set(value) {\n      return this[0] = checkNumber(value);\n    }\n  }, {\n    key: \"theta\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(value) {\n      return this[1] = checkNumber(value);\n    }\n  }, {\n    key: \"psi\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(value) {\n      return this[2] = checkNumber(value);\n    }\n  }, {\n    key: \"roll\",\n    get: function get() {\n      return this[0];\n    },\n    set: function set(value) {\n      return this[0] = checkNumber(value);\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      return this[1];\n    },\n    set: function set(value) {\n      return this[1] = checkNumber(value);\n    }\n  }, {\n    key: \"yaw\",\n    get: function get() {\n      return this[2];\n    },\n    set: function set(value) {\n      return this[2] = checkNumber(value);\n    }\n  }, {\n    key: \"order\",\n    get: function get() {\n      return this[3];\n    },\n    set: function set(value) {\n      return this[3] = checkOrder(value);\n    }\n  }]);\n\n  return Euler;\n}(MathArray);\n\nexport { Euler as default };","map":null,"metadata":{},"sourceType":"module"}