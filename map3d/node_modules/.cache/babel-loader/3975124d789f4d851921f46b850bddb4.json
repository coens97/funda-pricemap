{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _assign = require('babel-runtime/core-js/object/assign');\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _mapState = require('../utils/map-state');\n\nvar _mapState2 = _interopRequireDefault(_mapState);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // EVENT HANDLING PARAMETERS\n\n\nvar PITCH_MOUSE_THRESHOLD = 5; // Copyright (c) 2015 Uber Technologies, Inc.\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nvar PITCH_ACCEL = 1.2;\nvar ZOOM_ACCEL = 0.01;\nvar EVENT_TYPES = {\n  WHEEL: ['wheel'],\n  PAN: ['panstart', 'panmove', 'panend'],\n  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],\n  DOUBLE_TAP: ['doubletap']\n};\n\nvar MapControls = function () {\n  /**\n   * @classdesc\n   * A class that handles events and updates mercator style viewport parameters\n   */\n  function MapControls() {\n    (0, _classCallCheck3.default)(this, MapControls);\n    this._state = {\n      isDragging: false\n    };\n    this.handleEvent = this.handleEvent.bind(this);\n  }\n  /**\n   * Callback for events\n   * @param {hammer.Event} event\n   */\n\n\n  (0, _createClass3.default)(MapControls, [{\n    key: 'handleEvent',\n    value: function handleEvent(event) {\n      this.mapState = new _mapState2.default((0, _assign2.default)({}, this.mapStateProps, this._state));\n\n      switch (event.type) {\n        case 'panstart':\n          return this._onPanStart(event);\n\n        case 'panmove':\n          return this._onPan(event);\n\n        case 'panend':\n          return this._onPanEnd(event);\n\n        case 'pinchstart':\n          return this._onPinchStart(event);\n\n        case 'pinchmove':\n          return this._onPinch(event);\n\n        case 'pinchend':\n          return this._onPinchEnd(event);\n\n        case 'doubletap':\n          return this._onDoubleTap(event);\n\n        case 'wheel':\n          return this._onWheel(event);\n\n        default:\n          return false;\n      }\n    }\n    /* Event utils */\n    // Event object: http://hammerjs.github.io/api/#event-object\n\n  }, {\n    key: 'getCenter',\n    value: function getCenter(event) {\n      var _event$offsetCenter = event.offsetCenter,\n          x = _event$offsetCenter.x,\n          y = _event$offsetCenter.y;\n      return [x, y];\n    }\n  }, {\n    key: 'isFunctionKeyPressed',\n    value: function isFunctionKeyPressed(event) {\n      var srcEvent = event.srcEvent;\n      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n    }\n  }, {\n    key: 'setState',\n    value: function setState(newState) {\n      (0, _assign2.default)(this._state, newState);\n\n      if (this.onStateChange) {\n        this.onStateChange(this._state);\n      }\n    }\n    /* Callback util */\n    // formats map state and invokes callback function\n\n  }, {\n    key: 'updateViewport',\n    value: function updateViewport(newMapState) {\n      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var oldViewport = this.mapState.getViewportProps();\n      var newViewport = newMapState.getViewportProps();\n\n      if (this.onViewportChange && (0, _keys2.default)(newViewport).some(function (key) {\n        return oldViewport[key] !== newViewport[key];\n      })) {\n        // Viewport has changed\n        this.onViewportChange(newViewport);\n      }\n\n      this.setState((0, _assign2.default)({}, newMapState.getInteractiveState(), extraState));\n    }\n    /**\n     * Extract interactivity options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      var onChangeViewport = options.onChangeViewport,\n          onViewportChange = options.onViewportChange,\n          _options$onStateChang = options.onStateChange,\n          onStateChange = _options$onStateChang === undefined ? this.onStateChange : _options$onStateChang,\n          _options$eventManager = options.eventManager,\n          eventManager = _options$eventManager === undefined ? this.eventManager : _options$eventManager,\n          _options$scrollZoom = options.scrollZoom,\n          scrollZoom = _options$scrollZoom === undefined ? true : _options$scrollZoom,\n          _options$dragPan = options.dragPan,\n          dragPan = _options$dragPan === undefined ? true : _options$dragPan,\n          _options$dragRotate = options.dragRotate,\n          dragRotate = _options$dragRotate === undefined ? true : _options$dragRotate,\n          _options$doubleClickZ = options.doubleClickZoom,\n          doubleClickZoom = _options$doubleClickZ === undefined ? true : _options$doubleClickZ,\n          _options$touchZoomRot = options.touchZoomRotate,\n          touchZoomRotate = _options$touchZoomRot === undefined ? true : _options$touchZoomRot; // TODO(deprecate): remove this check when `onChangeViewport` gets deprecated\n\n      this.onViewportChange = onViewportChange || onChangeViewport;\n      this.onStateChange = onStateChange;\n      this.mapStateProps = options;\n\n      if (this.eventManager !== eventManager) {\n        // EventManager has changed\n        this.eventManager = eventManager;\n        this._events = {};\n      }\n\n      var isInteractive = Boolean(this.onViewportChange); // Register/unregister events\n\n      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);\n      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));\n      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && touchZoomRotate);\n      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom); // Interaction toggles\n\n      this.scrollZoom = scrollZoom;\n      this.dragPan = dragPan;\n      this.dragRotate = dragRotate;\n      this.doubleClickZoom = doubleClickZoom;\n      this.touchZoomRotate = touchZoomRotate;\n    }\n  }, {\n    key: 'toggleEvents',\n    value: function toggleEvents(eventNames, enabled) {\n      var _this = this;\n\n      if (this.eventManager) {\n        eventNames.forEach(function (eventName) {\n          if (_this._events[eventName] !== enabled) {\n            _this._events[eventName] = enabled;\n\n            if (enabled) {\n              _this.eventManager.on(eventName, _this.handleEvent);\n            } else {\n              _this.eventManager.off(eventName, _this.handleEvent);\n            }\n          }\n        });\n      }\n    }\n    /* Event handlers */\n    // Default handler for the `panstart` event.\n\n  }, {\n    key: '_onPanStart',\n    value: function _onPanStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.panStart({\n        pos: pos\n      }).rotateStart({\n        pos: pos\n      });\n      return this.updateViewport(newMapState, {\n        isDragging: true\n      });\n    } // Default handler for the `panmove` event.\n\n  }, {\n    key: '_onPan',\n    value: function _onPan(event) {\n      return this.isFunctionKeyPressed(event) ? this._onPanRotate(event) : this._onPanMove(event);\n    } // Default handler for the `panend` event.\n\n  }, {\n    key: '_onPanEnd',\n    value: function _onPanEnd(event) {\n      var newMapState = this.mapState.panEnd().rotateEnd();\n      return this.updateViewport(newMapState, {\n        isDragging: false\n      });\n    } // Default handler for panning to move.\n    // Called by `_onPan` when panning without function key pressed.\n\n  }, {\n    key: '_onPanMove',\n    value: function _onPanMove(event) {\n      if (!this.dragPan) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.pan({\n        pos: pos\n      });\n      return this.updateViewport(newMapState);\n    } // Default handler for panning to rotate.\n    // Called by `_onPan` when panning with function key pressed.\n\n  }, {\n    key: '_onPanRotate',\n    value: function _onPanRotate(event) {\n      if (!this.dragRotate) {\n        return false;\n      }\n\n      var deltaX = event.deltaX,\n          deltaY = event.deltaY;\n\n      var _getCenter = this.getCenter(event),\n          _getCenter2 = (0, _slicedToArray3.default)(_getCenter, 2),\n          centerY = _getCenter2[1];\n\n      var startY = centerY - deltaY;\n\n      var _mapState$getViewport = this.mapState.getViewportProps(),\n          width = _mapState$getViewport.width,\n          height = _mapState$getViewport.height;\n\n      var deltaScaleX = deltaX / width;\n      var deltaScaleY = 0;\n\n      if (deltaY > 0) {\n        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n          // Move from 0 to -1 as we drag upwards\n          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;\n        }\n      } else if (deltaY < 0) {\n        if (startY > PITCH_MOUSE_THRESHOLD) {\n          // Move from 0 to 1 as we drag upwards\n          deltaScaleY = 1 - centerY / startY;\n        }\n      }\n\n      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));\n      var newMapState = this.mapState.rotate({\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY\n      });\n      return this.updateViewport(newMapState);\n    } // Default handler for the `wheel` event.\n\n  }, {\n    key: '_onWheel',\n    value: function _onWheel(event) {\n      if (!this.scrollZoom) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var delta = event.delta; // Map wheel delta to relative scale\n\n      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));\n\n      if (delta < 0 && scale !== 0) {\n        scale = 1 / scale;\n      }\n\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      return this.updateViewport(newMapState);\n    } // Default handler for the `pinchstart` event.\n\n  }, {\n    key: '_onPinchStart',\n    value: function _onPinchStart(event) {\n      var pos = this.getCenter(event);\n      var newMapState = this.mapState.zoomStart({\n        pos: pos\n      });\n      return this.updateViewport(newMapState, {\n        isDragging: true\n      });\n    } // Default handler for the `pinch` event.\n\n  }, {\n    key: '_onPinch',\n    value: function _onPinch(event) {\n      if (!this.touchZoomRotate) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var scale = event.scale;\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      return this.updateViewport(newMapState);\n    } // Default handler for the `pinchend` event.\n\n  }, {\n    key: '_onPinchEnd',\n    value: function _onPinchEnd(event) {\n      var newMapState = this.mapState.zoomEnd();\n      return this.updateViewport(newMapState, {\n        isDragging: false\n      });\n    } // Default handler for the `doubletap` event.\n\n  }, {\n    key: '_onDoubleTap',\n    value: function _onDoubleTap(event) {\n      if (!this.doubleClickZoom) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var isZoomOut = this.isFunctionKeyPressed(event);\n      var newMapState = this.mapState.zoom({\n        pos: pos,\n        scale: isZoomOut ? 0.5 : 2\n      });\n      return this.updateViewport(newMapState);\n    }\n  }]);\n  return MapControls;\n}();\n\nexports.default = MapControls;","map":null,"metadata":{},"sourceType":"script"}