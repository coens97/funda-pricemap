{"ast":null,"code":"import { Vector3 } from 'math.gl';\nimport commonShader from './lighting-common.glsl';\nimport vertexShader1 from './lighting-vertex.glsl';\nimport fragmentShader1 from './lighting-fragment.glsl';\nexport var vertexShader = \"\".concat(commonShader, \"\\n\").concat(vertexShader1, \"\\n\");\nexport var fragmentShader = \"\".concat(commonShader, \"\\n\").concat(fragmentShader1, \"\\n\");\nexport var name = 'lighting';\nexport var config = {\n  MAX_POINT_LIGHTS: 4\n}; // Setup the lighting system: ambient, directional, point lights.\n\nexport function getUniforms(_ref) {\n  var _ref$lightingEnable = _ref.lightingEnable,\n      lightingEnable = _ref$lightingEnable === void 0 ? false : _ref$lightingEnable,\n      _ref$lightingAmbientC = _ref.lightingAmbientColor,\n      lightingAmbientColor = _ref$lightingAmbientC === void 0 ? [0.2, 0.2, 0.2] : _ref$lightingAmbientC,\n      _ref$lightingDirectio = _ref.lightingDirection,\n      lightingDirection = _ref$lightingDirectio === void 0 ? [1, 1, 1] : _ref$lightingDirectio,\n      _ref$lightingDirectio2 = _ref.lightingDirectionalColor,\n      lightingDirectionalColor = _ref$lightingDirectio2 === void 0 ? [0, 0, 0] : _ref$lightingDirectio2,\n      _ref$lightingPointLig = _ref.lightingPointLights,\n      lightingPointLights = _ref$lightingPointLig === void 0 ? [] : _ref$lightingPointLig; // Set light uniforms. Ambient, directional and point lights.\n\n  return Object.assign({\n    lightingEnable: lightingEnable,\n    // Ambient\n    lightingAmbientColor: lightingAmbientColor\n  }, getDirectionalUniforms(lightingDirection), getPointUniforms(lightingPointLights));\n}\n\nfunction getDirectionalUniforms(_ref2) {\n  var color = _ref2.color,\n      direction = _ref2.direction; // Normalize lighting direction vector\n\n  var dir = new Vector3(direction.x, direction.y, direction.z).normalize().scale(-1, -1, -1);\n  return {\n    directionalColor: [color.r, color.g, color.b],\n    lightingDirection: [dir.x, dir.y, dir.z]\n  };\n}\n\nfunction getPointUniforms(points) {\n  points = points instanceof Array ? points : [points];\n  var numberPoints = points.length;\n  var pointLocations = [];\n  var pointColors = [];\n  var enableSpecular = [];\n  var pointSpecularColors = [];\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var point = _step.value;\n      var position = point.position,\n          color = point.color,\n          diffuse = point.diffuse,\n          specular = point.specular;\n      var pointColor = color || diffuse;\n      pointLocations.push(position.x, position.y, position.z);\n      pointColors.push(pointColor.r, pointColor.g, pointColor.b); // Add specular color\n\n      enableSpecular.push(Number(Boolean(specular)));\n\n      if (specular) {\n        pointSpecularColors.push(specular.r, specular.g, specular.b);\n      } else {\n        pointSpecularColors.push(0, 0, 0);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return {\n    numberPoints: numberPoints,\n    pointLocation: pointLocations,\n    pointColor: pointColors,\n    enableSpecular: enableSpecular,\n    pointSpecularColor: pointSpecularColors\n  };\n}\n\nexport default {\n  name: name,\n  vs: vertexShader,\n  fs: fragmentShader,\n  getUniforms: getUniforms\n};","map":null,"metadata":{},"sourceType":"module"}