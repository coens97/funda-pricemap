{"ast":null,"code":"// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\nimport mat4_multiply from 'gl-mat4/multiply';\nimport vec4_transformMat4 from 'gl-vec4/transformMat4';\nimport log from '../../utils/log';\nimport assert from 'assert';\nimport { COORDINATE_SYSTEM } from '../../lib/constants';\nimport { projectFlat } from 'viewport-mercator-project'; // To quickly set a vector to zero\n\nvar ZERO_VECTOR = [0, 0, 0, 0]; // 4x4 matrix that drops 4th component of vector\n\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0]; // TODO - import these utils from fp64 package\n\nfunction fp64ify(a) {\n  var array = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var hiPart = Math.fround(a);\n  var loPart = a - hiPart;\n  array[startIndex] = hiPart;\n  array[startIndex + 1] = loPart;\n  return array;\n} // calculate WebGL 64 bit matrix (transposed \"Float64Array\")\n\n\nfunction fp64ifyMatrix4(matrix) {\n  // Transpose the projection matrix to column major for GLSL.\n  var matrixFP64 = new Float32Array(32);\n\n  for (var i = 0; i < 4; ++i) {\n    for (var j = 0; j < 4; ++j) {\n      var index = i * 4 + j;\n      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);\n    }\n  }\n\n  return matrixFP64;\n} // The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\n// Uncomment when debugging\n\n\nfunction calculateMatrixAndOffset(_ref) {\n  var viewport = _ref.viewport,\n      modelMatrix = _ref.modelMatrix,\n      coordinateSystem = _ref.coordinateSystem,\n      coordinateOrigin = _ref.coordinateOrigin,\n      coordinateZoom = _ref.coordinateZoom;\n  var viewMatrixUncentered = viewport.viewMatrixUncentered;\n  var viewMatrix = viewport.viewMatrix;\n  var projectionMatrix = viewport.projectionMatrix;\n  var viewProjectionMatrix = viewport.viewProjectionMatrix;\n  var projectionCenter = void 0;\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.IDENTITY:\n    case COORDINATE_SYSTEM.LNGLAT:\n      projectionCenter = ZERO_VECTOR;\n      break;\n    // TODO: make lighting work for meter offset mode\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n      // Calculate transformed projectionCenter (using 64 bit precision JS)\n      // This is the key to offset mode precision\n      // (avoids doing this addition in 32 bit precision in GLSL)\n      var positionPixels = projectFlat(coordinateOrigin, Math.pow(2, coordinateZoom)); // projectionCenter = new Matrix4(viewProjectionMatrix)\n      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n\n      projectionCenter = vec4_transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix); // Always apply uncentered projection matrix if available (shader adds center)\n\n      viewMatrix = viewMatrixUncentered || viewMatrix; // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n\n      viewProjectionMatrix = mat4_multiply([], projectionMatrix, viewMatrix);\n      viewProjectionMatrix = mat4_multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n      break;\n\n    default:\n      throw new Error('Unknown projection mode');\n  }\n\n  return {\n    viewMatrix: viewMatrix,\n    viewProjectionMatrix: viewProjectionMatrix,\n    projectionCenter: projectionCenter,\n    cameraPos: viewport.cameraPosition\n  };\n}\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\n\n\nexport function getUniformsFromViewport() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      viewport = _ref2.viewport,\n      _ref2$modelMatrix = _ref2.modelMatrix,\n      modelMatrix = _ref2$modelMatrix === undefined ? null : _ref2$modelMatrix,\n      _ref2$coordinateSyste = _ref2.coordinateSystem,\n      coordinateSystem = _ref2$coordinateSyste === undefined ? COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,\n      _ref2$coordinateOrigi = _ref2.coordinateOrigin,\n      coordinateOrigin = _ref2$coordinateOrigi === undefined ? [0, 0] : _ref2$coordinateOrigi,\n      _ref2$fp = _ref2.fp64,\n      fp64 = _ref2$fp === undefined ? false : _ref2$fp,\n      projectionMode = _ref2.projectionMode,\n      positionOrigin = _ref2.positionOrigin;\n\n  assert(viewport);\n\n  if (projectionMode !== undefined) {\n    log.removed('projectionMode', 'coordinateSystem');\n  }\n\n  if (positionOrigin !== undefined) {\n    log.removed('positionOrigin', 'coordinateOrigin');\n  }\n\n  var coordinateZoom = viewport.zoom;\n  assert(coordinateZoom >= 0);\n\n  var _calculateMatrixAndOf = calculateMatrixAndOffset({\n    coordinateSystem: coordinateSystem,\n    coordinateOrigin: coordinateOrigin,\n    coordinateZoom: coordinateZoom,\n    modelMatrix: modelMatrix,\n    viewport: viewport\n  }),\n      projectionCenter = _calculateMatrixAndOf.projectionCenter,\n      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,\n      cameraPos = _calculateMatrixAndOf.cameraPos;\n\n  assert(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix'); // Calculate projection pixels per unit\n\n  var distanceScales = viewport.getDistanceScales(); // TODO - does this depend on useDevicePixels?\n\n  var devicePixelRatio = window && window.devicePixelRatio || 1;\n  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n  var glModelMatrix = modelMatrix || IDENTITY_MATRIX;\n  var uniforms = {\n    // Projection mode values\n    project_uCoordinateSystem: coordinateSystem,\n    project_uCenter: projectionCenter,\n    // Screen size\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n    // Distance at which screen pixels are projected\n    project_uFocalDistance: viewport.focalDistance || 1,\n    project_uPixelsPerMeter: distanceScales.pixelsPerMeter,\n    project_uPixelsPerDegree: distanceScales.pixelsPerDegree,\n    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,\n    project_uPixelsPerUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale,\n    // This is the mercator scale (2 ** zoom)\n    project_uModelMatrix: glModelMatrix,\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n    // This is for lighting calculations\n    project_uCameraPosition: cameraPos\n  };\n\n  if (coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {\n    var distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);\n    uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerMeter;\n    uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;\n  }\n\n  if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS) {\n    var _distanceScalesAtOrigin = viewport.getDistanceScales(coordinateOrigin);\n\n    uniforms.project_uPixelsPerUnit = _distanceScalesAtOrigin.pixelsPerDegree;\n    uniforms.project_uPixelsPerUnit2 = _distanceScalesAtOrigin.pixelsPerDegree2;\n  } // TODO - fp64 flag should be from shader module, not layer props\n\n\n  return fp64 ? addFP64Uniforms(uniforms) : uniforms;\n} // 64 bit projection support\n\nfunction addFP64Uniforms(uniforms) {\n  var glViewProjectionMatrixFP64 = fp64ifyMatrix4(uniforms.project_uViewProjectionMatrix);\n  var scaleFP64 = fp64ify(uniforms.project_uScale);\n  uniforms.project_uViewProjectionMatrixFP64 = glViewProjectionMatrixFP64;\n  uniforms.project64_uViewProjectionMatrix = glViewProjectionMatrixFP64;\n  uniforms.project64_uScale = scaleFP64;\n  return uniforms;\n}","map":null,"metadata":{},"sourceType":"module"}