{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nimport log from '../utils/log';\nimport assert from 'assert'; // Returns an object with \"change flags\", either false or strings indicating reason for change\n\nexport function diffProps(props, oldProps) {\n  // First check if any props have changed (ignore props that will be examined separately)\n  var propsChangedReason = compareProps({\n    newProps: props,\n    oldProps: oldProps,\n    ignoreProps: {\n      data: null,\n      updateTriggers: null\n    }\n  }); // Now check if any data related props have changed\n\n  var dataChangedReason = diffDataProps(props, oldProps); // Check update triggers to determine if any attributes need regeneration\n  // Note - if data has changed, all attributes will need regeneration, so skip this step\n\n  var updateTriggersChangedReason = false;\n\n  if (!dataChangedReason) {\n    updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);\n  }\n\n  return {\n    dataChanged: dataChangedReason,\n    propsChanged: propsChangedReason,\n    updateTriggersChanged: updateTriggersChangedReason\n  };\n}\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * @param {Object} opt.oldProps - object with old key/value pairs\n * @param {Object} opt.newProps - object with new key/value pairs\n * @param {Object} opt.ignoreProps={} - object, keys that should not be compared\n * @returns {null|String} - null when values of all keys are strictly equal.\n *   if unequal, returns a string explaining what changed.\n */\n\n/* eslint-disable max-statements, max-depth, complexity */\n\nexport function compareProps() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      newProps = _ref.newProps,\n      oldProps = _ref.oldProps,\n      _ref$ignoreProps = _ref.ignoreProps,\n      ignoreProps = _ref$ignoreProps === undefined ? {} : _ref$ignoreProps,\n      _ref$shallowComparePr = _ref.shallowCompareProps,\n      shallowCompareProps = _ref$shallowComparePr === undefined ? {} : _ref$shallowComparePr,\n      _ref$triggerName = _ref.triggerName,\n      triggerName = _ref$triggerName === undefined ? 'props' : _ref$triggerName;\n\n  assert(oldProps !== undefined && newProps !== undefined, 'compareProps args'); // shallow equality => deep equality\n\n  if (oldProps === newProps) {\n    return null;\n  } // TODO - do we need these checks? Should never happen...\n\n\n  if ((typeof newProps === 'undefined' ? 'undefined' : _typeof(newProps)) !== 'object' || newProps === null) {\n    return triggerName + ' changed shallowly';\n  }\n\n  if ((typeof oldProps === 'undefined' ? 'undefined' : _typeof(oldProps)) !== 'object' || oldProps === null) {\n    return triggerName + ' changed shallowly';\n  } // Test if new props different from old props\n\n\n  for (var key in oldProps) {\n    if (!(key in ignoreProps)) {\n      if (!newProps.hasOwnProperty(key)) {\n        return triggerName + '.' + key + ' dropped: ' + oldProps[key] + ' -> undefined';\n      } // If object has an equals function, invoke it\n\n\n      var equals = newProps[key] && oldProps[key] && newProps[key].equals;\n\n      if (equals && !equals.call(newProps[key], oldProps[key])) {\n        return triggerName + '.' + key + ' changed deeply: ' + oldProps[key] + ' -> ' + newProps[key];\n      } // If both new and old value are functions, ignore differences\n\n\n      if (key in shallowCompareProps) {\n        var type = _typeof(newProps[key]);\n\n        if (type === 'function' && typeof oldProps[key] === 'function') {\n          equals = true;\n        }\n      }\n\n      if (!equals && oldProps[key] !== newProps[key]) {\n        return triggerName + '.' + key + ' changed shallowly: ' + oldProps[key] + ' -> ' + newProps[key];\n      }\n    }\n  } // Test if any new props have been added\n\n\n  for (var _key in newProps) {\n    if (!(_key in ignoreProps)) {\n      if (!oldProps.hasOwnProperty(_key)) {\n        return triggerName + '.' + _key + ' added: undefined -> ' + newProps[_key];\n      }\n    }\n  }\n\n  return null;\n}\n/* eslint-enable max-statements, max-depth, complexity */\n// HELPERS\n// The comparison of the data prop requires special handling\n// the dataComparator should be used if supplied\n\nfunction diffDataProps(props, oldProps) {\n  if (oldProps === null) {\n    return 'oldProps is null, initial diff';\n  } // Support optional app defined comparison of data\n\n\n  var dataComparator = props.dataComparator;\n\n  if (dataComparator) {\n    if (!dataComparator(props.data, oldProps.data)) {\n      return 'Data comparator detected a change';\n    } // Otherwise, do a shallow equal on props\n\n  } else if (props.data !== oldProps.data) {\n    return 'A new data container was supplied';\n  }\n\n  return null;\n} // Checks if any update triggers have changed\n// also calls callback to invalidate attributes accordingly.\n\n\nfunction diffUpdateTriggers(props, oldProps) {\n  if (oldProps === null) {\n    return 'oldProps is null, initial diff';\n  } // If the 'all' updateTrigger fires, ignore testing others\n\n\n  if ('all' in props.updateTriggers) {\n    var diffReason = diffUpdateTrigger(oldProps, props, 'all');\n\n    if (diffReason) {\n      return {\n        all: true\n      };\n    }\n  }\n\n  var triggerChanged = {};\n  var reason = false; // If the 'all' updateTrigger didn't fire, need to check all others\n\n  for (var triggerName in props.updateTriggers) {\n    if (triggerName !== 'all') {\n      var _diffReason = diffUpdateTrigger(oldProps, props, triggerName);\n\n      if (_diffReason) {\n        triggerChanged[triggerName] = true;\n        reason = triggerChanged;\n      }\n    }\n  }\n\n  return reason;\n}\n\nfunction diffUpdateTrigger(props, oldProps, triggerName) {\n  var newTriggers = props.updateTriggers[triggerName] || {};\n  var oldTriggers = oldProps.updateTriggers[triggerName] || {};\n  var diffReason = compareProps({\n    oldProps: oldTriggers,\n    newProps: newTriggers,\n    triggerName: triggerName\n  });\n  return diffReason;\n} // Constructors have their super class constructors as prototypes\n\n\nfunction getOwnProperty(object, prop) {\n  return Object.prototype.hasOwnProperty.call(object, prop) && object[prop];\n}\n/*\n * Return merged default props stored on layers constructor, create them if needed\n */\n\n\nexport function getDefaultProps(layer) {\n  // TODO - getOwnProperty is very slow, reduces layer construction speed 3x\n  var mergedDefaultProps = getOwnProperty(layer.constructor, 'mergedDefaultProps');\n\n  if (mergedDefaultProps) {\n    return mergedDefaultProps;\n  }\n\n  return mergeDefaultProps(layer);\n}\n/*\n * Walk a prototype chain and merge all default props from any 'defaultProps' objects\n */\n\nexport function mergeDefaultProps(object) {\n  var objectNameKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'layerName';\n  var subClassConstructor = object.constructor;\n  var objectName = getOwnProperty(subClassConstructor, objectNameKey);\n\n  if (!objectName) {\n    log.once(0, object.constructor.name + ' does not specify a ' + objectNameKey);\n  } // Use the object's constructor name as default id prop.\n  // Note that constructor names are substituted during minification and may not be \"human readable\"\n\n\n  var mergedDefaultProps = {\n    id: objectName || object.constructor.name\n  }; // Reverse shadowing\n  // TODO - Rewrite to stop when mergedDefaultProps is available on parent?\n\n  while (object) {\n    var objectDefaultProps = getOwnProperty(object.constructor, 'defaultProps');\n    Object.freeze(objectDefaultProps);\n\n    if (objectDefaultProps) {\n      mergedDefaultProps = Object.assign({}, objectDefaultProps, mergedDefaultProps);\n    }\n\n    object = Object.getPrototypeOf(object);\n  }\n\n  Object.freeze(mergedDefaultProps); // Store for quick lookup\n\n  subClassConstructor.mergedDefaultProps = mergedDefaultProps;\n  assert(mergeDefaultProps);\n  return mergedDefaultProps;\n}","map":null,"metadata":{},"sourceType":"module"}