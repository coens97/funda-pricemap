{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable react/no-direct-mutation-state */\n\n/* global fetch */\n\n/* global window */\n\n\nimport { COORDINATE_SYSTEM } from './constants';\nimport AttributeManager from './attribute-manager';\nimport { removeLayerInSeer } from './seer-integration';\nimport { diffProps as _diffProps } from '../lifecycle/props';\nimport { count } from '../utils/count';\nimport log from '../utils/log';\nimport GL from 'luma.gl/constants';\nimport { withParameters } from 'luma.gl';\nimport assert from '../utils/assert';\nimport { projectPosition as _projectPosition, getWorldPosition } from '../shaderlib/project/project-functions';\nimport Component from '../lifecycle/component';\nimport LayerState from './layer-state';\nimport { worldToPixels } from 'viewport-mercator-project';\nvar LOG_PRIORITY_UPDATE = 1;\nvar EMPTY_ARRAY = Object.freeze([]);\n\nvar noop = function noop() {};\n\nvar defaultProps = {\n  // data: Special handling for null, see below\n  data: {\n    type: 'data',\n    value: EMPTY_ARRAY,\n    async: true\n  },\n  dataComparator: null,\n  dataTransform: function dataTransform(data) {\n    return data;\n  },\n  fetch: function (_fetch) {\n    function fetch(_x) {\n      return _fetch.apply(this, arguments);\n    }\n\n    fetch.toString = function () {\n      return _fetch.toString();\n    };\n\n    return fetch;\n  }(function (url) {\n    return fetch(url).then(function (response) {\n      return response.json();\n    });\n  }),\n  updateTriggers: {},\n  // Update triggers: a core change detection mechanism in deck.gl\n  numInstances: undefined,\n  visible: true,\n  pickable: false,\n  opacity: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 0.8\n  },\n  onHover: noop,\n  onClick: noop,\n  coordinateSystem: COORDINATE_SYSTEM.LNGLAT,\n  coordinateOrigin: [0, 0, 0],\n  wrapLongitude: false,\n  parameters: {},\n  uniforms: {},\n  framebuffer: null,\n  animation: null,\n  // Passed prop animation functions to evaluate props\n  // Offset depth based on layer index to avoid z-fighting.\n  // Negative values pull layer towards the camera\n  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm\n  getPolygonOffset: function getPolygonOffset(_ref) {\n    var layerIndex = _ref.layerIndex;\n    return [0, -layerIndex * 100];\n  },\n  // Selection/Highlighting\n  highlightedObjectIndex: null,\n  autoHighlight: false,\n  highlightColor: [0, 0, 128, 128]\n};\n\nvar Layer =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(Layer, _Component);\n\n  function Layer() {\n    _classCallCheck(this, Layer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Layer).apply(this, arguments));\n  }\n\n  _createClass(Layer, [{\n    key: \"toString\",\n    value: function toString() {\n      var className = this.constructor.layerName || this.constructor.name;\n      return \"\".concat(className, \"({id: '\").concat(this.props.id, \"'})\");\n    } // Public API\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: \"setState\",\n    value: function setState(updateObject) {\n      this.setChangeFlags({\n        stateChanged: true\n      });\n      Object.assign(this.state, updateObject);\n      this.setNeedsRedraw();\n    } // Sets the redraw flag for this layer, will trigger a redraw next animation frame\n\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.internalState) {\n        this.internalState.needsRedraw = redraw;\n      }\n    } // This layer needs a deep update\n    // TODO - Need to align with existing needsUpdate before uncommenting\n    // For now async props will call layerManager directly\n\n  }, {\n    key: \"setLayerNeedsUpdate\",\n    value: function setLayerNeedsUpdate() {\n      this.context.layerManager.setNeedsUpdate(String(this));\n    } // Checks state of attributes and model\n\n  }, {\n    key: \"getNeedsRedraw\",\n    value: function getNeedsRedraw() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,\n          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? false : _ref2$clearRedrawFlag;\n\n      return this._getNeedsRedraw(clearRedrawFlags);\n    } // Checks if layer attributes needs updating\n\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      // Call subclass lifecycle method\n      return this.shouldUpdateState(this._getUpdateParams()); // End lifecycle method\n    } // Returns true if the layer is pickable and visible.\n\n  }, {\n    key: \"isPickable\",\n    value: function isPickable() {\n      return this.props.pickable && this.props.visible;\n    } // Return an array of models used by this layer, can be overriden by layer subclass\n\n  }, {\n    key: \"getModels\",\n    value: function getModels() {\n      return this.state && (this.state.models || (this.state.model ? [this.state.model] : []));\n    } // TODO - Gradually phase out, does not support multi model layers\n\n  }, {\n    key: \"getSingleModel\",\n    value: function getSingleModel() {\n      return this.state && this.state.model;\n    }\n  }, {\n    key: \"getAttributeManager\",\n    value: function getAttributeManager() {\n      return this.internalState && this.internalState.attributeManager;\n    } // Returns the most recent layer that matched to this state\n    // (When reacting to an async event, this layer may no longer be the latest)\n\n  }, {\n    key: \"getCurrentLayer\",\n    value: function getCurrentLayer() {\n      return this.internalState && this.internalState.layer;\n    } // Use iteration (the only required capability on data) to get first element\n    // deprecated since we are effectively only supporting Arrays\n\n  }, {\n    key: \"getFirstObject\",\n    value: function getFirstObject() {\n      var data = this.props.data;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          return object;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    } // PROJECTION METHODS\n    // Projects a point with current map state (lat, lon, zoom, pitch, bearing)\n    // From the current layer's coordinate system to screen\n\n  }, {\n    key: \"project\",\n    value: function project(xyz) {\n      var viewport = this.context.viewport;\n      var worldPosition = getWorldPosition(xyz, {\n        viewport: viewport,\n        modelMatrix: this.props.modelMatrix,\n        coordinateOrigin: this.props.coordinateOrigin,\n        coordinateSystem: this.props.coordinateSystem\n      });\n\n      var _worldToPixels = worldToPixels(worldPosition, viewport.pixelProjectionMatrix),\n          _worldToPixels2 = _slicedToArray(_worldToPixels, 3),\n          x = _worldToPixels2[0],\n          y = _worldToPixels2[1],\n          z = _worldToPixels2[2];\n\n      return xyz.length === 2 ? [x, y] : [x, y, z];\n    } // Note: this does not reverse `project`.\n    // Always unprojects to the viewport's coordinate system\n\n  }, {\n    key: \"unproject\",\n    value: function unproject(xy) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(xy));\n      return viewport.unproject(xy);\n    }\n  }, {\n    key: \"projectPosition\",\n    value: function projectPosition(xyz) {\n      assert(Array.isArray(xyz));\n      return _projectPosition(xyz, {\n        viewport: this.context.viewport,\n        modelMatrix: this.props.modelMatrix,\n        coordinateOrigin: this.props.coordinateOrigin,\n        coordinateSystem: this.props.coordinateSystem\n      });\n    } // DEPRECATE: This does not handle offset modes\n\n  }, {\n    key: \"projectFlat\",\n    value: function projectFlat(lngLat) {\n      log.deprecated('layer.projectFlat', 'layer.projectPosition');\n      var viewport = this.context.viewport;\n      assert(Array.isArray(lngLat));\n      return viewport.projectFlat(lngLat);\n    } // DEPRECATE: This is not meaningful in offset modes\n\n  }, {\n    key: \"unprojectFlat\",\n    value: function unprojectFlat(xy) {\n      log.deprecated('layer.unprojectFlat');\n      var viewport = this.context.viewport;\n      assert(Array.isArray(xy));\n      return viewport.unprojectFlat(xy);\n    }\n  }, {\n    key: \"use64bitProjection\",\n    value: function use64bitProjection() {\n      if (this.props.fp64) {\n        if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT_DEPRECATED) {\n          return true;\n        }\n\n        log.once(0, \"64-bit mode only works with coordinateSystem set to\\n        COORDINATE_SYSTEM.LNGLAT. Rendering in 32-bit mode instead\");\n      }\n\n      return false;\n    }\n  }, {\n    key: \"use64bitPositions\",\n    value: function use64bitPositions() {\n      return this.props.fp64 || this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT;\n    } // TODO - needs to refer to context for devicePixels setting\n\n  }, {\n    key: \"screenToDevicePixels\",\n    value: function screenToDevicePixels(screenPixels) {\n      log.deprecated('screenToDevicePixels', 'DeckGL prop useDevicePixels for conversion')();\n      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n      return screenPixels * devicePixelRatio;\n    } // Returns the picking color that doesn't match any subfeature\n    // Use if some graphics do not belong to any pickable subfeature\n    // @return {Array} - a black color\n\n  }, {\n    key: \"nullPickingColor\",\n    value: function nullPickingColor() {\n      return [0, 0, 0];\n    } // Returns the picking color that doesn't match any subfeature\n    // Use if some graphics do not belong to any pickable subfeature\n\n  }, {\n    key: \"encodePickingColor\",\n    value: function encodePickingColor(i) {\n      assert((i + 1 >> 24 & 255) === 0, 'index out of picking color range');\n      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];\n    } // Returns the index corresponding to a picking color that doesn't match any subfeature\n    // @param {Uint8Array} color - color array to be decoded\n    // @return {Array} - the decoded picking color\n\n  }, {\n    key: \"decodePickingColor\",\n    value: function decodePickingColor(color) {\n      assert(color instanceof Uint8Array);\n\n      var _color = _slicedToArray(color, 3),\n          i1 = _color[0],\n          i2 = _color[1],\n          i3 = _color[2]; // 1 was added to seperate from no selection\n\n\n      var index = i1 + i2 * 256 + i3 * 65536 - 1;\n      return index;\n    } // //////////////////////////////////////////////////\n    // LIFECYCLE METHODS, overridden by the layer subclasses\n    // Called once to set up the initial state\n    // App can create WebGL resources\n\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      throw new Error(\"Layer \".concat(this, \" has not defined initializeState\"));\n    } // Let's layer control if updateState should be called\n\n  }, {\n    key: \"shouldUpdateState\",\n    value: function shouldUpdateState(_ref3) {\n      var oldProps = _ref3.oldProps,\n          props = _ref3.props,\n          context = _ref3.context,\n          changeFlags = _ref3.changeFlags;\n      return changeFlags.propsOrDataChanged;\n    } // Default implementation, all attributes will be invalidated and updated\n    // when data changes\n\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref4) {\n      var oldProps = _ref4.oldProps,\n          props = _ref4.props,\n          context = _ref4.context,\n          changeFlags = _ref4.changeFlags;\n      var attributeManager = this.getAttributeManager();\n\n      if (changeFlags.dataChanged && attributeManager) {\n        attributeManager.invalidateAll();\n      }\n    } // Called once when layer is no longer matched and state will be discarded\n    // App can destroy WebGL resources here\n\n  }, {\n    key: \"finalizeState\",\n    value: function finalizeState() {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.getModels()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var model = _step2.value;\n          model.delete();\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var attributeManager = this.getAttributeManager();\n\n      if (attributeManager) {\n        attributeManager.finalize();\n      }\n    } // If state has a model, draw it with supplied uniforms\n\n  }, {\n    key: \"draw\",\n    value: function draw(opts) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.getModels()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var model = _step3.value;\n          model.draw(opts);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    } // called to populate the info object that is passed to the event handler\n    // @return null to cancel event\n\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref5) {\n      var info = _ref5.info,\n          mode = _ref5.mode;\n      var index = info.index;\n\n      if (index >= 0) {\n        // If props.data is an indexable array, get the object\n        if (Array.isArray(this.props.data)) {\n          info.object = this.props.data[index];\n        }\n      }\n\n      return info;\n    } // END LIFECYCLE METHODS\n    // //////////////////////////////////////////////////\n    // INTERNAL METHODS\n    // Default implementation of attribute invalidation, can be redefined\n\n  }, {\n    key: \"invalidateAttribute\",\n    value: function invalidateAttribute() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';\n      var diffReason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var attributeManager = this.getAttributeManager();\n\n      if (!attributeManager) {\n        return;\n      }\n\n      if (name === 'all') {\n        log.log(LOG_PRIORITY_UPDATE, \"updateTriggers invalidating all attributes: \".concat(diffReason))();\n        attributeManager.invalidateAll();\n      } else {\n        log.log(LOG_PRIORITY_UPDATE, \"updateTriggers invalidating attribute \".concat(name, \": \").concat(diffReason))();\n        attributeManager.invalidate(name);\n      }\n    } // Calls attribute manager to update any WebGL attributes\n\n  }, {\n    key: \"updateAttributes\",\n    value: function updateAttributes(props) {\n      var attributeManager = this.getAttributeManager();\n\n      if (!attributeManager) {\n        return;\n      } // Figure out data length\n\n\n      var numInstances = this.getNumInstances(props);\n      attributeManager.update({\n        data: props.data,\n        numInstances: numInstances,\n        props: props,\n        transitions: props.transitions,\n        buffers: props,\n        context: this,\n        // Don't worry about non-attribute props\n        ignoreUnknownAttributes: true\n      });\n      var model = this.getSingleModel();\n\n      if (model) {\n        var changedAttributes = attributeManager.getChangedAttributes({\n          clearChangedFlags: true\n        });\n        model.setAttributes(changedAttributes);\n      }\n    } // Update attribute transition\n\n  }, {\n    key: \"updateTransition\",\n    value: function updateTransition() {\n      var attributeManager = this.getAttributeManager();\n\n      if (attributeManager) {\n        attributeManager.updateTransition();\n      }\n    }\n  }, {\n    key: \"calculateInstancePickingColors\",\n    value: function calculateInstancePickingColors(attribute, _ref6) {\n      var numInstances = _ref6.numInstances;\n      var value = attribute.value,\n          size = attribute.size; // add 1 to index to seperate from no selection\n\n      for (var i = 0; i < numInstances; i++) {\n        var pickingColor = this.encodePickingColor(i);\n        value[i * size + 0] = pickingColor[0];\n        value[i * size + 1] = pickingColor[1];\n        value[i * size + 2] = pickingColor[2];\n      }\n    } // Sets the specified instanced picking color to null picking color. Used for multi picking.\n\n  }, {\n    key: \"_clearInstancePickingColor\",\n    value: function _clearInstancePickingColor(color) {\n      var instancePickingColors = this.getAttributeManager().attributes.instancePickingColors;\n      var value = instancePickingColors.value,\n          size = instancePickingColors.size;\n      var i = this.decodePickingColor(color);\n      value[i * size + 0] = 0;\n      value[i * size + 1] = 0;\n      value[i * size + 2] = 0; // TODO: Optimize this to use sub-buffer update!\n\n      instancePickingColors.update({\n        value: value\n      });\n    } // Sets all occurrences of the specified picking color to null picking color. Used for multi picking.\n\n  }, {\n    key: \"_clearPickingColor\",\n    value: function _clearPickingColor(color) {\n      var pickingColors = this.getAttributeManager().attributes.pickingColors;\n      var value = pickingColors.value;\n\n      for (var i = 0; i < value.length; i += 3) {\n        if (value[i + 0] === color[0] && value[i + 1] === color[1] && value[i + 2] === color[2]) {\n          value[i + 0] = 0;\n          value[i + 1] = 0;\n          value[i + 2] = 0;\n        }\n      } // TODO: Optimize this to use sub-buffer update!\n\n\n      pickingColors.update({\n        value: value\n      });\n    } // This method figures out if we use instance colors or not\n    // and calls _clearInstancePickingColor or _clearPickingColor\n\n  }, {\n    key: \"clearPickingColor\",\n    value: function clearPickingColor(color) {\n      if (this.getAttributeManager().attributes.pickingColors) {\n        this._clearPickingColor(color);\n      } else {\n        this._clearInstancePickingColor(color);\n      }\n    }\n  }, {\n    key: \"copyPickingColors\",\n    value: function copyPickingColors() {\n      var _this$getAttributeMan = this.getAttributeManager().attributes,\n          pickingColors = _this$getAttributeMan.pickingColors,\n          instancePickingColors = _this$getAttributeMan.instancePickingColors;\n      var colors = pickingColors || instancePickingColors;\n      return new Uint8ClampedArray(colors.value);\n    }\n  }, {\n    key: \"restorePickingColors\",\n    value: function restorePickingColors(value) {\n      var _this$getAttributeMan2 = this.getAttributeManager().attributes,\n          pickingColors = _this$getAttributeMan2.pickingColors,\n          instancePickingColors = _this$getAttributeMan2.instancePickingColors;\n      var colors = pickingColors || instancePickingColors;\n      colors.update({\n        value: value\n      });\n    } // Deduces numer of instances. Intention is to support:\n    // - Explicit setting of numInstances\n    // - Auto-deduction for ES6 containers that define a size member\n    // - Auto-deduction for Classic Arrays via the built-in length attribute\n    // - Auto-deduction via arrays\n\n  }, {\n    key: \"getNumInstances\",\n    value: function getNumInstances(props) {\n      props = props || this.props; // First check if the layer has set its own value\n\n      if (this.state && this.state.numInstances !== undefined) {\n        return this.state.numInstances;\n      } // Check if app has provided an explicit value\n\n\n      if (props.numInstances !== undefined) {\n        return props.numInstances;\n      } // Use container library to get a count for any ES6 container or object\n\n\n      var data = this.props.data;\n      return count(data);\n    } // LAYER MANAGER API\n    // Should only be called by the deck.gl LayerManager class\n    // Called by layer manager when a new layer is found\n\n    /* eslint-disable max-statements */\n\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      assert(this.context.gl);\n\n      this._initState(); // Call subclass lifecycle methods\n\n\n      this.initializeState(this.context); // End subclass lifecycle methods\n      // TODO deprecated, for backwards compatibility with older layers\n      // in case layer resets state\n\n      this.state.attributeManager = this.getAttributeManager(); // initializeState callback tends to clear state\n\n      this.setChangeFlags({\n        dataChanged: true,\n        propsChanged: true,\n        viewportChanged: true\n      });\n\n      this._updateState();\n\n      var model = this.getSingleModel();\n\n      if (model) {\n        model.id = this.props.id;\n        model.program.id = \"\".concat(this.props.id, \"-program\");\n        model.geometry.id = \"\".concat(this.props.id, \"-geometry\");\n      }\n    } // Called by layer manager\n    // if this layer is new (not matched with an existing layer) oldProps will be empty object\n\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      // Call subclass lifecycle method\n      var stateNeedsUpdate = this.needsUpdate(); // End lifecycle method\n\n      if (stateNeedsUpdate) {\n        this._updateState();\n      }\n    }\n    /* eslint-enable max-statements */\n    // Common code for _initialize and _update\n\n  }, {\n    key: \"_updateState\",\n    value: function _updateState() {\n      var updateParams = this._getUpdateParams(); // Call subclass lifecycle methods\n\n\n      this.updateState(updateParams); // Render or update previously rendered sublayers\n\n      if (this.isComposite) {\n        this._renderLayers(updateParams);\n      } // End subclass lifecycle methods\n      // Add any subclass attributes\n\n\n      this.updateAttributes(this.props);\n\n      this._updateBaseUniforms(); // Note: Automatic instance count update only works for single layers\n\n\n      if (this.state.model) {\n        this.state.model.setInstanceCount(this.getNumInstances());\n      }\n\n      this.clearChangeFlags();\n      this.internalState.resetOldProps();\n    } // Called by manager when layer is about to be disposed\n    // Note: not guaranteed to be called on application shutdown\n\n  }, {\n    key: \"_finalize\",\n    value: function _finalize() {\n      assert(this.internalState && this.state); // Call subclass lifecycle method\n\n      this.finalizeState(this.context); // End lifecycle method\n\n      removeLayerInSeer(this.id);\n    } // Calculates uniforms\n\n  }, {\n    key: \"drawLayer\",\n    value: function drawLayer(_ref7) {\n      var _this = this;\n\n      var _ref7$moduleParameter = _ref7.moduleParameters,\n          moduleParameters = _ref7$moduleParameter === void 0 ? null : _ref7$moduleParameter,\n          _ref7$uniforms = _ref7.uniforms,\n          uniforms = _ref7$uniforms === void 0 ? {} : _ref7$uniforms,\n          _ref7$parameters = _ref7.parameters,\n          parameters = _ref7$parameters === void 0 ? {} : _ref7$parameters;\n\n      if (!uniforms.picking_uActive) {\n        this.updateTransition();\n      } // TODO/ib - hack move to luma Model.draw\n\n\n      if (moduleParameters) {\n        this.setModuleParameters(moduleParameters);\n      } // Hack/ib - define a public luma function\n\n\n      var animationProps = this.context.animationProps;\n\n      if (animationProps) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.getModels()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var model = _step4.value;\n\n            model._setAnimationProps(animationProps);\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      } // Apply polygon offset to avoid z-fighting\n      // TODO - move to draw-layers\n\n\n      var getPolygonOffset = this.props.getPolygonOffset;\n      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];\n      parameters.polygonOffset = offsets; // Call subclass lifecycle method\n\n      withParameters(this.context.gl, parameters, function () {\n        _this.draw({\n          moduleParameters: moduleParameters,\n          uniforms: uniforms,\n          parameters: parameters,\n          context: _this.context\n        });\n      }); // End lifecycle method\n    } // {uniforms = {}, ...opts}\n\n  }, {\n    key: \"pickLayer\",\n    value: function pickLayer(opts) {\n      // Call subclass lifecycle method\n      return this.getPickingInfo(opts); // End lifecycle method\n    } // Helper methods\n\n  }, {\n    key: \"getChangeFlags\",\n    value: function getChangeFlags() {\n      return this.internalState.changeFlags;\n    } // Dirty some change flags, will be handled by updateLayer\n\n    /* eslint-disable complexity */\n\n  }, {\n    key: \"setChangeFlags\",\n    value: function setChangeFlags(flags) {\n      var _this2 = this;\n\n      this.internalState.changeFlags = this.internalState.changeFlags || {};\n      var changeFlags = this.internalState.changeFlags; // Update primary flags\n\n      if (flags.dataChanged && !changeFlags.dataChanged) {\n        changeFlags.dataChanged = flags.dataChanged;\n        log.log(LOG_PRIORITY_UPDATE + 1, function () {\n          return \"dataChanged: \".concat(flags.dataChanged, \" in \").concat(_this2.id);\n        })();\n      }\n\n      if (flags.updateTriggersChanged && !changeFlags.updateTriggersChanged) {\n        changeFlags.updateTriggersChanged = changeFlags.updateTriggersChanged && flags.updateTriggersChanged ? Object.assign({}, flags.updateTriggersChanged, changeFlags.updateTriggersChanged) : flags.updateTriggersChanged || changeFlags.updateTriggersChanged;\n        log.log(LOG_PRIORITY_UPDATE + 1, function () {\n          return 'updateTriggersChanged: ' + \"\".concat(Object.keys(flags.updateTriggersChanged).join(', '), \" in \").concat(_this2.id);\n        })();\n      }\n\n      if (flags.propsChanged && !changeFlags.propsChanged) {\n        changeFlags.propsChanged = flags.propsChanged;\n        log.log(LOG_PRIORITY_UPDATE + 1, function () {\n          return \"propsChanged: \".concat(flags.propsChanged, \" in \").concat(_this2.id);\n        })();\n      }\n\n      if (flags.viewportChanged && !changeFlags.viewportChanged) {\n        changeFlags.viewportChanged = flags.viewportChanged;\n        log.log(LOG_PRIORITY_UPDATE + 2, function () {\n          return \"viewportChanged: \".concat(flags.viewportChanged, \" in \").concat(_this2.id);\n        })();\n      }\n\n      if (flags.stateChanged && !changeFlags.stateChanged) {\n        changeFlags.stateChanged = flags.stateChanged;\n        log.log(LOG_PRIORITY_UPDATE + 1, function () {\n          return \"stateChanged: \".concat(flags.stateChanged, \" in \").concat(_this2.id);\n        })();\n      } // Update composite flags\n\n\n      var propsOrDataChanged = flags.dataChanged || flags.updateTriggersChanged || flags.propsChanged;\n      changeFlags.propsOrDataChanged = changeFlags.propsOrDataChanged || propsOrDataChanged;\n      changeFlags.somethingChanged = changeFlags.somethingChanged || propsOrDataChanged || flags.viewportChanged || flags.stateChanged;\n    }\n    /* eslint-enable complexity */\n    // Clear all changeFlags, typically after an update\n\n  }, {\n    key: \"clearChangeFlags\",\n    value: function clearChangeFlags() {\n      this.internalState.changeFlags = {\n        // Primary changeFlags, can be strings stating reason for change\n        dataChanged: false,\n        propsChanged: false,\n        updateTriggersChanged: false,\n        viewportChanged: false,\n        stateChanged: false,\n        // Derived changeFlags\n        propsOrDataChanged: false,\n        somethingChanged: false\n      };\n    }\n  }, {\n    key: \"printChangeFlags\",\n    value: function printChangeFlags() {\n      var flags = this.internalState.changeFlags;\n      return \"\".concat(flags.dataChanged ? 'data ' : '').concat(flags.propsChanged ? 'props ' : '').concat(flags.updateTriggersChanged ? 'triggers ' : '').concat(flags.viewportChanged ? 'viewport' : '');\n    } // Compares the layers props with old props from a matched older layer\n    // and extracts change flags that describe what has change so that state\n    // can be update correctly with minimal effort\n\n  }, {\n    key: \"diffProps\",\n    value: function diffProps(newProps, oldProps) {\n      var changeFlags = _diffProps(newProps, oldProps); // iterate over changedTriggers\n\n\n      if (changeFlags.updateTriggersChanged) {\n        for (var key in changeFlags.updateTriggersChanged) {\n          if (changeFlags.updateTriggersChanged[key]) {\n            this._activeUpdateTrigger(key);\n          }\n        }\n      }\n\n      return this.setChangeFlags(changeFlags);\n    }\n  }, {\n    key: \"setModuleParameters\",\n    value: function setModuleParameters(moduleParameters) {\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this.getModels()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var model = _step5.value;\n          model.updateModuleSettings(moduleParameters);\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n    } // PRIVATE METHODS\n\n  }, {\n    key: \"_getUpdateParams\",\n    value: function _getUpdateParams() {\n      return {\n        props: this.props,\n        oldProps: this.internalState.getOldProps(),\n        context: this.context,\n        changeFlags: this.internalState.changeFlags\n      };\n    } // Checks state of attributes and model\n\n  }, {\n    key: \"_getNeedsRedraw\",\n    value: function _getNeedsRedraw(clearRedrawFlags) {\n      // this method may be called by the render loop as soon a the layer\n      // has been created, so guard against uninitialized state\n      if (!this.internalState) {\n        return false;\n      }\n\n      var redraw = false;\n      redraw = redraw || this.internalState.needsRedraw && this.id;\n      this.internalState.needsRedraw = this.internalState.needsRedraw && !clearRedrawFlags; // TODO - is attribute manager needed? - Model should be enough.\n\n      var attributeManager = this.getAttributeManager();\n      var attributeManagerNeedsRedraw = attributeManager && attributeManager.getNeedsRedraw({\n        clearRedrawFlags: clearRedrawFlags\n      });\n\n      var modelNeedsRedraw = this._modelNeedsRedraw(clearRedrawFlags);\n\n      redraw = redraw || attributeManagerNeedsRedraw || modelNeedsRedraw;\n      return redraw;\n    }\n  }, {\n    key: \"_modelNeedsRedraw\",\n    value: function _modelNeedsRedraw(clearRedrawFlags) {\n      var redraw = false;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var model = _step6.value;\n          var modelNeedsRedraw = model.getNeedsRedraw({\n            clearRedrawFlags: clearRedrawFlags\n          });\n\n          if (modelNeedsRedraw && typeof modelNeedsRedraw !== 'string') {\n            modelNeedsRedraw = \"model \".concat(model.id);\n          }\n\n          redraw = redraw || modelNeedsRedraw;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return redraw;\n    } // Create new attribute manager\n\n  }, {\n    key: \"_getAttributeManager\",\n    value: function _getAttributeManager() {\n      return new AttributeManager(this.context.gl, {\n        id: this.props.id,\n        stats: this.context.stats\n      });\n    }\n  }, {\n    key: \"_initState\",\n    value: function _initState() {\n      assert(!this.internalState && !this.state);\n\n      var attributeManager = this._getAttributeManager();\n\n      if (attributeManager) {\n        // All instanced layers get instancePickingColors attribute by default\n        // Their shaders can use it to render a picking scene\n        // TODO - this slightly slows down non instanced layers\n        attributeManager.addInstanced({\n          instancePickingColors: {\n            type: GL.UNSIGNED_BYTE,\n            size: 3,\n            update: this.calculateInstancePickingColors\n          }\n        });\n      }\n\n      this.internalState = new LayerState({\n        attributeManager: attributeManager,\n        layer: this\n      });\n      this.state = {}; // TODO deprecated, for backwards compatibility with older layers\n\n      this.state.attributeManager = attributeManager;\n      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this); // Ensure any async props are updated\n\n      this.internalState.setAsyncProps(this.props);\n    } // Called by layer manager to transfer state from an old layer\n\n  }, {\n    key: \"_transferState\",\n    value: function _transferState(oldLayer) {\n      var state = oldLayer.state,\n          internalState = oldLayer.internalState;\n      assert(state && internalState);\n\n      if (this === oldLayer) {\n        return;\n      } // Move internalState\n\n\n      this.internalState = internalState;\n      this.internalState.component = this; // Move state\n\n      this.state = state; // Deprecated: layer references on `state`\n\n      state.layer = this; // We keep the state ref on old layers to support async actions\n      // oldLayer.state = null;\n      // Ensure any async props are updated\n\n      this.internalState.setAsyncProps(this.props); // Update model layer reference\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.getModels()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var model = _step7.value;\n          model.userData.layer = this;\n        } // Ensure any async props are updated\n\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      this.internalState.setAsyncProps(this.props);\n      this.diffProps(this.props, this.internalState.getOldProps());\n    }\n  }, {\n    key: \"_onAsyncPropUpdated\",\n    value: function _onAsyncPropUpdated() {\n      this.diffProps(this.props, this.internalState.getOldProps());\n      this.setLayerNeedsUpdate();\n    } // Operate on each changed triggers, will be called when an updateTrigger changes\n\n  }, {\n    key: \"_activeUpdateTrigger\",\n    value: function _activeUpdateTrigger(propName) {\n      this.invalidateAttribute(propName);\n    } //  Helper to check that required props are supplied\n\n  }, {\n    key: \"_checkRequiredProp\",\n    value: function _checkRequiredProp(propertyName, condition) {\n      var value = this.props[propertyName];\n\n      if (value === undefined) {\n        throw new Error(\"Property \".concat(propertyName, \" undefined in layer \").concat(this));\n      }\n\n      if (condition && !condition(value)) {\n        throw new Error(\"Bad property \".concat(propertyName, \" in layer \").concat(this));\n      }\n    }\n  }, {\n    key: \"_updateBaseUniforms\",\n    value: function _updateBaseUniforms() {\n      var _this3 = this;\n\n      var uniforms = {\n        // apply gamma to opacity to make it visually \"linear\"\n        opacity: typeof this.props.opacity === 'function' ? function (animationProps) {\n          return Math.pow(_this3.props.opacity(animationProps), 1 / 2.2);\n        } : Math.pow(this.props.opacity, 1 / 2.2)\n      };\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this.getModels()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var model = _step8.value;\n          model.setUniforms(uniforms);\n        } // TODO - set needsRedraw on the model(s)?\n\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      this.setNeedsRedraw();\n    } // DEPRECATED METHODS\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(uniformMap) {\n      var _iteratorNormalCompletion9 = true;\n      var _didIteratorError9 = false;\n      var _iteratorError9 = undefined;\n\n      try {\n        for (var _iterator9 = this.getModels()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n          var model = _step9.value;\n          model.setUniforms(uniformMap);\n        } // TODO - set needsRedraw on the model(s)?\n\n      } catch (err) {\n        _didIteratorError9 = true;\n        _iteratorError9 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {\n            _iterator9.return();\n          }\n        } finally {\n          if (_didIteratorError9) {\n            throw _iteratorError9;\n          }\n        }\n      }\n\n      this.setNeedsRedraw();\n      log.deprecated('layer.setUniforms', 'model.setUniforms')();\n    }\n  }, {\n    key: \"is64bitEnabled\",\n    value: function is64bitEnabled() {\n      log.deprecated('is64bitEnabled', 'use64bitProjection')();\n      return this.use64bitProjection();\n    }\n  }]);\n\n  return Layer;\n}(Component);\n\nexport { Layer as default };\nLayer.layerName = 'Layer';\nLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}