{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\"; // Depends on Khronos Debug support module being imported via \"luma.gl/debug\"\n\nimport { global } from '../utils/globals';\nimport { log } from '../utils'; // Helper to get shared context data\n\nfunction getContextData(gl) {\n  gl.luma = gl.luma || {};\n  return gl.luma;\n} // Enable or disable debug checks in debug contexts\n// Non-debug contexts do not have checks (to ensure performance)\n// Turning off debug for debug contexts removes most of the performance penalty\n\n\nexport function enableDebug(debug) {\n  log.debug = debug;\n} // Returns (a potentially new) context with debug instrumentation turned off or on.\n// Note that this actually returns a new context\n\nexport function makeDebugContext(gl) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$debug = _ref.debug,\n      debug = _ref$debug === void 0 ? true : _ref$debug;\n\n  if (gl === null) {\n    // Return to ensure we don't create a context in this case.\n    return null;\n  }\n\n  return debug ? getDebugContext(gl) : getRealContext(gl);\n} // Returns the real context from either of the real/debug contexts\n\nexport function getRealContext(gl) {\n  if (gl === null) {\n    // Return to ensure we don't create a context in this case.\n    return null;\n  }\n\n  var data = getContextData(gl); // If the context has a realContext member, it is a debug context so return the realContext\n\n  return data.realContext ? data.realContext : gl;\n} // Returns the debug context from either of the real/debug contexts\n\nexport function getDebugContext(gl) {\n  if (gl === null) {\n    // Return to ensure we don't create a context in this case.\n    return null;\n  }\n\n  if (!global.WebGLDebug) {\n    log.warn('WebGL debug mode not activated. import \"luma.gl/debug\" to enable.')();\n    return gl;\n  }\n\n  var data = getContextData(gl); // If this *is* a debug context, return itself\n\n  if (data.realContext) {\n    return gl;\n  } // If this already has a debug context, return it.\n\n\n  if (data.debugContext) {\n    return data.debugContext;\n  } // Create a new debug context\n\n\n  var WebGLDebugContext = function WebGLDebugContext() {\n    _classCallCheck(this, WebGLDebugContext);\n  };\n\n  var debugContext = global.WebGLDebug.makeDebugContext(gl, onGLError, onValidateGLFunc);\n  Object.assign(WebGLDebugContext.prototype, debugContext); // Store the debug context\n\n  data.debugContext = debugContext;\n  debugContext.debug = true;\n  debugContext.gl = gl;\n  log.info('debug context actived.'); // Return it\n\n  return debugContext;\n} // DEBUG TRACING\n\nfunction getFunctionString(functionName, functionArgs) {\n  var args = global.WebGLDebug.glFunctionArgsToString(functionName, functionArgs);\n  args = \"\".concat(args.slice(0, 100)).concat(args.length > 100 ? '...' : '');\n  return \"gl.\".concat(functionName, \"(\").concat(args, \")\");\n}\n\nfunction onGLError(err, functionName, args) {\n  var errorMessage = global.WebGLDebug.glEnumToString(err);\n  var functionArgs = global.WebGLDebug.glFunctionArgsToString(functionName, args);\n  var message = \"\".concat(errorMessage, \" in gl.\").concat(functionName, \"(\").concat(functionArgs, \")\");\n\n  if (log.throw) {\n    throw new Error(message);\n  } else {\n    log.error(message)();\n    debugger; // eslint-disable-line\n  }\n} // Don't generate function string until it is needed\n\n\nfunction onValidateGLFunc(functionName, functionArgs) {\n  var functionString;\n\n  if (log.priority >= 4) {\n    functionString = getFunctionString(functionName, functionArgs);\n    log.log(4, functionString)();\n  }\n\n  if (log.break) {\n    functionString = functionString || getFunctionString(functionName, functionArgs);\n    var isBreakpoint = log.break && log.break.every(function (breakOn) {\n      return functionString.indexOf(breakOn) !== -1;\n    });\n\n    if (isBreakpoint) {\n      debugger; // eslint-disable-line\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = functionArgs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var arg = _step.value;\n\n      if (arg === undefined) {\n        functionString = functionString || getFunctionString(functionName, functionArgs);\n\n        if (log.throw) {\n          throw new Error(\"Undefined argument: \".concat(functionString));\n        } else {\n          log.error(\"Undefined argument: \".concat(functionString));\n          debugger; // eslint-disable-line\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}