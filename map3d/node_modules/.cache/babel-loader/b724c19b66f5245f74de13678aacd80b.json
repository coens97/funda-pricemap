{"ast":null,"code":"function _instanceof(left, right) {\n  return null != right && \"undefined\" != typeof Symbol && right[Symbol.hasInstance] ? right[Symbol.hasInstance](left) : left instanceof right;\n}\n\nfunction _typeof(obj) {\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [],\n      _n = !0,\n      _d = !1,\n      _e = void 0;\n\n  try {\n    for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), !(i && _arr.length === i)); _n = !0) {\n      ;\n    }\n  } catch (err) {\n    _d = !0, _e = err;\n  } finally {\n    try {\n      _n || null == _i[\"return\"] || _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(target, props) {\n  for (var descriptor, i = 0; i < props.length; i++) {\n    descriptor = props[i], descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  return call && (\"object\" === _typeof(call) || \"function\" == typeof call) ? call : _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\");\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: !0,\n      configurable: !0\n    }\n  }), superClass && _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  return _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    return o.__proto__ = p, o;\n  }, _setPrototypeOf(o, p);\n}\n\nimport { createElement } from \"react\";\nimport PropTypes from \"prop-types\";\nimport BaseControl from \"./base-control\";\n\nvar propTypes = Object.assign({}, BaseControl.propTypes, {\n  className: PropTypes.string,\n  longitude: PropTypes.number.isRequired,\n  latitude: PropTypes.number.isRequired,\n  offsetLeft: PropTypes.number,\n  offsetTop: PropTypes.number\n}),\n    defaultProps = Object.assign({}, BaseControl.defaultProps, {\n  className: \"\",\n  offsetLeft: 0,\n  offsetTop: 0\n}),\n    Marker = function (_BaseControl) {\n  function Marker() {\n    return _classCallCheck(this, Marker), _possibleConstructorReturn(this, (Marker.__proto__ || Object.getPrototypeOf(Marker)).apply(this, arguments));\n  }\n\n  return _inherits(Marker, _BaseControl), _createClass(Marker, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          className = _this$props.className,\n          longitude = _this$props.longitude,\n          latitude = _this$props.latitude,\n          offsetLeft = _this$props.offsetLeft,\n          offsetTop = _this$props.offsetTop,\n          _this$context$viewpor = this.context.viewport.project([longitude, latitude]),\n          _this$context$viewpor2 = _slicedToArray(_this$context$viewpor, 2),\n          x = _this$context$viewpor2[0],\n          y = _this$context$viewpor2[1];\n\n      return createElement(\"div\", {\n        className: \"mapboxgl-marker \".concat(className),\n        ref: this._onContainerLoad,\n        style: {\n          position: \"absolute\",\n          left: x + offsetLeft,\n          top: y + offsetTop\n        },\n        children: this.props.children\n      });\n    }\n  }]), Marker;\n}(BaseControl);\n\nexport { Marker as default };\nMarker.displayName = \"Marker\", Marker.propTypes = propTypes, Marker.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}