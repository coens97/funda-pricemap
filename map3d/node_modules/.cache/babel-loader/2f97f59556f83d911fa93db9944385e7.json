{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _TEXTURE_FORMATS;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/* eslint-disable no-inline-comments, max-len */\n\n\nimport GL from './gl-constants';\nimport { WebGLBuffer } from './api';\nimport { isWebGL, ERR_WEBGL, isWebGL2, ERR_WEBGL2 } from './context';\nimport { withParameters } from './context-state';\nimport Resource from './resource';\nimport Buffer from './buffer';\nimport { uid, isPowerOfTwo, log } from '../utils';\nimport assert from 'assert';\nimport { glKey } from './gl-constants'; // Supported min filters for NPOT texture.\n\nvar NPOT_MIN_FILTERS = [GL.LINEAR, GL.NEAREST]; // const S3TC = 'WEBGL_compressed_texture_s3tc';\n// const PVRTC = 'WEBGL_compressed_texture_pvrtc';\n// const ES3 = 'WEBGL_compressed_texture_es3';\n// const ETC1 = 'WEBGL_compressed_texture_etc1';\n// const SRGB = 'EXT_sRGB';\n// const DEPTH = 'WEBGL_depth_texture';\n// Legal combinations for internalFormat, format and type\n\nexport var TEXTURE_FORMATS = (_TEXTURE_FORMATS = {}, _defineProperty(_TEXTURE_FORMATS, GL.RGB, {\n  dataFormat: GL.RGB,\n  types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_5_6_5]\n}), _defineProperty(_TEXTURE_FORMATS, GL.RGBA, {\n  dataFormat: GL.RGBA,\n  types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_4_4_4_4, GL.UNSIGNED_SHORT_5_5_5_1]\n}), _defineProperty(_TEXTURE_FORMATS, GL.ALPHA, {\n  dataFormat: GL.ALPHA,\n  types: [GL.UNSIGNED_BYTE]\n}), _defineProperty(_TEXTURE_FORMATS, GL.LUMINANCE, {\n  dataFormat: GL.LUMINANCE,\n  types: [GL.UNSIGNED_BYTE]\n}), _defineProperty(_TEXTURE_FORMATS, GL.LUMINANCE_ALPHA, {\n  dataFormat: GL.LUMINANCE_ALPHA,\n  types: [GL.UNSIGNED_BYTE] // [GL.DEPTH_COMPONENT]: {types: [GL.UNSIGNED_SHORT, GL.UNSIGNED_INT, GL.UNSIGNED_INT_24_8], gl1: DEPTH},\n  // [GL.DEPTH_STENCIL]: {gl1: DEPTH},\n  // Sized texture format - more performance\n  // R\n  // [GL.R8]: {dataFormat: GL.RED, types: [GL.UNSIGNED_BYTE], gl2: true},\n  // [GL.R16F]: {dataFormat: GL.RED, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},\n  // [GL.R32F]: {dataFormat: GL.RED, types: [GL.FLOAT], gl2: true},\n  // [GL.R8UI]: {dataFormat: GL.RED_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},\n  // // RG\n  // [GL.RG8]: {dataFormat: GL.RG, types: [GL.UNSIGNED_BYTE], gl2: true},\n  // [GL.RG16F]: {dataFormat: GL.RG, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},\n  // [GL.RG32F]: {dataFormat: GL.RG, types: [GL.FLOAT], gl2: true},\n  // [GL.RG8UI]: {dataFormat: GL.RG_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},\n  // // RGB\n  // [GL.RGB8]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},\n  // [GL.SRGB8]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},\n  // [GL.RGB565]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_5_6_5], gl2: true},\n  // [GL.R11F_G11F_B10F]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_INT_10F_11F_11F_REV, GL.HALF_FLOAT, GL.FLOAT], gl2: true},\n  // [GL.RGB9_E5]: {dataFormat: GL.RGB, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true, gl1: 'WEBGL_color_buffer_half_float'},\n  // [GL.RGB16F]: {dataFormat: GL.RGB, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true, gl1: 'WEBGL_color_buffer_float'},\n  // [GL.RGB32F]: {dataFormat: GL.RGB, types: [GL.FLOAT], gl2: true},\n  // [GL.RGB8UI]: {dataFormat: GL.RGB_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},\n  // // RGBA\n  // [GL.RGBA8]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},\n  // [GL.SRGB8_ALPHA8]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},\n  // [GL.RGB5_A1]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_5_5_5_1], gl2: true},\n  // [GL.RGBA4]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_4_4_4_4], gl2: true},\n  // [GL.RGBA16F]: {dataFormat: GL.RGBA, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},\n  // [GL.RGBA32F]: {dataFormat: GL.RGBA, types: [GL.FLOAT], gl2: true},\n  // [GL.RGBA8UI]: {dataFormat: GL.RGBA_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true}\n  // Compressed formats\n  // WEBGL_compressed_texture_s3tc\n  // [GL.COMPRESSED_RGB_S3TC_DXT1_EXT]: {compressed: true, gl1: S3TC},\n  // [GL.COMPRESSED_RGBA_S3TC_DXT1_EXT]: {compressed: true, gl1: S3TC},\n  // [GL.COMPRESSED_RGBA_S3TC_DXT3_EXT]: {compressed: true, gl1: S3TC},\n  // [GL.COMPRESSED_RGBA_S3TC_DXT5_EXT]: {compressed: true, gl1: S3TC},\n  // WEBGL_compressed_texture_es3\n  // [GL.COMPRESSED_R11_EAC]: {compressed: true, gl1: ES3}, // RED\n  // [GL.COMPRESSED_SIGNED_R11_EAC]: {compressed: true, gl1: ES3}, // RED\n  // [GL.COMPRESSED_RG11_EAC]: {compressed: true, gl1: ES3}, // RG\n  // [GL.COMPRESSED_SIGNED_RG11_EAC]: {compressed: true, gl1: ES3}, // RG\n  // [GL.COMPRESSED_RGB8_ETC2]: {compressed: true, gl1: ES3}, // RGB\n  // [GL.COMPRESSED_RGBA8_ETC2_EAC]: {compressed: true, gl1: ES3}, // RBG\n  // [GL.COMPRESSED_SRGB8_ETC2]: {compressed: true, gl1: ES3}, // RGB\n  // [GL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: {compressed: true, gl1: ES3}, // RGBA\n  // [GL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: {compressed: true, gl1: ES3}, // RGBA\n  // [GL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: {compressed: true, gl1: ES3}, // RGBA\n\n  /* WebGL2 guaranteed availability compressed formats?\n  COMPRESSED_R11_EAC RED\n  COMPRESSED_SIGNED_R11_EAC RED\n  COMPRESSED_RG11_EAC RG\n  COMPRESSED_SIGNED_RG11_EAC RG\n  COMPRESSED_RGB8_ETC2 RGB\n  COMPRESSED_SRGB8_ETC2 RGB\n  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA\n  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA\n  COMPRESSED_RGBA8_ETC2_EAC RGBA\n  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC\n  */\n  // WEBGL_compressed_texture_pvrtc\n  // [GL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG]: {compressed: true, gl1: PVRTC},\n  // [GL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG]: {compressed: true, gl1: PVRTC},\n  // [GL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG]: {compressed: true, gl1: PVRTC},\n  // [GL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG]: {compressed: true, gl1: PVRTC},\n  // WEBGL_compressed_texture_etc1\n  // [GL.COMPRESSED_RGB_ETC1_WEBGL]: {compressed: true, gl1: ETC1},\n  // WEBGL_compressed_texture_atc\n  // [GL.COMPRESSED_RGB_ATC_WEBGL]: {compressed: true, gl1: ETC1},\n  // [GL.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL]: {compressed: true, gl1: ETC1},\n  // [GL.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL]: {compressed: true, gl1: ETC1}\n\n}), _TEXTURE_FORMATS);\n\nfunction isFormatSupported(gl, format) {\n  assert(isWebGL(gl), ERR_WEBGL);\n  var info = TEXTURE_FORMATS[format];\n\n  if (!info) {\n    return false;\n  }\n\n  if (info.gl1 === undefined && info.gl2 === undefined) {\n    // No info - always supported\n    return true;\n  }\n\n  var value = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;\n  return typeof value === 'string' ? gl.getExtension(value) : value;\n}\n\nfunction isLinearFilteringSupported(gl, format) {\n  var info = TEXTURE_FORMATS[format];\n\n  switch (info && info.types[0]) {\n    // Both WebGL1 and WebGL2?\n    case GL.FLOAT:\n      return gl.getExtension('OES_texture_float_linear');\n    // Not in WebGL2?\n\n    case GL.HALF_FLOAT:\n      return gl.getExtension('OES_texture_half_float_linear');\n\n    default:\n      return true;\n  }\n}\n\nvar Texture =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Texture, _Resource);\n\n  _createClass(Texture, null, [{\n    key: 'isSupported',\n    value: function isSupported(gl) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          format = _ref.format,\n          linearFiltering = _ref.linearFiltering;\n\n      assert(isWebGL(gl), ERR_WEBGL);\n      var supported = true;\n\n      if (format) {\n        supported = supported && isFormatSupported(gl, format);\n        supported = supported && (!linearFiltering || isLinearFilteringSupported(gl, format));\n      }\n\n      return supported;\n    } // target cannot be modified by bind:\n    // textures are special because when you first bind them to a target,\n    // they get special information. When you first bind a texture as a\n    // GL_TEXTURE_2D, you are actually setting special state in the texture.\n    // You are saying that this texture is a 2D texture.\n    // And it will always be a 2D texture; this state cannot be changed ever.\n    // If you have a texture that was first bound as a GL_TEXTURE_2D,\n    // you must always bind it as a GL_TEXTURE_2D;\n    // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n    // (while run-time).\n\n  }]);\n\n  function Texture(gl, opts) {\n    _classCallCheck(this, Texture);\n\n    var _opts$id = opts.id,\n        id = _opts$id === undefined ? uid('texture') : _opts$id,\n        handle = opts.handle,\n        target = opts.target;\n\n    var _this = _possibleConstructorReturn(this, (Texture.__proto__ || Object.getPrototypeOf(Texture)).call(this, gl, {\n      id: id,\n      handle: handle\n    }));\n\n    _this.target = target;\n    _this.hasFloatTexture = gl.getExtension('OES_texture_float');\n    _this.textureUnit = undefined;\n    return _this;\n  }\n\n  _createClass(Texture, [{\n    key: 'toString',\n    value: function toString() {\n      return 'Texture(' + this.id + ',' + this.width + 'x' + this.height + ')';\n    }\n    /* eslint-disable max-len, max-statements */\n\n  }, {\n    key: 'initialize',\n    value: function initialize() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var data = opts.data;\n      var _opts$pixels = opts.pixels,\n          pixels = _opts$pixels === undefined ? null : _opts$pixels,\n          _opts$format = opts.format,\n          format = _opts$format === undefined ? GL.RGBA : _opts$format,\n          _opts$type = opts.type,\n          type = _opts$type === undefined ? GL.UNSIGNED_BYTE : _opts$type,\n          _opts$border = opts.border,\n          border = _opts$border === undefined ? 0 : _opts$border,\n          _opts$recreate = opts.recreate,\n          recreate = _opts$recreate === undefined ? false : _opts$recreate,\n          _opts$parameters = opts.parameters,\n          parameters = _opts$parameters === undefined ? {} : _opts$parameters,\n          _opts$pixelStore = opts.pixelStore,\n          pixelStore = _opts$pixelStore === undefined ? {} : _opts$pixelStore,\n          _opts$unpackFlipY = opts.unpackFlipY,\n          unpackFlipY = _opts$unpackFlipY === undefined ? true : _opts$unpackFlipY,\n          generateMipmaps = opts.generateMipmaps;\n      var _opts$mipmaps = opts.mipmaps,\n          mipmaps = _opts$mipmaps === undefined ? true : _opts$mipmaps;\n\n      if (generateMipmaps !== undefined) {\n        log.deprecated('generateMipmaps', 'mipmaps');\n        mipmaps = generateMipmaps;\n      } // pixels variable is  for API compatibility purpose\n\n\n      if (!data) {\n        log.deprecated('data', 'pixels');\n        data = pixels;\n      }\n\n      var width = opts.width,\n          height = opts.height,\n          dataFormat = opts.dataFormat; // Deduce width and height\n      // Store opts for accessors\n\n      var _deduceParameters2 = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: false,\n        data: data,\n        width: width,\n        height: height\n      });\n\n      width = _deduceParameters2.width;\n      height = _deduceParameters2.height;\n      dataFormat = _deduceParameters2.dataFormat;\n      this.width = width;\n      this.height = height;\n      this.format = format;\n      this.type = type;\n      this.dataFormat = dataFormat;\n      this.border = border;\n      this.mipmaps = mipmaps; // Note: luma.gl defaults to GL.UNPACK_FLIP_Y_WEBGL = true;\n      // TODO - compare v4 and v3\n\n      var DEFAULT_TEXTURE_SETTINGS = _defineProperty({}, GL.UNPACK_FLIP_Y_WEBGL, unpackFlipY);\n\n      var glSettings = Object.assign({}, DEFAULT_TEXTURE_SETTINGS, pixelStore);\n\n      if (this._isNPOT()) {\n        log.warn(0, 'texture: ' + this + ' is Non-Power-Of-Two, disabling mipmaping');\n        mipmaps = false;\n\n        this._updateForNPOT(parameters);\n      }\n\n      this.setImageData({\n        data: data,\n        width: width,\n        height: height,\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        border: border,\n        mipmaps: mipmaps,\n        parameters: glSettings\n      });\n\n      if (mipmaps) {\n        this.generateMipmap();\n      } // Append any v3 style parameters\n\n\n      var updatedParameters = this._applyV3Options(parameters, opts); // Set texture sampler parameters\n\n\n      this.setParameters(updatedParameters); // TODO - Store data to enable auto recreate on context loss\n\n      if (recreate) {\n        this.data = data;\n      }\n    } // If size has changed, reinitializes with current format\n    // note clears image and mipmaps\n\n  }, {\n    key: 'resize',\n    value: function resize(_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height;\n\n      if (width !== this.width || height !== this.height) {\n        return this.initialize({\n          width: width,\n          height: height,\n          format: this.format,\n          type: this.type,\n          dataFormat: this.dataFormat,\n          border: this.border,\n          mipmaps: false\n        });\n      }\n\n      return this;\n    } // Call to regenerate mipmaps after modifying texture(s)\n\n  }, {\n    key: 'generateMipmap',\n    value: function generateMipmap() {\n      var _this2 = this;\n\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.gl.bindTexture(this.target, this.handle);\n      withParameters(this.gl, params, function () {\n        _this2.gl.generateMipmap(_this2.target);\n      });\n      this.gl.bindTexture(this.target, null);\n      return this;\n    }\n    /*\n     * Allocates storage\n     * @param {*} pixels -\n     *  null - create empty texture of specified format\n     *  Typed array - init from image data in typed array\n     *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n     *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n     *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n     *  HTMLVideoElement - Creates video texture. Auto width/height\n     *\n     * @param {GLint} width -\n     * @param {GLint} height -\n     * @param {GLint} mipMapLevel -\n     * @param {GLenum} format - format of image data.\n     * @param {GLenum} type\n     *  - format of array (autodetect from type) or\n     *  - (WEBGL2) format of buffer\n     * @param {Number} offset - (WEBGL2) offset from start of buffer\n     * @param {GLint} border - must be 0.\n     * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n     */\n\n    /* eslint-disable max-len, max-statements, complexity */\n\n  }, {\n    key: 'setImageData',\n    value: function setImageData(_ref3) {\n      var _this3 = this;\n\n      var _ref3$target = _ref3.target,\n          target = _ref3$target === undefined ? this.target : _ref3$target,\n          _ref3$pixels = _ref3.pixels,\n          pixels = _ref3$pixels === undefined ? null : _ref3$pixels,\n          _ref3$data = _ref3.data,\n          data = _ref3$data === undefined ? null : _ref3$data,\n          width = _ref3.width,\n          height = _ref3.height,\n          _ref3$level = _ref3.level,\n          level = _ref3$level === undefined ? 0 : _ref3$level,\n          _ref3$format = _ref3.format,\n          format = _ref3$format === undefined ? GL.RGBA : _ref3$format,\n          type = _ref3.type,\n          dataFormat = _ref3.dataFormat,\n          _ref3$offset = _ref3.offset,\n          offset = _ref3$offset === undefined ? 0 : _ref3$offset,\n          _ref3$border = _ref3.border,\n          border = _ref3$border === undefined ? 0 : _ref3$border,\n          _ref3$compressed = _ref3.compressed,\n          compressed = _ref3$compressed === undefined ? false : _ref3$compressed,\n          _ref3$parameters = _ref3.parameters,\n          parameters = _ref3$parameters === undefined ? {} : _ref3$parameters; // pixels variable is  for API compatibility purpose\n\n      if (!data) {\n        data = pixels;\n      }\n\n      var _deduceParameters3 = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: compressed,\n        data: data,\n        width: width,\n        height: height\n      });\n\n      type = _deduceParameters3.type;\n      dataFormat = _deduceParameters3.dataFormat;\n      compressed = _deduceParameters3.compressed;\n      width = _deduceParameters3.width;\n      height = _deduceParameters3.height;\n      var gl = this.gl;\n      gl.bindTexture(this.target, this.handle);\n      var dataType = null;\n\n      var _getDataType2 = this._getDataType({\n        data: data,\n        compressed: compressed\n      });\n\n      data = _getDataType2.data;\n      dataType = _getDataType2.dataType;\n      withParameters(this.gl, parameters, function () {\n        switch (dataType) {\n          case 'null':\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);\n            break;\n\n          case 'typed-array':\n            // Looks like this assert is not necessary, as offset is ignored under WebGL1\n            // assert((offset === 0 || isWebGL2(gl)), 'offset supported in WebGL2 only');\n            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data, offset);\n            break;\n\n          case 'buffer':\n            // WebGL2 enables creating textures directly from a WebGL buffer\n            assert(isWebGL2(gl), ERR_WEBGL2);\n            gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data.handle || data);\n            gl.texImage2D(target, level, format, width, height, border, format, type, offset);\n            break;\n\n          case 'browser-object':\n            gl.texImage2D(target, level, format, format, type, data);\n            break;\n\n          case 'compressed':\n            gl.compressedTexImage2D(_this3.target, level, format, width, height, border, data);\n            break;\n\n          default:\n            assert(false, 'Unknown image data type');\n        }\n      });\n    }\n    /* eslint-enable max-len, max-statements, complexity */\n\n    /**\n     * Redefines an area of an existing texture\n     * Note: does not allocate storage\n     */\n\n    /*\n     * Redefines an area of an existing texture\n     * @param {*} pixels, data -\n     *  null - create empty texture of specified format\n     *  Typed array - init from image data in typed array\n     *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer\n     *  HTMLImageElement|Image - Inits with content of image. Auto width/height\n     *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height\n     *  HTMLVideoElement - Creates video texture. Auto width/height\n     *\n     * @param {GLint} x - xOffset from where texture to be updated\n     * @param {GLint} y - yOffset from where texture to be updated\n     * @param {GLint} width - width of the sub image to be updated\n     * @param {GLint} height - height of the sub image to be updated\n     * @param {GLint} level - mip level to be updated\n     * @param {GLenum} format - internal format of image data.\n     * @param {GLenum} type\n     *  - format of array (autodetect from type) or\n     *  - (WEBGL2) format of buffer or ArrayBufferView\n     * @param {GLenum} dataFormat - format of image data.\n     * @param {Number} offset - (WEBGL2) offset from start of buffer\n     * @param {GLint} border - must be 0.\n     * @parameters - temporary settings to be applied, can be used to supply pixel store settings.\n     */\n\n  }, {\n    key: 'setSubImageData',\n    value: function setSubImageData(_ref4) {\n      var _this4 = this;\n\n      var _ref4$target = _ref4.target,\n          target = _ref4$target === undefined ? this.target : _ref4$target,\n          _ref4$pixels = _ref4.pixels,\n          pixels = _ref4$pixels === undefined ? null : _ref4$pixels,\n          _ref4$data = _ref4.data,\n          data = _ref4$data === undefined ? null : _ref4$data,\n          _ref4$x = _ref4.x,\n          x = _ref4$x === undefined ? 0 : _ref4$x,\n          _ref4$y = _ref4.y,\n          y = _ref4$y === undefined ? 0 : _ref4$y,\n          width = _ref4.width,\n          height = _ref4.height,\n          _ref4$level = _ref4.level,\n          level = _ref4$level === undefined ? 0 : _ref4$level,\n          _ref4$format = _ref4.format,\n          format = _ref4$format === undefined ? GL.RGBA : _ref4$format,\n          type = _ref4.type,\n          dataFormat = _ref4.dataFormat,\n          _ref4$compressed = _ref4.compressed,\n          compressed = _ref4$compressed === undefined ? false : _ref4$compressed,\n          _ref4$offset = _ref4.offset,\n          offset = _ref4$offset === undefined ? 0 : _ref4$offset,\n          _ref4$border = _ref4.border,\n          border = _ref4$border === undefined ? 0 : _ref4$border,\n          _ref4$parameters = _ref4.parameters,\n          parameters = _ref4$parameters === undefined ? {} : _ref4$parameters; // pixels variable is  for API compatibility purpose\n\n      var _deduceParameters4 = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat,\n        compressed: compressed,\n        data: data,\n        width: width,\n        height: height\n      });\n\n      type = _deduceParameters4.type;\n      dataFormat = _deduceParameters4.dataFormat;\n      compressed = _deduceParameters4.compressed;\n      width = _deduceParameters4.width;\n      height = _deduceParameters4.height;\n\n      if (!data) {\n        data = pixels;\n      } // Support ndarrays\n\n\n      if (data && data.data) {\n        var ndarray = data;\n        data = ndarray.data;\n        width = ndarray.shape[0];\n        height = ndarray.shape[1];\n      } // Support buffers\n\n\n      if (data instanceof Buffer) {\n        data = data.handle;\n      }\n\n      this.gl.bindTexture(this.target, this.handle);\n      withParameters(this.gl, parameters, function () {\n        // TODO - x,y parameters\n        if (compressed) {\n          _this4.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);\n        } else if (data === null) {\n          _this4.gl.texSubImage2D(target, level, format, width, height, border, dataFormat, type, null);\n        } else if (ArrayBuffer.isView(data)) {\n          _this4.gl.texSubImage2D(target, level, x, y, width, height, format, type, data, offset);\n        } else if (data instanceof WebGLBuffer) {\n          // WebGL2 allows us to create texture directly from a WebGL buffer\n          assert(isWebGL2(_this4.gl), ERR_WEBGL2); // This texImage2D signature uses currently bound GL_PIXEL_UNPACK_BUFFER\n\n          _this4.gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, data);\n\n          _this4.gl.texSubImage2D(target, level, format, width, height, border, format, type, offset);\n\n          _this4.gl.bindBuffer(GL.GL_PIXEL_UNPACK_BUFFER, null);\n        } else {\n          // Assume data is a browser supported object (ImageData, Canvas, ...)\n          _this4.gl.texSubImage2D(target, level, x, y, format, type, data);\n        }\n      });\n      this.gl.bindTexture(this.target, null);\n    }\n    /* eslint-enable max-len, max-statements, complexity */\n\n    /**\n     * Defines a two-dimensional texture image or cube-map texture image with\n     * pixels from the current framebuffer (rather than from client memory).\n     * (gl.copyTexImage2D wrapper)\n     *\n     * Note that binding a texture into a Framebuffer's color buffer and\n     * rendering can be faster.\n     */\n\n  }, {\n    key: 'copyFramebuffer',\n    value: function copyFramebuffer(_ref5) {\n      var _ref5$target = _ref5.target,\n          target = _ref5$target === undefined ? this.target : _ref5$target,\n          framebuffer = _ref5.framebuffer,\n          _ref5$offset = _ref5.offset,\n          offset = _ref5$offset === undefined ? 0 : _ref5$offset,\n          _ref5$x = _ref5.x,\n          x = _ref5$x === undefined ? 0 : _ref5$x,\n          _ref5$y = _ref5.y,\n          y = _ref5$y === undefined ? 0 : _ref5$y,\n          width = _ref5.width,\n          height = _ref5.height,\n          _ref5$level = _ref5.level,\n          level = _ref5$level === undefined ? 0 : _ref5$level,\n          _ref5$internalFormat = _ref5.internalFormat,\n          internalFormat = _ref5$internalFormat === undefined ? GL.RGBA : _ref5$internalFormat,\n          _ref5$border = _ref5.border,\n          border = _ref5$border === undefined ? 0 : _ref5$border;\n\n      if (framebuffer) {\n        framebuffer.bind();\n      } // target\n\n\n      this.bind();\n      this.gl.copyTexImage2D(this.target, level, internalFormat, x, y, width, height, border);\n      this.unbind();\n\n      if (framebuffer) {\n        framebuffer.unbind();\n      }\n    }\n  }, {\n    key: 'getActiveUnit',\n    value: function getActiveUnit() {\n      return this.gl.getParameter(GL.ACTIVE_TEXTURE) - GL.TEXTURE0;\n    } // target cannot be modified by bind:\n    // textures are special because when you first bind them to a target,\n    // they get special information. When you first bind a texture as a\n    // GL_TEXTURE_2D, you are actually setting special state in the texture.\n    // You are saying that this texture is a 2D texture.\n    // And it will always be a 2D texture; this state cannot be changed ever.\n    // If you have a texture that was first bound as a GL_TEXTURE_2D,\n    // you must always bind it as a GL_TEXTURE_2D;\n    // attempting to bind it as GL_TEXTURE_1D will give rise to an error\n    // (while run-time).\n\n  }, {\n    key: 'bind',\n    value: function bind() {\n      var textureUnit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.textureUnit;\n\n      if (textureUnit === undefined) {\n        throw new Error('Texture.bind: must specify texture unit');\n      }\n\n      this.textureUnit = textureUnit;\n      this.gl.activeTexture(GL.TEXTURE0 + textureUnit);\n      this.gl.bindTexture(this.target, this.handle);\n      return textureUnit;\n    }\n  }, {\n    key: 'unbind',\n    value: function unbind() {\n      if (this.textureUnit === undefined) {\n        throw new Error('Texture.unbind: texture unit not specified');\n      }\n\n      this.gl.activeTexture(GL.TEXTURE0 + this.textureUnit);\n      this.gl.bindTexture(this.target, null);\n      return this.textureUnit;\n    } // PRIVATE METHODS\n\n  }, {\n    key: '_getDataType',\n    value: function _getDataType(_ref6) {\n      var data = _ref6.data,\n          _ref6$compressed = _ref6.compressed,\n          compressed = _ref6$compressed === undefined ? false : _ref6$compressed;\n\n      if (compressed) {\n        return {\n          data: data,\n          dataType: 'compressed'\n        };\n      }\n\n      if (data === null) {\n        return {\n          data: data,\n          dataType: 'null'\n        };\n      }\n\n      if (ArrayBuffer.isView(data)) {\n        return {\n          data: data,\n          dataType: 'typed-array'\n        };\n      }\n\n      if (data instanceof Buffer) {\n        return {\n          data: data.handle,\n          dataType: 'buffer'\n        };\n      }\n\n      if (data instanceof WebGLBuffer) {\n        return {\n          data: data,\n          dataType: 'buffer'\n        };\n      } // Assume data is a browser supported object (ImageData, Canvas, ...)\n\n\n      return {\n        data: data,\n        dataType: 'browser-object'\n      };\n    } // Image 3D copies from Typed Array or WebGLBuffer\n\n  }, {\n    key: 'setImage3D',\n    value: function setImage3D(_ref7) {\n      var _ref7$level = _ref7.level,\n          level = _ref7$level === undefined ? 0 : _ref7$level,\n          _ref7$internalformat = _ref7.internalformat,\n          internalformat = _ref7$internalformat === undefined ? GL.RGBA : _ref7$internalformat,\n          width = _ref7.width,\n          height = _ref7.height,\n          _ref7$depth = _ref7.depth,\n          depth = _ref7$depth === undefined ? 1 : _ref7$depth,\n          _ref7$border = _ref7.border,\n          border = _ref7$border === undefined ? 0 : _ref7$border,\n          format = _ref7.format,\n          _ref7$type = _ref7.type,\n          type = _ref7$type === undefined ? GL.UNSIGNED_BYTE : _ref7$type,\n          _ref7$offset = _ref7.offset,\n          offset = _ref7$offset === undefined ? 0 : _ref7$offset,\n          pixels = _ref7.pixels;\n\n      if (ArrayBuffer.isView(pixels)) {\n        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, pixels);\n        return this;\n      }\n\n      if (pixels instanceof Buffer) {\n        this.gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, pixels.handle);\n        this.gl.texImage3D(this.target, level, internalformat, width, height, depth, border, format, type, offset);\n      }\n\n      return this;\n    }\n    /* Copied from texture-2d.js\n    // WebGL2\n    setPixels(opts = {}) {\n      const {\n        buffer,\n        width = null,\n        height = null,\n        mipmapLevel = 0,\n        format = GL.RGBA,\n        type = GL.UNSIGNED_BYTE,\n        border = 0\n      } = opts;\n       const {gl} = this;\n       // This signature of texImage2D uses currently bound GL_PIXEL_UNPACK_BUFFER\n      gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, buffer.target);\n      // And as always, we must also bind the texture itself\n      this.bind();\n       gl.texImage2D(gl.TEXTURE_2D,\n        mipmapLevel, format, width, height, border, format, type, buffer.target);\n       this.unbind();\n      gl.bindBuffer(GL.GL_PIXEL_UNPACK_BUFFER, null);\n      return this;\n    }\n     setImageDataFromCompressedBuffer(opts) {\n      const {\n        buffer,\n        // offset = 0,\n        width = null,\n        height = null,\n        mipmapLevel = 0,\n        internalFormat = GL.RGBA,\n        // format = GL.RGBA,\n        // type = GL.UNSIGNED_BYTE,\n        border = 0\n      } = opts;\n       const {gl} = this;\n      gl.compressedTexImage2D(this.target,\n        mipmapLevel, internalFormat, width, height, border, buffer);\n      // gl.compressedTexSubImage2D(target,\n      //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);\n      return this;\n    }\n     copySubImage(opts) {\n      const {\n        // pixels,\n        // offset = 0,\n        // x,\n        // y,\n        // width,\n        // height,\n        // mipmapLevel = 0,\n        // internalFormat = GL.RGBA,\n        // type = GL.UNSIGNED_BYTE,\n        // border = 0\n      } = opts;\n       // if (pixels instanceof ArrayBufferView) {\n      //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);\n      // }\n      // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);\n      // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);\n      // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);\n      // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);\n      // // Additional signature in a WebGL 2 context:\n      // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);\n    }\n    */\n    // HELPER METHODS\n\n  }, {\n    key: '_deduceParameters',\n    value: function _deduceParameters(opts) {\n      var format = opts.format,\n          data = opts.data;\n      var width = opts.width,\n          height = opts.height,\n          dataFormat = opts.dataFormat,\n          type = opts.type,\n          compressed = opts.compressed; // Deduce format and type from format\n\n      var textureFormat = TEXTURE_FORMATS[format];\n      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;\n      type = type || textureFormat && textureFormat.types[0]; // Deduce compression from format\n\n      compressed = compressed || textureFormat && textureFormat.compressed;\n\n      var _deduceImageSize2 = this._deduceImageSize({\n        data: data,\n        width: width,\n        height: height\n      });\n\n      width = _deduceImageSize2.width;\n      height = _deduceImageSize2.height;\n      return {\n        dataFormat: dataFormat,\n        type: type,\n        compressed: compressed,\n        width: width,\n        height: height,\n        format: format,\n        data: data\n      };\n    } // Convert and append any v3 style parameters\n\n  }, {\n    key: '_applyV3Options',\n    value: function _applyV3Options(parameters, opts) {\n      var v4Parameters = Object.assign({}, parameters);\n\n      if ('magFilter' in opts) {\n        v4Parameters[GL.TEXTURE_MAG_FILTER] = opts.magFilter;\n        log.deprecated('magFilter', 'TEXTURE_MAG_FILTER');\n      }\n\n      if ('minFilter' in opts) {\n        v4Parameters[GL.TEXTURE_MIN_FILTER] = opts.minFilter;\n        log.deprecated('minFilter', 'TEXTURE_MIN_FILTER');\n      }\n\n      if ('wrapS' in opts) {\n        v4Parameters[GL.TEXTURE_WRAP_S] = opts.wrapS;\n        log.deprecated('wrapS', 'TEXTURE_WRAP_S');\n      }\n\n      if ('wrapT' in opts) {\n        v4Parameters[GL.TEXTURE_WRAP_T] = opts.wrapT;\n        log.deprecated('wrapT', 'TEXTURE_WRAP_T');\n      }\n\n      return v4Parameters;\n    }\n    /* global ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement */\n\n  }, {\n    key: '_deduceImageSize',\n    value: function _deduceImageSize(_ref8) {\n      var data = _ref8.data,\n          width = _ref8.width,\n          height = _ref8.height;\n      var size = void 0;\n\n      if (typeof ImageData !== 'undefined' && data instanceof ImageData) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {\n        size = {\n          width: data.naturalWidth,\n          height: data.naturalHeight\n        };\n      } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {\n        size = {\n          width: data.width,\n          height: data.height\n        };\n      } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {\n        size = {\n          width: data.videoWidth,\n          height: data.videoHeight\n        };\n      } else if (!data) {\n        size = {\n          width: width >= 0 ? width : 1,\n          height: height >= 0 ? height : 1\n        };\n      } else {\n        size = {\n          width: width,\n          height: height\n        };\n      }\n\n      assert(size, 'Could not deduced texture size');\n      assert(width === undefined || size.width === width, 'Deduced texture width does not match supplied width');\n      assert(height === undefined || size.height === height, 'Deduced texture height does not match supplied height');\n      return size;\n    } // RESOURCE METHODS\n\n  }, {\n    key: '_createHandle',\n    value: function _createHandle() {\n      return this.gl.createTexture();\n    }\n  }, {\n    key: '_deleteHandle',\n    value: function _deleteHandle() {\n      this.gl.deleteTexture(this.handle);\n    }\n  }, {\n    key: '_getParameter',\n    value: function _getParameter(pname) {\n      switch (pname) {\n        case GL.TEXTURE_WIDTH:\n          return this.width;\n\n        case GL.TEXTURE_HEIGHT:\n          return this.height;\n\n        default:\n          this.gl.bindTexture(this.target, this.handle);\n          var value = this.gl.getTexParameter(this.target, pname);\n          this.gl.bindTexture(this.target, null);\n          return value;\n      }\n    }\n  }, {\n    key: '_setParameter',\n    value: function _setParameter(pname, param) {\n      this.gl.bindTexture(this.target, this.handle); // NOTE: Apply NPOT workaround\n\n      param = this._getNPOTParam(pname, param); // Apparently there are some integer/float conversion rules that made\n      // the WebGL committe expose two parameter setting functions in JavaScript.\n      // For now, pick the float version for parameters specified as GLfloat.\n\n      switch (pname) {\n        case GL.TEXTURE_MIN_LOD:\n        case GL.TEXTURE_MAX_LOD:\n          this.gl.texParameterf(this.handle, pname, param);\n          break;\n\n        case GL.TEXTURE_WIDTH:\n        case GL.TEXTURE_HEIGHT:\n          throw new Error('Cannot set emulated parameter');\n\n        default:\n          this.gl.texParameteri(this.target, pname, param);\n          break;\n      }\n\n      this.gl.bindTexture(this.target, null);\n      return this;\n    }\n  }, {\n    key: '_isNPOT',\n    value: function _isNPOT() {\n      return !isWebGL2(this.gl) && (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height));\n    } // Update default settings which are not supported by NPOT textures.\n\n  }, {\n    key: '_updateForNPOT',\n    value: function _updateForNPOT(parameters) {\n      if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {\n        log.warn(0, 'texture: ' + this + ' is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR');\n        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;\n      }\n\n      if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {\n        log.warn(0, 'texture: ' + this + ' is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE');\n        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;\n      }\n\n      if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {\n        log.warn(0, 'texture: ' + this + ' is Non-Power-Of-Two, forcing TEXTURE_WRAP_T to CLAMP_TO_EDGE');\n        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;\n      }\n    }\n  }, {\n    key: '_getNPOTParam',\n    value: function _getNPOTParam(pname, param) {\n      if (this._isNPOT()) {\n        switch (pname) {\n          case GL.TEXTURE_MIN_FILTER:\n            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {\n              log.warn(0, 'texture: ' + this + ' is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR');\n              param = GL.LINEAR;\n            }\n\n            break;\n\n          case GL.TEXTURE_WRAP_S:\n          case GL.TEXTURE_WRAP_T:\n            if (param !== GL.CLAMP_TO_EDGE) {\n              log.warn(0, 'texture: ' + this + ' is Non-Power-Of-Two, ' + glKey(pname) + ' to CLAMP_TO_EDGE');\n              param = GL.CLAMP_TO_EDGE;\n            }\n\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return param;\n    }\n  }]);\n\n  return Texture;\n}(Resource);\n\nexport default Texture;","map":null,"metadata":{},"sourceType":"module"}