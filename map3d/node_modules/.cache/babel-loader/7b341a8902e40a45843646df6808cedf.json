{"ast":null,"code":"// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nexport default \"const float TILE_SIZE = 512.0;\\nconst float PI = 3.1415926536;\\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\\n\\n// ref: lib/constants.js\\nconst float PROJECT_IDENTITY = 0.;\\nconst float PROJECT_MERCATOR = 1.;\\nconst float PROJECT_MERCATOR_OFFSETS = 2.;\\n\\nuniform float projectionMode;\\nuniform float projectionScale;\\nuniform vec4 projectionCenter;\\nuniform vec3 projectionPixelsPerUnit;\\n\\nuniform mat4 modelMatrix;\\nuniform mat4 projectionMatrix;\\n\\n//\\n// Scaling offsets\\n//\\n\\n// the scalar version of project_scale is for scaling the z component only\\nfloat project_scale(float meters) {\\n  return meters * projectionPixelsPerUnit.z;\\n}\\n\\nvec2 project_scale(vec2 meters) {\\n  return meters * projectionPixelsPerUnit.xy;\\n}\\n\\nvec3 project_scale(vec3 meters) {\\n  return vec3(\\n    project_scale(meters.xy),\\n    project_scale(meters.z)\\n  );\\n}\\n\\nvec4 project_scale(vec4 meters) {\\n  return vec4(\\n    project_scale(meters.xyz),\\n    meters.w\\n  );\\n}\\n\\n//\\n// Projecting positions\\n//\\n\\n// non-linear projection: lnglats => unit tile [0-1, 0-1]\\nvec2 project_mercator_(vec2 lnglat) {\\n  return vec2(\\n    radians(lnglat.x) + PI,\\n    PI - log(tan_fp32(PI * 0.25 + radians(lnglat.y) * 0.5))\\n  );\\n}\\n\\nvec4 project_position(vec4 position) {\\n\\n  if (projectionMode == PROJECT_MERCATOR) {\\n    return vec4(\\n      project_mercator_(position.xy) * WORLD_SCALE * projectionScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n\\n  // Apply model matrix\\n  vec4 position_modelspace = modelMatrix * position;\\n  return project_scale(position_modelspace);\\n}\\n\\nvec3 project_position(vec3 position) {\\n  vec4 projected_position = project_position(vec4(position, 1.0));\\n  return projected_position.xyz;\\n}\\n\\nvec2 project_position(vec2 position) {\\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0));\\n  return projected_position.xy;\\n}\\n\\nvec4 project_to_clipspace(vec4 position) {\\n  if (projectionMode == PROJECT_MERCATOR_OFFSETS) {\\n    position.w *= projectionPixelsPerUnit.z;\\n  }\\n  return projectionMatrix * position + projectionCenter;\\n}\\n\\n// Backwards compatibility\\n\\nfloat scale(float position) {\\n  return project_scale(position);\\n}\\n\\nvec2 scale(vec2 position) {\\n  return project_scale(position);\\n}\\n\\nvec3 scale(vec3 position) {\\n  return project_scale(position);\\n}\\n\\nvec4 scale(vec4 position) {\\n  return project_scale(position);\\n}\\n\\nvec2 preproject(vec2 position) {\\n  return project_position(position);\\n}\\n\\nvec3 preproject(vec3 position) {\\n  return project_position(position);\\n}\\n\\nvec4 preproject(vec4 position) {\\n  return project_position(position);\\n}\\n\\nvec4 project(vec4 position) {\\n  return project_to_clipspace(position);\\n}\\n\";","map":null,"metadata":{},"sourceType":"module"}