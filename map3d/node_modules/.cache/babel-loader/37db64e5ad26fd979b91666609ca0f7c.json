{"ast":null,"code":"import * as MarchingSquares from './marching-squares';\nimport assert from 'assert'; // Given all the cell weights, generates contours for each threshold.\n\nexport function generateContours(_ref) {\n  var thresholds = _ref.thresholds,\n      colors = _ref.colors,\n      cellWeights = _ref.cellWeights,\n      gridSize = _ref.gridSize,\n      gridOrigin = _ref.gridOrigin,\n      cellSize = _ref.cellSize;\n  var contourSegments = [];\n  var width = gridSize[0];\n  var height = gridSize[1];\n  thresholds.forEach(function (threshold, index) {\n    for (var x = -1; x < width; x++) {\n      for (var y = -1; y < height; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        var code = MarchingSquares.getCode({\n          cellWeights: cellWeights,\n          thresholdValue: threshold,\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        }); // Get the intersection vertices based on MarchingSquares code.\n\n        var vertices = MarchingSquares.getVertices({\n          gridOrigin: gridOrigin,\n          cellSize: cellSize,\n          x: x,\n          y: y,\n          width: width,\n          height: height,\n          code: code\n        }); // We should always get even number of vertices\n\n        assert(vertices.length % 2 === 0);\n\n        for (var i = 0; i < vertices.length; i += 2) {\n          contourSegments.push({\n            start: vertices[i],\n            end: vertices[i + 1],\n            threshold: threshold\n          });\n        }\n      }\n    }\n  });\n  return contourSegments;\n}","map":null,"metadata":{},"sourceType":"module"}