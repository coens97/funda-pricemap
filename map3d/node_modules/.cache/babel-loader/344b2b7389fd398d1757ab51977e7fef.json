{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// View and Projection Matrix calculations for mapbox-js style\n// map view properties\n\n\nimport Viewport from './viewport';\nimport { projectFlat, unprojectFlat, getProjectionMatrix, getUncenteredViewMatrix, fitBounds as _fitBounds } from 'viewport-mercator-project'; // TODO - import from viewport-mercator-project\n// import {fitBounds} from '../viewport-mercator-project/fit-bounds';\n// TODO - import from math.gl\n\n/* eslint-disable camelcase */\n\nimport vec2_add from 'gl-vec2/add';\nimport vec2_negate from 'gl-vec2/negate';\nimport assert from 'assert';\nvar ERR_ARGUMENT = 'Illegal argument to WebMercatorViewport';\n\nvar WebMercatorViewport = function (_Viewport) {\n  _inherits(WebMercatorViewport, _Viewport);\n  /**\n   * @classdesc\n   * Creates view/projection matrices from mercator params\n   * Note: The Viewport is immutable in the sense that it only has accessors.\n   * A new viewport instance should be created if any parameters have changed.\n   */\n\n  /* eslint-disable complexity, max-statements */\n\n\n  function WebMercatorViewport() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, WebMercatorViewport);\n\n    var _opts$latitude = opts.latitude,\n        latitude = _opts$latitude === undefined ? 0 : _opts$latitude,\n        _opts$longitude = opts.longitude,\n        longitude = _opts$longitude === undefined ? 0 : _opts$longitude,\n        _opts$zoom = opts.zoom,\n        zoom = _opts$zoom === undefined ? 11 : _opts$zoom,\n        _opts$pitch = opts.pitch,\n        pitch = _opts$pitch === undefined ? 0 : _opts$pitch,\n        _opts$bearing = opts.bearing,\n        bearing = _opts$bearing === undefined ? 0 : _opts$bearing,\n        _opts$farZMultiplier = opts.farZMultiplier,\n        farZMultiplier = _opts$farZMultiplier === undefined ? 10 : _opts$farZMultiplier;\n    var width = opts.width,\n        height = opts.height,\n        _opts$altitude = opts.altitude,\n        altitude = _opts$altitude === undefined ? 1.5 : _opts$altitude; // Silently allow apps to send in 0,0 to facilitate isomorphic render etc\n\n    width = width || 1;\n    height = height || 1; // Altitude - prevent division by 0\n    // TODO - just throw an Error instead?\n\n    altitude = Math.max(0.75, altitude);\n    var projectionMatrix = getProjectionMatrix({\n      width: width,\n      height: height,\n      pitch: pitch,\n      altitude: altitude,\n      farZMultiplier: farZMultiplier\n    }); // The uncentered matrix allows us two move the center addition to the\n    // shader (cheap) which gives a coordinate system that has its center in\n    // the layer's center position. This makes rotations and other modelMatrx\n    // transforms much more useful.\n\n    var viewMatrixUncentered = getUncenteredViewMatrix({\n      height: height,\n      pitch: pitch,\n      bearing: bearing,\n      altitude: altitude\n    }); // Save parameters\n\n    var _this = _possibleConstructorReturn(this, (WebMercatorViewport.__proto__ || Object.getPrototypeOf(WebMercatorViewport)).call(this, Object.assign({}, opts, {\n      // x, y, position, ...\n      // TODO / hack - prevent vertical offsets if not FirstPersonViewport\n      position: opts.position && [opts.position[0], opts.position[1], 0],\n      width: width,\n      height: height,\n      viewMatrix: viewMatrixUncentered,\n      longitude: longitude,\n      latitude: latitude,\n      zoom: zoom,\n      projectionMatrix: projectionMatrix,\n      focalDistance: 1 // Viewport is already carefully set up to \"focus\" on ground\n\n    })));\n\n    _this.latitude = latitude;\n    _this.longitude = longitude;\n    _this.zoom = zoom;\n    _this.pitch = pitch;\n    _this.bearing = bearing;\n    _this.altitude = altitude; // Bind methods\n\n    _this.metersToLngLatDelta = _this.metersToLngLatDelta.bind(_this);\n    _this.lngLatDeltaToMeters = _this.lngLatDeltaToMeters.bind(_this);\n    _this.addMetersToLngLat = _this.addMetersToLngLat.bind(_this);\n    Object.freeze(_this);\n    return _this;\n  }\n  /* eslint-enable complexity, max-statements */\n\n  /**\n   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.\n   * Performs the nonlinear part of the web mercator projection.\n   * Remaining projection is done with 4x4 matrices which also handles\n   * perspective.\n   *\n   * @param {Array} lngLat - [lng, lat] coordinates\n   *   Specifies a point on the sphere to project onto the map.\n   * @return {Array} [x,y] coordinates.\n   */\n\n\n  _createClass(WebMercatorViewport, [{\n    key: '_projectFlat',\n    value: function _projectFlat(lngLat) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return projectFlat(lngLat, scale);\n    }\n    /**\n     * Unproject world point [x,y] on map onto {lat, lon} on sphere\n     *\n     * @param {object|Vector} xy - object with {x,y} members\n     *  representing point on projected map plane\n     * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.\n     *   Has toArray method if you need a GeoJSON Array.\n     *   Per cartographic tradition, lat and lon are specified as degrees.\n     */\n\n  }, {\n    key: '_unprojectFlat',\n    value: function _unprojectFlat(xy) {\n      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.scale;\n      return unprojectFlat(xy, scale);\n    }\n    /**\n     * Converts a meter offset to a lnglat offset\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n     * @return {[Number,Number]|[Number,Number,Number]) - array of [lng,lat,z] deltas\n     */\n\n  }, {\n    key: 'metersToLngLatDelta',\n    value: function metersToLngLatDelta(xyz) {\n      var _xyz = _slicedToArray(xyz, 3),\n          x = _xyz[0],\n          y = _xyz[1],\n          _xyz$ = _xyz[2],\n          z = _xyz$ === undefined ? 0 : _xyz$;\n\n      assert(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z), ERR_ARGUMENT);\n      var _distanceScales = this.distanceScales,\n          pixelsPerMeter = _distanceScales.pixelsPerMeter,\n          degreesPerPixel = _distanceScales.degreesPerPixel;\n      var deltaLng = x * pixelsPerMeter[0] * degreesPerPixel[0];\n      var deltaLat = y * pixelsPerMeter[1] * degreesPerPixel[1];\n      return xyz.length === 2 ? [deltaLng, deltaLat] : [deltaLng, deltaLat, z];\n    }\n    /**\n     * Converts a lnglat offset to a meter offset\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) deltaLngLatZ - array of [lng,lat,z] deltas\n     * @return {[Number,Number]|[Number,Number,Number]) - array of meter deltas\n     */\n\n  }, {\n    key: 'lngLatDeltaToMeters',\n    value: function lngLatDeltaToMeters(deltaLngLatZ) {\n      var _deltaLngLatZ = _slicedToArray(deltaLngLatZ, 3),\n          deltaLng = _deltaLngLatZ[0],\n          deltaLat = _deltaLngLatZ[1],\n          _deltaLngLatZ$ = _deltaLngLatZ[2],\n          deltaZ = _deltaLngLatZ$ === undefined ? 0 : _deltaLngLatZ$;\n\n      assert(Number.isFinite(deltaLng) && Number.isFinite(deltaLat) && Number.isFinite(deltaZ), ERR_ARGUMENT);\n      var _distanceScales2 = this.distanceScales,\n          pixelsPerDegree = _distanceScales2.pixelsPerDegree,\n          metersPerPixel = _distanceScales2.metersPerPixel;\n      var deltaX = deltaLng * pixelsPerDegree[0] * metersPerPixel[0];\n      var deltaY = deltaLat * pixelsPerDegree[1] * metersPerPixel[1];\n      return deltaLngLatZ.length === 2 ? [deltaX, deltaY] : [deltaX, deltaY, deltaZ];\n    }\n    /**\n     * Add a meter delta to a base lnglat coordinate, returning a new lnglat array\n     *\n     * Note: Uses simple linear approximation around the viewport center\n     * Error increases with size of offset (roughly 1% per 100km)\n     *\n     * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate\n     * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas\n     * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas\n     */\n\n  }, {\n    key: 'addMetersToLngLat',\n    value: function addMetersToLngLat(lngLatZ, xyz) {\n      var _lngLatZ = _slicedToArray(lngLatZ, 3),\n          lng = _lngLatZ[0],\n          lat = _lngLatZ[1],\n          _lngLatZ$ = _lngLatZ[2],\n          Z = _lngLatZ$ === undefined ? 0 : _lngLatZ$;\n\n      var _metersToLngLatDelta = this.metersToLngLatDelta(xyz),\n          _metersToLngLatDelta2 = _slicedToArray(_metersToLngLatDelta, 3),\n          deltaLng = _metersToLngLatDelta2[0],\n          deltaLat = _metersToLngLatDelta2[1],\n          _metersToLngLatDelta3 = _metersToLngLatDelta2[2],\n          deltaZ = _metersToLngLatDelta3 === undefined ? 0 : _metersToLngLatDelta3;\n\n      return lngLatZ.length === 2 ? [lng + deltaLng, lat + deltaLat] : [lng + deltaLng, lat + deltaLat, Z + deltaZ];\n    }\n    /**\n     * Get the map center that place a given [lng, lat] coordinate at screen\n     * point [x, y]\n     *\n     * @param {Array} lngLat - [lng,lat] coordinates\n     *   Specifies a point on the sphere.\n     * @param {Array} pos - [x,y] coordinates\n     *   Specifies a point on the screen.\n     * @return {Array} [lng,lat] new map center.\n     */\n\n  }, {\n    key: 'getLocationAtPoint',\n    value: function getLocationAtPoint(_ref) {\n      var lngLat = _ref.lngLat,\n          pos = _ref.pos;\n      var fromLocation = this.projectFlat(this.unproject(pos));\n      var toLocation = this.projectFlat(lngLat);\n      var center = this.projectFlat([this.longitude, this.latitude]);\n      var translate = vec2_add([], toLocation, vec2_negate([], fromLocation));\n      var newCenter = vec2_add([], center, translate);\n      return this.unprojectFlat(newCenter);\n    }\n    /**\n     * Returns a new viewport that fit around the given rectangle.\n     * Only supports non-perspective mode.\n     * @param {Array} bounds - [[lon, lat], [lon, lat]]\n     * @param {Number} [options.padding] - The amount of padding in pixels to add to the given bounds.\n     * @param {Array} [options.offset] - The center of the given bounds relative to the map's center,\n     *    [x, y] measured in pixels.\n     * @returns {WebMercatorViewport}\n     */\n\n  }, {\n    key: 'fitBounds',\n    value: function fitBounds(bounds) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var width = this.width,\n          height = this.height;\n\n      var _fitBounds2 = _fitBounds(Object.assign({\n        width: width,\n        height: height,\n        bounds: bounds\n      }, options)),\n          longitude = _fitBounds2.longitude,\n          latitude = _fitBounds2.latitude,\n          zoom = _fitBounds2.zoom;\n\n      return new WebMercatorViewport({\n        width: width,\n        height: height,\n        longitude: longitude,\n        latitude: latitude,\n        zoom: zoom\n      });\n    } // TODO - should support user supplied constraints\n\n  }, {\n    key: 'isMapSynched',\n    value: function isMapSynched() {\n      var EPSILON = 0.000001;\n      var MAPBOX_LIMITS = {\n        pitch: 60,\n        zoom: 40\n      };\n      var pitch = this.pitch,\n          zoom = this.zoom;\n      return pitch <= MAPBOX_LIMITS.pitch + EPSILON && zoom <= MAPBOX_LIMITS.zoom + EPSILON;\n    }\n  }]);\n\n  return WebMercatorViewport;\n}(Viewport);\n\nexport default WebMercatorViewport;\nWebMercatorViewport.displayName = 'WebMercatorViewport';","map":null,"metadata":{},"sourceType":"module"}