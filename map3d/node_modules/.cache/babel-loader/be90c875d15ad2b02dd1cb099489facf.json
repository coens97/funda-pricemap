{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport Object3D from './object-3d';\nimport { Matrix4 } from 'math.gl';\nimport assert from '../utils/assert';\n\nvar Group =\n/*#__PURE__*/\nfunction (_Object3D) {\n  _inherits(Group, _Object3D);\n\n  function Group() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Group);\n\n    var _opts$children = opts.children,\n        children = _opts$children === void 0 ? [] : _opts$children;\n    children.every(function (child) {\n      return assert(_instanceof(child, Object3D));\n    });\n    _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, opts));\n    _this.children = children;\n    return _this;\n  } // Unpacks arrays and nested arrays of children\n\n\n  _createClass(Group, [{\n    key: \"add\",\n    value: function add() {\n      for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n        children[_key] = arguments[_key];\n      }\n\n      for (var _i = 0; _i < children.length; _i++) {\n        var child = children[_i];\n\n        if (Array.isArray(child)) {\n          this.add.apply(this, _toConsumableArray(child));\n        } else {\n          this.children.push(child);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(child) {\n      var children = this.children;\n      var indexOf = children.indexOf(child);\n\n      if (indexOf > -1) {\n        children.splice(indexOf, 1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeAll\",\n    value: function removeAll() {\n      this.children = [];\n      return this;\n    } // If visitor returns a truthy value, traversal will be aborted and that value\n    // will be returned from `traverse`. Otherwise `traverse` will return null.\n\n  }, {\n    key: \"traverse\",\n    value: function traverse(visitor) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$modelMatrix = _ref.modelMatrix,\n          modelMatrix = _ref$modelMatrix === void 0 ? new Matrix4() : _ref$modelMatrix;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var child = _step.value;\n          var matrix = child.matrix;\n          modelMatrix = modelMatrix.multiplyRight(matrix);\n          var result = void 0;\n\n          if (_instanceof(child, Group)) {\n            result = child.traverse(visitor, {\n              modelMatrix: modelMatrix\n            });\n          } else {\n            // child.setUniforms({modelMatrix});\n            result = visitor(child, {});\n          } // Abort if a result was returned\n\n\n          if (result) {\n            return result;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    } // If visitor returns a truthy value, traversal will be aborted and that value\n    // will be returned from `traverseReverse`. Otherwise `traverseReverse` will return null.\n\n  }, {\n    key: \"traverseReverse\",\n    value: function traverseReverse(visitor) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$modelMatrix = _ref2.modelMatrix,\n          modelMatrix = _ref2$modelMatrix === void 0 ? new Matrix4() : _ref2$modelMatrix;\n\n      for (var i = this.children.length - 1; i >= 0; --i) {\n        var child = this.children[i];\n        var matrix = child.matrix;\n        modelMatrix = modelMatrix.multiplyRight(matrix);\n        var result = void 0;\n\n        if (_instanceof(child, Group)) {\n          result = child.traverseReverse(visitor, {\n            modelMatrix: modelMatrix\n          });\n        } else {\n          // child.setUniforms({modelMatrix});\n          result = visitor(child, {});\n        } // Abort if a result was returned\n\n\n        if (result) {\n          return result;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return Group;\n}(Object3D);\n\nexport { Group as default };","map":null,"metadata":{},"sourceType":"module"}