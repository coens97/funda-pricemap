{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport WheelInput from './wheel-input';\nimport MoveInput from './move-input';\nimport { isBrowser } from '../globals'; // Hammer.js directly references `document` and `window`,\n// which means that importing it in environments without\n// those objects throws errors. Therefore, instead of\n// directly `import`ing 'hammerjs' and './constants'\n// (which imports Hammer.js) we conditionally require it\n// depending on support for those globals, and provide mocks\n// for environments without `document`/`window`.\n\nfunction ManagerMock(m) {\n  var instance = {};\n\n  var chainedNoop = function chainedNoop() {\n    return instance;\n  };\n\n  instance.get = function () {\n    return null;\n  };\n\n  instance.on = chainedNoop;\n  instance.off = chainedNoop;\n  instance.destroy = chainedNoop;\n  instance.emit = chainedNoop;\n  return instance;\n}\n\nvar Manager = isBrowser ? require('hammerjs').Manager : ManagerMock;\n\nvar _ref = isBrowser ? require('./constants') : {\n  BASIC_EVENT_ALIASES: {},\n  EVENT_RECOGNIZER_MAP: {},\n  GESTURE_EVENT_ALIASES: {}\n},\n    BASIC_EVENT_ALIASES = _ref.BASIC_EVENT_ALIASES,\n    EVENT_RECOGNIZER_MAP = _ref.EVENT_RECOGNIZER_MAP,\n    RECOGNIZERS = _ref.RECOGNIZERS,\n    GESTURE_EVENT_ALIASES = _ref.GESTURE_EVENT_ALIASES;\n/**\n * Single API for subscribing to events about both\n * basic input events (e.g. 'mousemove', 'touchstart', 'wheel')\n * and gestural input (e.g. 'click', 'tap', 'panstart').\n * Delegates event registration and handling to Hammer.js.\n * @param {DOM Element} element         DOM element on which event handlers will be registered.\n * @param {Object} options              Options for instantiation\n * @param {Object} options.events       Map of {event name: handler} to register on init.\n * @param {Object} options.recognizers  Gesture recognizers from Hammer.js to register,\n *                                      as an Array in Hammer.Recognizer format.\n *                                      (http://hammerjs.github.io/api/#hammermanager)\n */\n\n\nvar EventManager = function () {\n  function EventManager(element) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, EventManager);\n\n    this.element = element;\n    this._onBasicInput = this._onBasicInput.bind(this);\n    this.manager = new Manager(element, {\n      recognizers: options.recognizers || RECOGNIZERS\n    }).on('hammer.input', this._onBasicInput);\n    this.eventHandlers = []; // Handle events not handled by Hammer.js:\n    // - mouse wheel\n    // - pointer/touch/mouse move\n\n    this._onOtherEvent = this._onOtherEvent.bind(this);\n    this.wheelInput = new WheelInput(element, this._onOtherEvent, {\n      enable: false\n    });\n    this.moveInput = new MoveInput(element, this._onOtherEvent, {\n      enable: false\n    }); // Register all passed events.\n\n    var events = options.events;\n\n    if (events) {\n      this.on(events);\n    }\n  }\n  /**\n   * Tear down internal event management implementations.\n   */\n\n\n  _createClass(EventManager, [{\n    key: 'destroy',\n    value: function destroy() {\n      this.wheelInput.destroy();\n      this.moveInput.destroy();\n      this.manager.destroy();\n    }\n    /**\n     * Register an event handler function to be called on `event`.\n     * @param {string|Object} event   An event name (String) or map of event names to handlers.\n     * @param {Function} [handler]    The function to be called on `event`.\n     */\n\n  }, {\n    key: 'on',\n    value: function on(event, handler) {\n      if (typeof event === 'string') {\n        this._addEventHandler(event, handler);\n      } else {\n        // If `event` is a map, call `on()` for each entry.\n        for (var eventName in event) {\n          this._addEventHandler(eventName, event[eventName]);\n        }\n      }\n    }\n    /**\n     * Deregister a previously-registered event handler.\n     * @param {string|Object} event   An event name (String) or map of event names to handlers\n     * @param {Function} [handler]    The function to be called on `event`.\n     */\n\n  }, {\n    key: 'off',\n    value: function off(event, handler) {\n      if (typeof event === 'string') {\n        this._removeEventHandler(event, handler);\n      } else {\n        // If `event` is a map, call `off()` for each entry.\n        for (var eventName in event) {\n          this._removeEventHandler(eventName, event[eventName]);\n        }\n      }\n    }\n    /*\n     * Enable/disable recognizer for the given event\n     */\n\n  }, {\n    key: '_toggleRecognizer',\n    value: function _toggleRecognizer(name, enabled) {\n      var recognizer = this.manager.get(name);\n\n      if (recognizer) {\n        recognizer.set({\n          enable: enabled\n        });\n      }\n\n      this.wheelInput.toggleIfEventSupported(name, enabled);\n      this.moveInput.toggleIfEventSupported(name, enabled);\n    }\n    /**\n     * Process the event registration for a single event + handler.\n     */\n\n  }, {\n    key: '_addEventHandler',\n    value: function _addEventHandler(event, handler) {\n      var wrappedHandler = this._wrapEventHandler(event, handler); // Alias to a recognized gesture as necessary.\n\n\n      var eventAlias = GESTURE_EVENT_ALIASES[event] || event; // Get recognizer for this event\n\n      var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Enable recognizer for this event.\n\n      this._toggleRecognizer(recognizerName, true); // Save wrapped handler\n\n\n      this.eventHandlers.push({\n        event: event,\n        eventAlias: eventAlias,\n        recognizerName: recognizerName,\n        handler: handler,\n        wrappedHandler: wrappedHandler\n      });\n      this.manager.on(eventAlias, wrappedHandler);\n    }\n    /**\n     * Process the event deregistration for a single event + handler.\n     */\n\n  }, {\n    key: '_removeEventHandler',\n    value: function _removeEventHandler(event, handler) {\n      var eventHandlerRemoved = false; // Find saved handler if any.\n\n      for (var i = this.eventHandlers.length; i--;) {\n        var entry = this.eventHandlers[i];\n\n        if (entry.event === event && entry.handler === handler) {\n          // Deregister event handler.\n          this.manager.off(entry.eventAlias, entry.wrappedHandler); // Delete saved handler\n\n          this.eventHandlers.splice(i, 1);\n          eventHandlerRemoved = true;\n        }\n      }\n\n      if (eventHandlerRemoved) {\n        // Alias to a recognized gesture as necessary.\n        var eventAlias = GESTURE_EVENT_ALIASES[event] || event; // Get recognizer for this event\n\n        var recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias; // Disable recognizer if no more handlers are attached to its events\n\n        var isRecognizerUsed = this.eventHandlers.find(function (entry) {\n          return entry.recognizerName === recognizerName;\n        });\n\n        if (!isRecognizerUsed) {\n          this._toggleRecognizer(recognizerName, false);\n        }\n      }\n    }\n    /**\n     * Returns an event handler that aliases events and add props before passing\n     * to the real handler.\n     */\n\n  }, {\n    key: '_wrapEventHandler',\n    value: function _wrapEventHandler(type, handler) {\n      var _this = this;\n\n      return function (event) {\n        var element = _this.element;\n        var srcEvent = event.srcEvent;\n        var center = event.center || {\n          x: srcEvent.clientX,\n          y: srcEvent.clientY\n        }; // Calculate center relative to the root element\n        // TODO/xiaoji - avoid using getBoundingClientRect for perf?\n\n        var rect = element.getBoundingClientRect();\n        var offsetCenter = {\n          x: center.x - rect.left - element.clientLeft,\n          y: center.y - rect.top - element.clientTop\n        };\n        handler(Object.assign({}, event, {\n          type: type,\n          center: center,\n          offsetCenter: offsetCenter,\n          rootElement: element\n        }));\n      };\n    }\n    /**\n     * Handle basic events using the 'hammer.input' Hammer.js API:\n     * Before running Recognizers, Hammer emits a 'hammer.input' event\n     * with the basic event info. This function emits all basic events\n     * aliased to the \"class\" of event received.\n     * See constants.BASIC_EVENT_CLASSES basic event class definitions.\n     */\n\n  }, {\n    key: '_onBasicInput',\n    value: function _onBasicInput(event) {\n      var srcEvent = event.srcEvent;\n      var alias = BASIC_EVENT_ALIASES[srcEvent.type];\n\n      if (alias) {\n        // fire all events aliased to srcEvent.type\n        var emitEvent = Object.assign({}, event, {\n          isDown: true,\n          type: alias\n        });\n        this.manager.emit(alias, emitEvent);\n      }\n    }\n    /**\n     * Handle events not supported by Hammer.js,\n     * and pipe back out through same (Hammer) channel used by other events.\n     */\n\n  }, {\n    key: '_onOtherEvent',\n    value: function _onOtherEvent(event) {\n      this.manager.emit(event.type, event);\n    }\n  }]);\n\n  return EventManager;\n}();\n\nexport default EventManager;","map":null,"metadata":{},"sourceType":"module"}