{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* global window */\n\n\nimport { COORDINATE_SYSTEM, LIFECYCLE } from './constants';\nimport AttributeManager from './attribute-manager';\nimport Stats from './stats';\nimport { getDefaultProps, compareProps } from './props';\nimport { log, count } from './utils';\nimport { applyPropOverrides, removeLayerInSeer } from '../debug/seer-integration';\nimport { GL, withParameters } from 'luma.gl';\nimport assert from 'assert';\nvar LOG_PRIORITY_UPDATE = 1;\nvar EMPTY_ARRAY = [];\n\nvar noop = function noop() {};\n/*\n * @param {string} props.id - layer name\n * @param {array}  props.data - array of data instances\n * @param {bool} props.opacity - opacity of the layer\n */\n\n\nvar defaultProps = {\n  // data: Special handling for null, see below\n  dataComparator: null,\n  updateTriggers: {},\n  // Update triggers: a core change detection mechanism in deck.gl\n  numInstances: undefined,\n  visible: true,\n  pickable: false,\n  opacity: 0.8,\n  onHover: noop,\n  onClick: noop,\n  projectionMode: COORDINATE_SYSTEM.LNGLAT,\n  parameters: {},\n  uniforms: {},\n  framebuffer: null,\n  animation: null,\n  // Passed prop animation functions to evaluate props\n  // Offset depth based on layer index to avoid z-fighting.\n  // Negative values pull layer towards the camera\n  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm\n  getPolygonOffset: function getPolygonOffset(_ref) {\n    var layerIndex = _ref.layerIndex;\n    return [0, -layerIndex * 100];\n  }\n};\nvar counter = 0;\n\nvar Layer = function () {\n  /**\n   * @class\n   * @param {object} props - See docs and defaults above\n   */\n  function Layer(props) {\n    _classCallCheck(this, Layer); // If sublayer has static defaultProps member, getDefaultProps will return it\n\n\n    var mergedDefaultProps = getDefaultProps(this); // Merge supplied props with pre-merged default props\n\n    props = Object.assign({}, mergedDefaultProps, props); // Accept null as data - otherwise apps and layers need to add ugly checks\n    // Use constant fallback so that data change is not triggered\n\n    props.data = props.data || EMPTY_ARRAY; // Apply any overrides from the seer debug extension if it is active\n\n    applyPropOverrides(props); // Props are immutable\n\n    Object.freeze(props); // Define all members\n\n    this.id = props.id; // The layer's id, used for matching with layers' from last render cyckle\n\n    this.props = props; // Current props, a frozen object\n\n    this.animatedProps = null; // Computing animated props requires layer manager state\n\n    this.oldProps = null; // Props from last render used for change detection\n\n    this.state = null; // Will be set to the shared layer state object during layer matching\n\n    this.context = null; // Will reference layer manager's context, contains state shared by layers\n\n    this.count = counter++; // Keep track of how many layer instances you are generating\n\n    this.lifecycle = LIFECYCLE.NO_STATE; // Helps track and debug the life cycle of the layers\n    // CompositeLayer members, need to be defined here because of the `Object.seal`\n\n    this.parentLayer = null; // reference to the composite layer parent that rendered this layer\n\n    this.oldSubLayers = []; // reference to sublayers rendered in the previous cycle\n    // Seal the layer\n\n    Object.seal(this);\n  }\n\n  _createClass(Layer, [{\n    key: 'toString',\n    value: function toString() {\n      var className = this.constructor.layerName || this.constructor.name;\n      return className !== this.props.id ? '<' + className + ':\\'' + this.props.id + '\\'>' : '<' + className + '>';\n    }\n  }, {\n    key: 'initializeState',\n    // //////////////////////////////////////////////////\n    // LIFECYCLE METHODS, overridden by the layer subclasses\n    // Called once to set up the initial state\n    // App can create WebGL resources\n    value: function initializeState() {\n      throw new Error('Layer ' + this + ' has not defined initializeState');\n    } // Let's layer control if updateState should be called\n\n  }, {\n    key: 'shouldUpdateState',\n    value: function shouldUpdateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          oldContext = _ref2.oldContext,\n          context = _ref2.context,\n          changeFlags = _ref2.changeFlags;\n      return changeFlags.propsOrDataChanged;\n    } // Default implementation, all attributes will be invalidated and updated\n    // when data changes\n\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref3) {\n      var oldProps = _ref3.oldProps,\n          props = _ref3.props,\n          oldContext = _ref3.oldContext,\n          context = _ref3.context,\n          changeFlags = _ref3.changeFlags;\n\n      if (changeFlags.dataChanged) {\n        this.invalidateAttribute('all');\n      }\n    } // Called once when layer is no longer matched and state will be discarded\n    // App can destroy WebGL resources here\n\n  }, {\n    key: 'finalizeState',\n    value: function finalizeState() {} // If state has a model, draw it with supplied uniforms\n\n  }, {\n    key: 'draw',\n    value: function draw(_ref4) {\n      var _ref4$uniforms = _ref4.uniforms,\n          uniforms = _ref4$uniforms === undefined ? {} : _ref4$uniforms;\n\n      if (this.state.model) {\n        this.state.model.render(uniforms);\n      }\n    } // called to populate the info object that is passed to the event handler\n    // @return null to cancel event\n\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(_ref5) {\n      var info = _ref5.info,\n          mode = _ref5.mode;\n      var color = info.color,\n          index = info.index;\n\n      if (index >= 0) {\n        // If props.data is an indexable array, get the object\n        if (Array.isArray(this.props.data)) {\n          info.object = this.props.data[index];\n        }\n      } // TODO - move to the JS part of a shader picking shader package\n\n\n      if (mode === 'hover') {\n        var selectedPickingColor = new Float32Array(3);\n        selectedPickingColor[0] = color[0];\n        selectedPickingColor[1] = color[1];\n        selectedPickingColor[2] = color[2];\n        this.setUniforms({\n          selectedPickingColor: selectedPickingColor\n        });\n      }\n\n      return info;\n    } // END LIFECYCLE METHODS\n    // //////////////////////////////////////////////////\n    // Default implementation of attribute invalidation, can be redefine\n\n  }, {\n    key: 'invalidateAttribute',\n    value: function invalidateAttribute() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'all';\n\n      if (name === 'all') {\n        this.state.attributeManager.invalidateAll();\n      } else {\n        this.state.attributeManager.invalidate(name);\n      }\n    } // Calls attribute manager to update any WebGL attributes, can be redefined\n\n  }, {\n    key: 'updateAttributes',\n    value: function updateAttributes(props) {\n      var _state = this.state,\n          attributeManager = _state.attributeManager,\n          model = _state.model;\n\n      if (!attributeManager) {\n        return;\n      } // Figure out data length\n\n\n      var numInstances = this.getNumInstances(props);\n      attributeManager.update({\n        data: props.data,\n        numInstances: numInstances,\n        props: props,\n        buffers: props,\n        context: this,\n        // Don't worry about non-attribute props\n        ignoreUnknownAttributes: true\n      });\n\n      if (model) {\n        var changedAttributes = attributeManager.getChangedAttributes({\n          clearChangedFlags: true\n        });\n        model.setAttributes(changedAttributes);\n      }\n    } // Public API\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: 'setState',\n    value: function setState(updateObject) {\n      Object.assign(this.state, updateObject);\n      this.state.needsRedraw = true;\n    }\n  }, {\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (this.state) {\n        this.state.needsRedraw = redraw;\n      }\n    } // PROJECTION METHODS\n\n    /**\n     * Projects a point with current map state (lat, lon, zoom, pitch, bearing)\n     *\n     * Note: Position conversion is done in shader, so in many cases there is no need\n     * for this function\n     * @param {Array|TypedArray} lngLat - long and lat values\n     * @return {Array|TypedArray} - x, y coordinates\n     */\n\n  }, {\n    key: 'project',\n    value: function project(lngLat) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n      return viewport.project(lngLat);\n    }\n  }, {\n    key: 'unproject',\n    value: function unproject(xy) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n      return viewport.unproject(xy);\n    }\n  }, {\n    key: 'projectFlat',\n    value: function projectFlat(lngLat) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(lngLat), 'Layer.project needs [lng,lat]');\n      return viewport.projectFlat(lngLat);\n    }\n  }, {\n    key: 'unprojectFlat',\n    value: function unprojectFlat(xy) {\n      var viewport = this.context.viewport;\n      assert(Array.isArray(xy), 'Layer.unproject needs [x,y]');\n      return viewport.unprojectFlat(xy);\n    }\n  }, {\n    key: 'screenToDevicePixels',\n    value: function screenToDevicePixels(screenPixels) {\n      var devicePixelRatio = typeof window !== 'undefined' ? window.devicePixelRatio : 1;\n      return screenPixels * devicePixelRatio;\n    }\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @return {Array} - a black color\n     */\n\n  }, {\n    key: 'nullPickingColor',\n    value: function nullPickingColor() {\n      return [0, 0, 0];\n    }\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @param {int} i - index to be decoded\n     * @return {Array} - the decoded color\n     */\n\n  }, {\n    key: 'encodePickingColor',\n    value: function encodePickingColor(i) {\n      return [i + 1 & 255, i + 1 >> 8 & 255, i + 1 >> 8 >> 8 & 255];\n    }\n    /**\n     * Returns the picking color that doesn't match any subfeature\n     * Use if some graphics do not belong to any pickable subfeature\n     * @param {Uint8Array} color - color array to be decoded\n     * @return {Array} - the decoded picking color\n     */\n\n  }, {\n    key: 'decodePickingColor',\n    value: function decodePickingColor(color) {\n      assert(color instanceof Uint8Array);\n\n      var _color = _slicedToArray(color, 3),\n          i1 = _color[0],\n          i2 = _color[1],\n          i3 = _color[2]; // 1 was added to seperate from no selection\n\n\n      var index = i1 + i2 * 256 + i3 * 65536 - 1;\n      return index;\n    }\n  }, {\n    key: 'calculateInstancePickingColors',\n    value: function calculateInstancePickingColors(attribute, _ref6) {\n      var numInstances = _ref6.numInstances;\n      var value = attribute.value,\n          size = attribute.size; // add 1 to index to seperate from no selection\n\n      for (var i = 0; i < numInstances; i++) {\n        var pickingColor = this.encodePickingColor(i);\n        value[i * size + 0] = pickingColor[0];\n        value[i * size + 1] = pickingColor[1];\n        value[i * size + 2] = pickingColor[2];\n      }\n    } // DATA ACCESS API\n    // Data can use iterators and may not be random access\n    // Use iteration (the only required capability on data) to get first element\n\n  }, {\n    key: 'getFirstObject',\n    value: function getFirstObject() {\n      var data = this.props.data;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          return object;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return null;\n    } // INTERNAL METHODS\n    // Deduces numer of instances. Intention is to support:\n    // - Explicit setting of numInstances\n    // - Auto-deduction for ES6 containers that define a size member\n    // - Auto-deduction for Classic Arrays via the built-in length attribute\n    // - Auto-deduction via arrays\n\n  }, {\n    key: 'getNumInstances',\n    value: function getNumInstances(props) {\n      props = props || this.props; // First check if the layer has set its own value\n\n      if (this.state && this.state.numInstances !== undefined) {\n        return this.state.numInstances;\n      } // Check if app has provided an explicit value\n\n\n      if (props.numInstances !== undefined) {\n        return props.numInstances;\n      } // Use container library to get a count for any ES6 container or object\n\n\n      var _props = props,\n          data = _props.data;\n      return count(data);\n    } // LAYER MANAGER API\n    // Should only be called by the deck.gl LayerManager class\n    // Called by layer manager when a new layer is found\n\n    /* eslint-disable max-statements */\n\n  }, {\n    key: 'initializeLayer',\n    value: function initializeLayer(updateParams) {\n      assert(this.context.gl, 'Layer context missing gl');\n      assert(!this.state, 'Layer missing state');\n      this.state = {};\n      this.state.stats = new Stats({\n        id: 'draw'\n      }); // Initialize state only once\n\n      this.setState({\n        attributeManager: new AttributeManager({\n          id: this.props.id\n        }),\n        model: null,\n        needsRedraw: true,\n        dataChanged: true\n      });\n      var attributeManager = this.state.attributeManager; // All instanced layers get instancePickingColors attribute by default\n      // Their shaders can use it to render a picking scene\n      // TODO - this slows down non instanced layers\n\n      attributeManager.addInstanced({\n        instancePickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          update: this.calculateInstancePickingColors\n        }\n      }); // Call subclass lifecycle methods\n\n      this.initializeState();\n      this.updateState(updateParams); // End subclass lifecycle methods\n      // Add any subclass attributes\n\n      this.updateAttributes(this.props);\n\n      this._updateBaseUniforms();\n\n      var model = this.state.model;\n\n      if (model) {\n        model.setInstanceCount(this.getNumInstances());\n        model.id = this.props.id;\n        model.program.id = this.props.id + '-program';\n        model.geometry.id = this.props.id + '-geometry';\n        model.setAttributes(attributeManager.getAttributes());\n      }\n    } // Called by layer manager when existing layer is getting new props\n\n  }, {\n    key: 'updateLayer',\n    value: function updateLayer(updateParams) {\n      // Check for deprecated method\n      if (this.shouldUpdate) {\n        log.once(0, 'deck.gl v3 ' + this + ': \"shouldUpdate\" deprecated, renamed to \"shouldUpdateState\"');\n      } // Call subclass lifecycle method\n\n\n      var stateNeedsUpdate = this.shouldUpdateState(updateParams); // End lifecycle method\n\n      if (stateNeedsUpdate) {\n        // Call subclass lifecycle method\n        this.updateState(updateParams); // End lifecycle method\n        // Run the attribute updaters\n\n        this.updateAttributes(updateParams.props);\n\n        this._updateBaseUniforms();\n\n        if (this.state.model) {\n          this.state.model.setInstanceCount(this.getNumInstances());\n        }\n      }\n    }\n    /* eslint-enable max-statements */\n    // Called by manager when layer is about to be disposed\n    // Note: not guaranteed to be called on application shutdown\n\n  }, {\n    key: 'finalizeLayer',\n    value: function finalizeLayer() {\n      // Call subclass lifecycle method\n      this.finalizeState(); // End lifecycle method\n\n      removeLayerInSeer(this.id);\n    } // Calculates uniforms\n\n  }, {\n    key: 'drawLayer',\n    value: function drawLayer(_ref7) {\n      var _this = this;\n\n      var _ref7$moduleParameter = _ref7.moduleParameters,\n          moduleParameters = _ref7$moduleParameter === undefined ? null : _ref7$moduleParameter,\n          _ref7$uniforms = _ref7.uniforms,\n          uniforms = _ref7$uniforms === undefined ? {} : _ref7$uniforms,\n          _ref7$parameters = _ref7.parameters,\n          parameters = _ref7$parameters === undefined ? {} : _ref7$parameters; // TODO/ib - hack move to luma Model.draw\n\n      if (moduleParameters && this.state.model) {\n        this.state.model.updateModuleSettings(moduleParameters);\n      } // Apply polygon offset to avoid z-fighting\n\n\n      var getPolygonOffset = this.props.getPolygonOffset;\n      var offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];\n      parameters.polygonOffset = offsets; // Call subclass lifecycle method\n\n      withParameters(this.context.gl, parameters, function () {\n        return _this.draw({\n          moduleParameters: moduleParameters,\n          uniforms: uniforms,\n          parameters: parameters\n        });\n      }); // End lifecycle method\n    } // {uniforms = {}, ...opts}\n\n  }, {\n    key: 'pickLayer',\n    value: function pickLayer(opts) {\n      // Call subclass lifecycle method\n      return this.getPickingInfo(opts); // End lifecycle method\n    } // Checks state of attributes and model\n    // TODO - is attribute manager needed? - Model should be enough.\n\n  }, {\n    key: 'getNeedsRedraw',\n    value: function getNeedsRedraw() {\n      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,\n          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag; // this method may be called by the render loop as soon a the layer\n      // has been created, so guard against uninitialized state\n\n\n      if (!this.state) {\n        return false;\n      }\n\n      var redraw = false;\n      redraw = redraw || this.state.needsRedraw;\n      this.state.needsRedraw = this.state.needsRedraw && !clearRedrawFlags;\n      var _state2 = this.state,\n          attributeManager = _state2.attributeManager,\n          model = _state2.model;\n      redraw = redraw || attributeManager && attributeManager.getNeedsRedraw({\n        clearRedrawFlags: clearRedrawFlags\n      });\n      redraw = redraw || model && model.getNeedsRedraw({\n        clearRedrawFlags: clearRedrawFlags\n      });\n      return redraw;\n    }\n  }, {\n    key: 'diffProps',\n    value: function diffProps(oldProps, newProps, context) {\n      // First check if any props have changed (ignore props that will be examined separately)\n      var propsChangedReason = compareProps({\n        newProps: newProps,\n        oldProps: oldProps,\n        ignoreProps: {\n          data: null,\n          updateTriggers: null\n        }\n      }); // Now check if any data related props have changed\n\n      var dataChangedReason = this._diffDataProps(oldProps, newProps);\n\n      var propsChanged = Boolean(propsChangedReason);\n      var dataChanged = Boolean(dataChangedReason);\n      var viewportChanged = context.viewportChanged;\n      var updateTriggersChanged = false; // Check update triggers to determine if any attributes need regeneration\n      // Note - if data has changed, all attributes will need regeneration, so skip this step\n\n      if (!dataChanged) {\n        updateTriggersChanged = this._diffUpdateTriggers(oldProps, newProps);\n      }\n\n      var propsOrDataChanged = propsChanged || dataChanged || updateTriggersChanged;\n      var somethingChanged = propsOrDataChanged || viewportChanged; // Trace what happened\n\n      if (dataChanged) {\n        log.log(LOG_PRIORITY_UPDATE, 'dataChanged: ' + dataChangedReason + ' in ' + this.id);\n      } else if (propsChanged) {\n        log.log(LOG_PRIORITY_UPDATE, 'propsChanged: ' + propsChangedReason + ' in ' + this.id);\n      }\n\n      return {\n        propsChanged: propsChanged,\n        dataChanged: dataChanged,\n        updateTriggersChanged: updateTriggersChanged,\n        propsOrDataChanged: propsOrDataChanged,\n        viewportChanged: viewportChanged,\n        somethingChanged: somethingChanged,\n        reason: dataChangedReason || propsChangedReason || 'Viewport changed'\n      };\n    } // PRIVATE METHODS\n    // The comparison of the data prop requires special handling\n    // the dataComparator should be used if supplied\n\n  }, {\n    key: '_diffDataProps',\n    value: function _diffDataProps(oldProps, newProps) {\n      if (oldProps === null) {\n        return 'oldProps is null, initial diff';\n      } // Support optional app defined comparison of data\n\n\n      var dataComparator = newProps.dataComparator;\n\n      if (dataComparator) {\n        if (!dataComparator(newProps.data, oldProps.data)) {\n          return 'Data comparator detected a change';\n        } // Otherwise, do a shallow equal on props\n\n      } else if (newProps.data !== oldProps.data) {\n        return 'A new data container was supplied';\n      }\n\n      return null;\n    } // Checks if any update triggers have changed, and invalidate\n    // attributes accordingly.\n\n    /* eslint-disable max-statements */\n\n  }, {\n    key: '_diffUpdateTriggers',\n    value: function _diffUpdateTriggers(oldProps, newProps) {\n      // const {attributeManager} = this.state;\n      // const updateTriggerMap = attributeManager.getUpdateTriggerMap();\n      if (oldProps === null) {\n        return true; // oldProps is null, initial diff\n      }\n\n      var change = false;\n\n      for (var propName in newProps.updateTriggers) {\n        var oldTriggers = oldProps.updateTriggers[propName] || {};\n        var newTriggers = newProps.updateTriggers[propName] || {};\n        var diffReason = compareProps({\n          oldProps: oldTriggers,\n          newProps: newTriggers,\n          triggerName: propName\n        });\n\n        if (diffReason) {\n          if (propName === 'all') {\n            log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating all attributes: ' + diffReason);\n            this.invalidateAttribute('all');\n            change = true;\n          } else {\n            log.log(LOG_PRIORITY_UPDATE, 'updateTriggers invalidating attribute ' + propName + ': ' + diffReason);\n            this.invalidateAttribute(propName);\n            change = true;\n          }\n        }\n      }\n\n      return change;\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: '_checkRequiredProp',\n    value: function _checkRequiredProp(propertyName, condition) {\n      var value = this.props[propertyName];\n\n      if (value === undefined) {\n        throw new Error('Property ' + propertyName + ' undefined in layer ' + this);\n      }\n\n      if (condition && !condition(value)) {\n        throw new Error('Bad property ' + propertyName + ' in layer ' + this);\n      }\n    } // Emits a warning if an old prop is used, optionally suggesting a replacement\n\n  }, {\n    key: '_checkRemovedProp',\n    value: function _checkRemovedProp(oldProp) {\n      var newProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (this.props[oldProp] !== undefined) {\n        var layerName = this.constructor;\n        var message = layerName + ' no longer accepts props.' + oldProp + ' in this version of deck.gl.';\n\n        if (newProp) {\n          message += '\\nPlease use props.' + newProp + ' instead.';\n        }\n\n        log.once(0, message);\n      }\n    }\n  }, {\n    key: '_updateBaseUniforms',\n    value: function _updateBaseUniforms() {\n      this.setUniforms({\n        // apply gamma to opacity to make it visually \"linear\"\n        opacity: Math.pow(this.props.opacity, 1 / 2.2),\n        ONE: 1.0\n      });\n    } // DEPRECATED METHODS\n    // Updates selected state members and marks the object for redraw\n\n  }, {\n    key: 'setUniforms',\n    value: function setUniforms(uniformMap) {\n      if (this.state.model) {\n        this.state.model.setUniforms(uniformMap);\n      } // TODO - set needsRedraw on the model?\n\n\n      this.state.needsRedraw = true;\n      log(3, 'layer.setUniforms', uniformMap);\n    }\n  }, {\n    key: 'stats',\n    get: function get() {\n      return this.state.stats;\n    }\n  }]);\n\n  return Layer;\n}();\n\nexport default Layer;\nLayer.layerName = 'Layer';\nLayer.propTypes = defaultProps;\nLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}