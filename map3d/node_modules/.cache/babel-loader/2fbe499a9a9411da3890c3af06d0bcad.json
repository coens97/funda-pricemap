{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport * as Polygon from './polygon';\nimport { experimental } from '../../core';\nvar fp64ify = experimental.fp64ify,\n    fillArray = experimental.fillArray;\nimport earcut from 'earcut';\n\nfunction getPickingColor(index) {\n  return [index + 1 & 255, index + 1 >> 8 & 255, index + 1 >> 8 >> 8 & 255];\n}\n\nfunction arrayPush(array, values) {\n  var length = values.length;\n  var offset = array.length;\n\n  for (var index = 0; index < length; index++) {\n    array[offset++] = values[index];\n  }\n\n  return array;\n}\n\nfunction flatten(values, level) {\n  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (level > 1) {\n    values.forEach(function (v) {\n      return flatten(v, level - 1, result);\n    });\n  } else {\n    arrayPush(result, values);\n  }\n\n  return result;\n}\n\nvar DEFAULT_COLOR = [0, 0, 0, 255]; // Black\n\nexport var PolygonTesselatorExtruded = function () {\n  function PolygonTesselatorExtruded(_ref) {\n    var polygons = _ref.polygons,\n        _ref$getHeight = _ref.getHeight,\n        getHeight = _ref$getHeight === undefined ? function (x) {\n      return 1000;\n    } : _ref$getHeight,\n        _ref$getColor = _ref.getColor,\n        getColor = _ref$getColor === undefined ? function (x) {\n      return DEFAULT_COLOR;\n    } : _ref$getColor,\n        _ref$wireframe = _ref.wireframe,\n        wireframe = _ref$wireframe === undefined ? false : _ref$wireframe,\n        _ref$fp = _ref.fp64,\n        fp64 = _ref$fp === undefined ? false : _ref$fp;\n\n    _classCallCheck(this, PolygonTesselatorExtruded);\n\n    this.fp64 = fp64; // Expensive operation, convert all polygons to arrays\n\n    polygons = polygons.map(function (complexPolygon, polygonIndex) {\n      var height = getHeight(polygonIndex) || 0;\n      return Polygon.normalize(complexPolygon).map(function (polygon) {\n        return polygon.map(function (coord) {\n          return [coord[0], coord[1], height];\n        });\n      });\n    });\n    var groupedVertices = polygons;\n    this.groupedVertices = polygons;\n    var pointCount = getPointCount(polygons);\n    this.pointCount = pointCount;\n    this.wireframe = wireframe;\n    this.attributes = {};\n    var positionsJS = calculatePositionsJS({\n      groupedVertices: groupedVertices,\n      pointCount: pointCount,\n      wireframe: wireframe\n    });\n    Object.assign(this.attributes, {\n      positions: calculatePositions(positionsJS, this.fp64),\n      indices: calculateIndices({\n        groupedVertices: groupedVertices,\n        wireframe: wireframe\n      }),\n      normals: calculateNormals({\n        groupedVertices: groupedVertices,\n        pointCount: pointCount,\n        wireframe: wireframe\n      }),\n      // colors: calculateColors({groupedVertices, wireframe, getColor}),\n      pickingColors: calculatePickingColors({\n        groupedVertices: groupedVertices,\n        pointCount: pointCount,\n        wireframe: wireframe\n      })\n    });\n  }\n\n  _createClass(PolygonTesselatorExtruded, [{\n    key: 'indices',\n    value: function indices() {\n      return this.attributes.indices;\n    }\n  }, {\n    key: 'positions',\n    value: function positions() {\n      return this.attributes.positions;\n    }\n  }, {\n    key: 'normals',\n    value: function normals() {\n      return this.attributes.normals;\n    }\n  }, {\n    key: 'colors',\n    value: function colors() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$getColor = _ref2.getColor,\n          getColor = _ref2$getColor === undefined ? function (x) {\n        return DEFAULT_COLOR;\n      } : _ref2$getColor;\n\n      var groupedVertices = this.groupedVertices,\n          pointCount = this.pointCount,\n          wireframe = this.wireframe;\n      return calculateColors({\n        groupedVertices: groupedVertices,\n        pointCount: pointCount,\n        wireframe: wireframe,\n        getColor: getColor\n      });\n    }\n  }, {\n    key: 'pickingColors',\n    value: function pickingColors() {\n      return this.attributes.pickingColors;\n    } // updateTriggers: {\n    //   positions: ['getHeight'],\n    //   colors: ['getColors']\n    //   pickingColors: 'none'\n    // }\n\n  }]);\n\n  return PolygonTesselatorExtruded;\n}(); // Count number of points in a list of complex polygons\n\nfunction getPointCount(polygons) {\n  return polygons.reduce(function (points, polygon) {\n    return points + Polygon.getVertexCount(polygon);\n  }, 0);\n}\n\nfunction calculateIndices(_ref3) {\n  var groupedVertices = _ref3.groupedVertices,\n      _ref3$wireframe = _ref3.wireframe,\n      wireframe = _ref3$wireframe === undefined ? false : _ref3$wireframe; // adjust index offset for multiple polygons\n\n  var multiplier = wireframe ? 2 : 5;\n  var offsets = [];\n  groupedVertices.reduce(function (vertexIndex, vertices) {\n    offsets.push(vertexIndex);\n    return vertexIndex + Polygon.getVertexCount(vertices) * multiplier;\n  }, 0);\n  var indices = groupedVertices.map(function (vertices, polygonIndex) {\n    return wireframe ? // 1. get sequentially ordered indices of each polygons wireframe\n    // 2. offset them by the number of indices in previous polygons\n    calculateContourIndices(vertices, offsets[polygonIndex]) : // 1. get triangulated indices for the internal areas\n    // 2. offset them by the number of indices in previous polygons\n    calculateSurfaceIndices(vertices, offsets[polygonIndex]);\n  });\n  return new Uint32Array(flatten(indices, 2));\n} // Calculate a flat position array in JS - can be mapped to 32 or 64 bit typed arrays\n// Remarks:\n// * each top vertex is on 3 surfaces\n// * each bottom vertex is on 2 surfaces\n\n\nfunction calculatePositionsJS(_ref4) {\n  var groupedVertices = _ref4.groupedVertices,\n      pointCount = _ref4.pointCount,\n      _ref4$wireframe = _ref4.wireframe,\n      wireframe = _ref4$wireframe === undefined ? false : _ref4$wireframe;\n  var multiplier = wireframe ? 2 : 5;\n  var positions = new Float32Array(pointCount * 3 * multiplier);\n  var vertexIndex = 0;\n  groupedVertices.forEach(function (vertices) {\n    var topVertices = flatten(vertices, 3);\n    var baseVertices = topVertices.slice(0);\n    var i = topVertices.length - 1;\n\n    while (i > 0) {\n      baseVertices[i] = 0;\n      i -= 3;\n    }\n\n    var len = topVertices.length;\n\n    if (wireframe) {\n      fillArray({\n        target: positions,\n        source: topVertices,\n        start: vertexIndex\n      });\n      fillArray({\n        target: positions,\n        source: baseVertices,\n        start: vertexIndex + len\n      });\n    } else {\n      fillArray({\n        target: positions,\n        source: topVertices,\n        start: vertexIndex,\n        count: 3\n      });\n      fillArray({\n        target: positions,\n        source: baseVertices,\n        start: vertexIndex + len * 3,\n        count: 2\n      });\n    }\n\n    vertexIndex += len * multiplier;\n  });\n  return positions;\n}\n\nfunction calculatePositions(positionsJS, fp64) {\n  var positionLow = void 0;\n\n  if (fp64) {\n    // We only need x, y component\n    var vertexCount = positionsJS.length / 3;\n    positionLow = new Float32Array(vertexCount * 2);\n\n    for (var i = 0; i < vertexCount; i++) {\n      positionLow[i * 2 + 0] = fp64ify(positionsJS[i * 3 + 0])[1];\n      positionLow[i * 2 + 1] = fp64ify(positionsJS[i * 3 + 1])[1];\n    }\n  }\n\n  return {\n    positions: positionsJS,\n    positions64xyLow: positionLow\n  };\n}\n\nfunction calculateNormals(_ref5) {\n  var groupedVertices = _ref5.groupedVertices,\n      pointCount = _ref5.pointCount,\n      wireframe = _ref5.wireframe;\n  var up = [0, 0, 1];\n  var multiplier = wireframe ? 2 : 5;\n  var normals = new Float32Array(pointCount * 3 * multiplier);\n  var vertexIndex = 0;\n\n  if (wireframe) {\n    return fillArray({\n      target: normals,\n      source: up,\n      count: pointCount * multiplier\n    });\n  }\n\n  groupedVertices.map(function (vertices, polygonIndex) {\n    var vertexCount = Polygon.getVertexCount(vertices);\n    fillArray({\n      target: normals,\n      source: up,\n      start: vertexIndex,\n      count: vertexCount\n    });\n    vertexIndex += vertexCount * 3;\n    var sideNormalsForward = [];\n    var sideNormalsBackward = [];\n    vertices.forEach(function (polygon) {\n      var sideNormals = calculateSideNormals(polygon);\n      var firstNormal = sideNormals.slice(0, 3);\n      arrayPush(sideNormalsForward, sideNormals);\n      arrayPush(sideNormalsForward, firstNormal);\n      arrayPush(sideNormalsBackward, firstNormal);\n      arrayPush(sideNormalsBackward, sideNormals);\n    });\n    fillArray({\n      target: normals,\n      start: vertexIndex,\n      count: 2,\n      source: sideNormalsForward.concat(sideNormalsBackward)\n    });\n    vertexIndex += vertexCount * 3 * 4;\n  });\n  return normals;\n}\n\nfunction calculateSideNormals(vertices) {\n  var normals = [];\n  var lastVertice = null;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = vertices[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var vertice = _step.value;\n\n      if (lastVertice) {\n        // vertex[i-1], vertex[i]\n        var n = getNormal(lastVertice, vertice);\n        arrayPush(normals, n);\n      }\n\n      lastVertice = vertice;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return normals;\n}\n\nfunction calculateColors(_ref6) {\n  var groupedVertices = _ref6.groupedVertices,\n      pointCount = _ref6.pointCount,\n      getColor = _ref6.getColor,\n      _ref6$wireframe = _ref6.wireframe,\n      wireframe = _ref6$wireframe === undefined ? false : _ref6$wireframe;\n  var multiplier = wireframe ? 2 : 5;\n  var colors = new Uint8ClampedArray(pointCount * 4 * multiplier);\n  var vertexIndex = 0;\n  groupedVertices.forEach(function (complexPolygon, polygonIndex) {\n    var color = getColor(polygonIndex);\n    color[3] = Number.isFinite(color[3]) ? color[3] : 255;\n    var numVertices = Polygon.getVertexCount(complexPolygon);\n    fillArray({\n      target: colors,\n      source: color,\n      start: vertexIndex,\n      count: numVertices * multiplier\n    });\n    vertexIndex += color.length * numVertices * multiplier;\n  });\n  return colors;\n}\n\nfunction calculatePickingColors(_ref7) {\n  var groupedVertices = _ref7.groupedVertices,\n      pointCount = _ref7.pointCount,\n      _ref7$wireframe = _ref7.wireframe,\n      wireframe = _ref7$wireframe === undefined ? false : _ref7$wireframe;\n  var multiplier = wireframe ? 2 : 5;\n  var colors = new Uint8ClampedArray(pointCount * 3 * multiplier);\n  var vertexIndex = 0;\n  groupedVertices.forEach(function (vertices, polygonIndex) {\n    var numVertices = Polygon.getVertexCount(vertices);\n    var color = getPickingColor(polygonIndex);\n    fillArray({\n      target: colors,\n      source: color,\n      start: vertexIndex,\n      count: numVertices * multiplier\n    });\n    vertexIndex += color.length * numVertices * multiplier;\n  });\n  return colors;\n}\n\nfunction calculateContourIndices(vertices, offset) {\n  var stride = Polygon.getVertexCount(vertices);\n  var indices = [];\n  vertices.forEach(function (polygon) {\n    indices.push(offset);\n    var numVertices = polygon.length; // polygon top\n    // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n\n    for (var i = 1; i < numVertices - 1; i++) {\n      indices.push(i + offset, i + offset);\n    }\n\n    indices.push(offset); // polygon sides\n\n    for (var _i = 0; _i < numVertices - 1; _i++) {\n      indices.push(_i + offset, _i + stride + offset);\n    }\n\n    offset += numVertices;\n  });\n  return indices;\n}\n\nfunction drawSurfaceRectangle(targetArray, offset, stride) {\n  targetArray.push(offset + stride, offset + stride * 3, offset + stride * 2 + 1, offset + stride * 2 + 1, offset + stride * 3, offset + stride * 4 + 1);\n}\n\nfunction calculateSurfaceIndices(vertices, offset) {\n  var stride = Polygon.getVertexCount(vertices);\n  var holes = null;\n  var holeCount = vertices.length - 1;\n\n  if (holeCount) {\n    holes = [];\n    var vertexIndex = 0;\n\n    for (var i = 0; i < holeCount; i++) {\n      vertexIndex += vertices[i].length;\n      holes[i] = vertexIndex;\n    }\n  }\n\n  var indices = earcut(flatten(vertices, 3), holes, 3).map(function (index) {\n    return index + offset;\n  });\n  vertices.forEach(function (polygon) {\n    var numVertices = polygon.length; // polygon sides\n\n    for (var _i2 = 0; _i2 < numVertices - 1; _i2++) {\n      drawSurfaceRectangle(indices, offset + _i2, stride);\n    }\n\n    offset += numVertices;\n  });\n  return indices;\n} // helpers\n// get normal vector of line segment\n\n\nfunction getNormal(p1, p2) {\n  return [p1[1] - p2[1], p2[0] - p1[0], 0];\n}","map":null,"metadata":{},"sourceType":"module"}