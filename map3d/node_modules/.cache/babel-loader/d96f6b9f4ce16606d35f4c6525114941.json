{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar ERR_DELETED = 'Query was deleted before result was available';\nvar ERR_CANCEL = 'Query was canceled before result was available';\n\nvar noop = function noop(x) {\n  return x;\n};\n\nvar QueryManager =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Internal class that helps \"asynchronous WebGL query objects\" manage\n   * pending requests (e.g. for EXT_disjoint_timer_query and WebGL2 queries)\n   *\n   * Creates and manages promises for the queries.\n   * Tracks pending queries enabling polling.\n   * Tracks pending queries enabling invalidation.\n   * Encapsulates some standard error messages.\n   *\n   * Remarks:\n   * - Maintains a minimal list of pending queries only to minimize GC impact\n   * - Exported as a singleton class instance.\n   */\n  function QueryManager() {\n    _classCallCheck(this, QueryManager);\n\n    this.pendingQueries = new Set();\n    this.invalidQueryType = null;\n    this.invalidErrorMessage = '';\n\n    this.checkInvalid = function () {\n      return false;\n    };\n  } // API THAT SHOULD BE EXPOSED TO APPLICATION\n  // Checks invalidation callback and then all pending queries for completion\n  // Should only be called once per tick\n\n\n  _createClass(QueryManager, [{\n    key: 'poll',\n    value: function poll(gl) {\n      this.cancelInvalidQueries(gl); // Now check availability of results and resolve promises as appropriate\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.pendingQueries.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var query = _step.value;\n          var resultAvailable = query.isResultAvailable();\n\n          if (resultAvailable) {\n            var result = query.getResult();\n            this.resolveQuery(query, result);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    } // API FOR MANAGED QUERY CLASSES\n    // Registers query invalidation method - used to detect disjoint timer queries\n\n  }, {\n    key: 'setInvalidator',\n    value: function setInvalidator(_ref) {\n      var queryType = _ref.queryType,\n          errorMessage = _ref.errorMessage,\n          checkInvalid = _ref.checkInvalid;\n      this.invalidQueryType = queryType;\n      this.invalidErrorMessage = errorMessage;\n      this.checkInvalid = checkInvalid;\n    } // Starts a query, sets up a new promise\n\n  }, {\n    key: 'beginQuery',\n    value: function beginQuery(query) {\n      var onComplete = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n      var onError = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop; // Make sure disjoint state is cleared, so that this query starts fresh\n      // Cancel other queries if needed\n\n      this.cancelInvalidQueries(query.gl); // Cancel current promise - noop if already resolved or rejected\n\n      this.cancelQuery(query); // Create a new promise with attached resolve and reject methods\n\n      var resolvers = {};\n      query.promise = new Promise(function (resolve, reject) {\n        resolvers.resolve = resolve;\n        resolvers.reject = reject;\n      });\n      Object.assign(query.promise, resolvers); // Add this query to the pending queries\n\n      this.pendingQueries.add(query); // Register the callbacks\n\n      return query.promise.then(onComplete).catch(onError);\n    } // Resolves a query with a result\n\n  }, {\n    key: 'resolveQuery',\n    value: function resolveQuery(query, result) {\n      this.pendingQueries.delete(query);\n      query.promise.resolve(result);\n    } // Rejects the promise\n\n  }, {\n    key: 'rejectQuery',\n    value: function rejectQuery(query, errorMessage) {\n      this.pendingQueries.delete(query);\n\n      if (query.promise) {\n        query.promise.reject(new Error(errorMessage));\n      }\n    } // Rejects promise with standard message for Query.delete()\n\n  }, {\n    key: 'deleteQuery',\n    value: function deleteQuery(query) {\n      return this.rejectQuery(query, ERR_DELETED);\n    } // Rejects promise with standard message for Query.cancel()\n\n  }, {\n    key: 'cancelQuery',\n    value: function cancelQuery(query) {\n      return this.rejectQuery(query, ERR_CANCEL);\n    } // Rejects promise with registered message for invalidation\n\n  }, {\n    key: 'invalidateQuery',\n    value: function invalidateQuery(query) {\n      if (query instanceof this.invalidQueryType) {\n        this.rejectQuery(query, this.invalidErrorMessage);\n      }\n    } // Checks all queries to see if need to be invalidated\n\n  }, {\n    key: 'cancelInvalidQueries',\n    value: function cancelInvalidQueries(gl) {\n      // We assume that we can cancel queries for all context.\n      // Should be OK since this is used to check for \"disjoint\" GPU state\n      if (this.checkInvalid(gl)) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = this.pendingQueries.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var query = _step2.value;\n            this.invalidateQuery(query);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  }]);\n\n  return QueryManager;\n}();\n\nexport default new QueryManager();","map":null,"metadata":{},"sourceType":"module"}