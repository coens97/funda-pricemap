{"ast":null,"code":"var _UNIFORM_SETTERS;\n\nfunction _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport Sampler from './sampler';\nimport { formatValue, log } from '../utils';\nimport assert from '../utils/assert'; // Local constants, will be \"collapsed\" during minification\n// WebGL1\n\nvar GL_FLOAT = 0x1406;\nvar GL_FLOAT_VEC2 = 0x8B50;\nvar GL_FLOAT_VEC3 = 0x8B51;\nvar GL_FLOAT_VEC4 = 0x8B52;\nvar GL_INT = 0x1404;\nvar GL_INT_VEC2 = 0x8B53;\nvar GL_INT_VEC3 = 0x8B54;\nvar GL_INT_VEC4 = 0x8B55;\nvar GL_BOOL = 0x8B56;\nvar GL_BOOL_VEC2 = 0x8B57;\nvar GL_BOOL_VEC3 = 0x8B58;\nvar GL_BOOL_VEC4 = 0x8B59;\nvar GL_FLOAT_MAT2 = 0x8B5A;\nvar GL_FLOAT_MAT3 = 0x8B5B;\nvar GL_FLOAT_MAT4 = 0x8B5C;\nvar GL_SAMPLER_2D = 0x8B5E;\nvar GL_SAMPLER_CUBE = 0x8B60; // WebGL2\n\nvar GL_UNSIGNED_INT = 0x1405;\nvar GL_UNSIGNED_INT_VEC2 = 0x8DC6;\nvar GL_UNSIGNED_INT_VEC3 = 0x8DC7;\nvar GL_UNSIGNED_INT_VEC4 = 0x8DC8;\n/* eslint-disable camelcase */\n\nvar GL_FLOAT_MAT2x3 = 0x8B65;\nvar GL_FLOAT_MAT2x4 = 0x8B66;\nvar GL_FLOAT_MAT3x2 = 0x8B67;\nvar GL_FLOAT_MAT3x4 = 0x8B68;\nvar GL_FLOAT_MAT4x2 = 0x8B69;\nvar GL_FLOAT_MAT4x3 = 0x8B6A;\nvar GL_SAMPLER_3D = 0x8B5F;\nvar GL_SAMPLER_2D_SHADOW = 0x8B62;\nvar GL_SAMPLER_2D_ARRAY = 0x8DC1;\nvar GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;\nvar GL_SAMPLER_CUBE_SHADOW = 0x8DC5;\nvar GL_INT_SAMPLER_2D = 0x8DCA;\nvar GL_INT_SAMPLER_3D = 0x8DCB;\nvar GL_INT_SAMPLER_CUBE = 0x8DCC;\nvar GL_INT_SAMPLER_2D_ARRAY = 0x8DCF;\nvar GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2;\nvar GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3;\nvar GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;\nvar GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\nvar UNIFORM_SETTERS = (_UNIFORM_SETTERS = {}, _defineProperty(_UNIFORM_SETTERS, GL_FLOAT, function (gl, location, value) {\n  return gl.uniform1f(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC2, function (gl, location, value) {\n  return gl.uniform2fv(location, toFloatArray(value, 2));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC3, function (gl, location, value) {\n  return gl.uniform3fv(location, toFloatArray(value, 3));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC4, function (gl, location, value) {\n  return gl.uniform4fv(location, toFloatArray(value, 4));\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC2, function (gl, location, value) {\n  return gl.uniform2iv(location, toIntArray(value, 2));\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC3, function (gl, location, value) {\n  return gl.uniform3iv(location, toIntArray(value, 3));\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC4, function (gl, location, value) {\n  return gl.uniform4iv(location, toIntArray(value, 4));\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC2, function (gl, location, value) {\n  return gl.uniform2iv(location, toIntArray(value, 2));\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC3, function (gl, location, value) {\n  return gl.uniform3iv(location, toIntArray(value, 3));\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC4, function (gl, location, value) {\n  return gl.uniform4iv(location, toIntArray(value, 4));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2, function (gl, location, value) {\n  return gl.uniformMatrix2fv(location, false, toFloatArray(value, 4));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3, function (gl, location, value) {\n  return gl.uniformMatrix3fv(location, false, toFloatArray(value, 9));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4, function (gl, location, value) {\n  return gl.uniformMatrix4fv(location, false, toFloatArray(value, 16));\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_CUBE, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT, function (gl, location, value) {\n  return gl.uniform1ui(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC2, function (gl, location, value) {\n  return gl.uniform2uiv(location, toUIntArray(value, 2));\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC3, function (gl, location, value) {\n  return gl.uniform3uiv(location, toUIntArray(value, 3));\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC4, function (gl, location, value) {\n  return gl.uniform4uiv(location, toUIntArray(value, 4));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2x3, function (gl, location, value) {\n  return gl.uniformMatrix2x3fv(location, false, toFloatArray(value, 6));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2x4, function (gl, location, value) {\n  return gl.uniformMatrix2x4fv(location, false, toFloatArray(value, 8));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3x2, function (gl, location, value) {\n  return gl.uniformMatrix3x2fv(location, false, toFloatArray(value, 6));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3x4, function (gl, location, value) {\n  return gl.uniformMatrix3x4fv(location, false, toFloatArray(value, 12));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4x2, function (gl, location, value) {\n  return gl.uniformMatrix4x2fv(location, false, toFloatArray(value, 8));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4x3, function (gl, location, value) {\n  return gl.uniformMatrix4x3fv(location, false, toFloatArray(value, 12));\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_3D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_SHADOW, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_ARRAY, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_ARRAY_SHADOW, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_CUBE_SHADOW, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_2D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_3D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_CUBE, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_2D_ARRAY, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_2D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_3D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_CUBE, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _UNIFORM_SETTERS); // Pre-allocated typed arrays for temporary conversion\n\nvar FLOAT_ARRAY = {};\nvar INT_ARRAY = {};\nvar UINT_ARRAY = {};\n/* Functions to ensure the type of uniform values */\n\nfunction toTypedArray(value, uniformLength, Type, cache) {\n  var length = value.length;\n\n  if (length % uniformLength) {\n    log.warn(\"Uniform size should be multiples of \".concat(uniformLength), value)();\n  }\n\n  if (_instanceof(value, Type)) {\n    return value;\n  }\n\n  var result = cache[length];\n\n  if (!result) {\n    result = new Type(length);\n    cache[length] = result;\n  }\n\n  for (var i = 0; i < length; i++) {\n    result[i] = value[i];\n  }\n\n  return result;\n}\n\nfunction toFloatArray(value, uniformLength) {\n  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);\n}\n\nfunction toIntArray(value, uniformLength) {\n  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);\n}\n\nfunction toUIntArray(value, uniformLength) {\n  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);\n}\n\nexport function parseUniformName(name) {\n  // name = name[name.length - 1] === ']' ?\n  // name.substr(0, name.length - 3) : name;\n  // if array name then clean the array brackets\n  var UNIFORM_NAME_REGEXP = /([^\\[]*)(\\[[0-9]+\\])?/;\n  var matches = name.match(UNIFORM_NAME_REGEXP);\n\n  if (!matches || matches.length < 2) {\n    throw new Error(\"Failed to parse GLSL uniform name \".concat(name));\n  }\n\n  return {\n    name: matches[1],\n    length: matches[2] || 1,\n    isArray: Boolean(matches[2])\n  };\n} // Returns a Magic Uniform Setter\n\n/* eslint-disable complexity */\n\nexport function getUniformSetter(gl, location, info) {\n  var setter = UNIFORM_SETTERS[info.type];\n\n  if (!setter) {\n    throw new Error(\"Unknown GLSL uniform type \".concat(info.type));\n  }\n\n  return setter.bind(null, gl, location);\n} // Basic checks of uniform values without knowledge of program\n// To facilitate early detection of e.g. undefined values in JavaScript\n\nexport function checkUniformValues(uniforms, source) {\n  for (var uniformName in uniforms) {\n    var value = uniforms[uniformName];\n\n    if (!checkUniformValue(value)) {\n      // Add space to source\n      source = source ? \"\".concat(source, \" \") : ''; // Value could be unprintable so write the object on console\n\n      console.error(\"\".concat(source, \" Bad uniform \").concat(uniformName), value); // eslint-disable-line\n\n      /* eslint-enable no-console */\n\n      throw new Error(\"\".concat(source, \" Bad uniform \").concat(uniformName));\n    }\n  }\n\n  return true;\n} // TODO use type information during validation\n\nfunction checkUniformValue(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return checkUniformArray(value);\n  } // Check if single value is a number\n\n\n  if (isFinite(value)) {\n    return true;\n  } else if (value === true || value === false) {\n    return true;\n  } else if (_instanceof(value, Texture) || _instanceof(value, Sampler)) {\n    return true;\n  } else if (_instanceof(value, Framebuffer)) {\n    return Boolean(value.texture);\n  }\n\n  return false;\n}\n\nfunction checkUniformArray(value) {\n  // Check that every element in array is a number, and at least 1 element\n  if (value.length === 0) {\n    return false;\n  }\n\n  var checkLength = Math.min(value.length, 16);\n\n  for (var i = 0; i < checkLength; ++i) {\n    if (!Number.isFinite(value[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Given two values of a uniform, returns `true` if they are equal\n */\n\n\nexport function areUniformsEqual(uniform1, uniform2) {\n  if (Array.isArray(uniform1) || ArrayBuffer.isView(uniform1)) {\n    if (!uniform2) {\n      return false;\n    }\n\n    var len = uniform1.length;\n\n    if (uniform2.length !== len) {\n      return false;\n    }\n\n    for (var i = 0; i < len; i++) {\n      if (uniform1[i] !== uniform2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return uniform1 === uniform2;\n} // Prepares a table suitable for console.table\n\n/* eslint-disable max-statements */\n\nexport function getUniformsTable() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$header = _ref.header,\n      header = _ref$header === void 0 ? 'Uniforms' : _ref$header,\n      program = _ref.program,\n      uniforms = _ref.uniforms,\n      _ref$undefinedOnly = _ref.undefinedOnly,\n      undefinedOnly = _ref$undefinedOnly === void 0 ? false : _ref$undefinedOnly;\n\n  assert(program);\n  var SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';\n  var PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list\n\n  var uniformLocations = program._uniformSetters;\n  var table = {}; // {[header]: {}};\n  // Add program's provided uniforms (in alphabetical order)\n\n  var uniformNames = Object.keys(uniformLocations).sort();\n  var count = 0; // First add non-underscored uniforms (assumed not coming from shader modules)\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = uniformNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var _uniformName = _step.value;\n\n      if (!_uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !_uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n        if (addUniformToTable({\n          table: table,\n          header: header,\n          uniforms: uniforms,\n          uniformName: _uniformName,\n          undefinedOnly: undefinedOnly\n        })) {\n          count++;\n        }\n      }\n    } // add underscored uniforms (assumed from shader modules)\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = uniformNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var _uniformName2 = _step2.value;\n\n      if (_uniformName2.match(PROJECT_MODULE_UNIFORM_REGEXP)) {\n        if (addUniformToTable({\n          table: table,\n          header: header,\n          uniforms: uniforms,\n          uniformName: _uniformName2,\n          undefinedOnly: undefinedOnly\n        })) {\n          count++;\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = uniformNames[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var _uniformName3 = _step3.value;\n\n      if (!table[_uniformName3]) {\n        if (addUniformToTable({\n          table: table,\n          header: header,\n          uniforms: uniforms,\n          uniformName: _uniformName3,\n          undefinedOnly: undefinedOnly\n        })) {\n          count++;\n        }\n      }\n    } // Create a table of unused uniforms\n\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var unusedCount = 0;\n  var unusedTable = {};\n\n  if (!undefinedOnly) {\n    for (var uniformName in uniforms) {\n      var uniform = uniforms[uniformName];\n\n      if (!table[uniformName]) {\n        unusedCount++;\n        unusedTable[uniformName] = _defineProperty({\n          Type: \"NOT USED: \".concat(uniform)\n        }, header, formatValue(uniform));\n      }\n    }\n  }\n\n  return {\n    table: table,\n    count: count,\n    unusedTable: unusedTable,\n    unusedCount: unusedCount\n  };\n} // Helper\n\nfunction addUniformToTable(_ref2) {\n  var table = _ref2.table,\n      header = _ref2.header,\n      uniforms = _ref2.uniforms,\n      uniformName = _ref2.uniformName,\n      undefinedOnly = _ref2.undefinedOnly;\n  var value = uniforms[uniformName];\n  var isDefined = isUniformDefined(value);\n\n  if (!undefinedOnly || !isDefined) {\n    var _table$uniformName;\n\n    table[uniformName] = (_table$uniformName = {}, _defineProperty(_table$uniformName, header, isDefined ? formatValue(value) : 'N/A'), _defineProperty(_table$uniformName, 'Uniform Type', isDefined ? value : 'NOT PROVIDED'), _table$uniformName);\n    return true;\n  }\n\n  return false;\n}\n\nfunction isUniformDefined(value) {\n  return value !== undefined && value !== null;\n}","map":null,"metadata":{},"sourceType":"module"}