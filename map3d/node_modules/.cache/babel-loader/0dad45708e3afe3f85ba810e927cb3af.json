{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport assert from 'assert';\nimport { Framebuffer, ShaderCache } from 'luma.gl';\nimport seer from 'seer';\nimport Layer from './layer';\nimport { log } from './utils';\nimport { flatten } from './utils/flatten';\nimport { drawLayers as _drawLayers, pickLayers, queryLayers } from './draw-and-pick';\nimport { LIFECYCLE } from './constants';\nimport { Viewport } from './viewports';\nimport { setPropOverrides, layerEditListener, seerInitListener, initLayerInSeer, updateLayerInSeer } from '../debug/seer-integration';\nvar LOG_PRIORITY_LIFECYCLE = 2;\nvar LOG_PRIORITY_LIFECYCLE_MINOR = 4;\n\nvar layerName = function layerName(layer) {\n  return layer instanceof Layer ? '' + layer : !layer ? 'null layer' : 'invalid layer';\n};\n\nvar LayerManager = function () {\n  function LayerManager(_ref) {\n    var gl = _ref.gl;\n\n    _classCallCheck(this, LayerManager);\n    /* Currently deck.gl expects the DeckGL.layers to be different\n     whenever React rerenders. If the same layers array is used, the\n     LayerManager's diffing algorithm will generate a fatal error and\n     break the rendering.\n      `this.lastRenderedLayers` stores the UNFILTERED layers sent\n     down to LayerManager, so that `layers` reference can be compared.\n     If it's the same across two React render calls, the diffing logic\n     will be skipped.\n    */\n\n\n    this.lastRenderedLayers = [];\n    this.prevLayers = [];\n    this.layers = [];\n    this.oldContext = {};\n    this.screenCleared = false;\n    this._needsRedraw = true;\n    this._eventManager = null;\n    this._pickingRadius = 0;\n    this._onLayerClick = null;\n    this._onLayerHover = null;\n    this._onClick = this._onClick.bind(this);\n    this._onPointerMove = this._onPointerMove.bind(this);\n    this._initSeer = this._initSeer.bind(this);\n    this._editSeer = this._editSeer.bind(this);\n    this.context = {\n      gl: gl,\n      uniforms: {},\n      viewport: null,\n      viewportChanged: true,\n      pickingFBO: null,\n      lastPickedInfo: {\n        index: -1,\n        layerId: null\n      },\n      shaderCache: new ShaderCache({\n        gl: gl\n      })\n    };\n    seerInitListener(this._initSeer);\n    layerEditListener(this._editSeer);\n    Object.seal(this.context);\n    Object.seal(this);\n  } // Gets an (optionally) filtered list of layers\n\n\n  _createClass(LayerManager, [{\n    key: 'getLayers',\n    value: function getLayers() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$layerIds = _ref2.layerIds,\n          layerIds = _ref2$layerIds === undefined ? null : _ref2$layerIds; // Filtering by layerId compares beginning of strings, so that sublayers will be included\n      // Dependes on the convention of adding suffixes to the parent's layer name\n\n\n      return layerIds ? this.layers.filter(function (layer) {\n        return layerIds.find(function (layerId) {\n          return layer.id.indexOf(layerId) === 0;\n        });\n      }) : this.layers;\n    }\n    /**\n     * Method to call when the layer manager is not needed anymore.\n     *\n     * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.\n     */\n\n  }, {\n    key: 'finalize',\n    value: function finalize() {\n      seer.removeListener(this._initSeer);\n      seer.removeListener(this._editSeer);\n    }\n  }, {\n    key: 'setViewport',\n    value: function setViewport(viewport) {\n      assert(viewport instanceof Viewport, 'Invalid viewport'); // TODO - viewport change detection breaks METER_OFFSETS mode\n      // const oldViewport = this.context.viewport;\n      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n      this._needsRedraw = true;\n      var viewportChanged = true;\n\n      if (viewportChanged) {\n        Object.assign(this.oldContext, this.context);\n        this.context.viewport = viewport;\n        this.context.viewportChanged = true;\n        this.context.uniforms = {};\n        log(4, viewport);\n      }\n\n      return this;\n    }\n    /**\n     * @param {Object} eventManager   A source of DOM input events\n     */\n\n  }, {\n    key: 'initEventHandling',\n    value: function initEventHandling(eventManager) {\n      this._eventManager = eventManager; // TODO: add/remove handlers on demand at runtime, not all at once on init.\n      // Consider both top-level handlers like onLayerClick/Hover\n      // and per-layer handlers attached to individual layers.\n      // https://github.com/uber/deck.gl/issues/634\n\n      this._eventManager.on({\n        click: this._onClick,\n        pointermove: this._onPointerMove\n      });\n    } // Set parameters for input event handling.\n\n  }, {\n    key: 'setEventHandlingParameters',\n    value: function setEventHandlingParameters(_ref3) {\n      var pickingRadius = _ref3.pickingRadius,\n          onLayerClick = _ref3.onLayerClick,\n          onLayerHover = _ref3.onLayerHover;\n\n      if (!isNaN(pickingRadius)) {\n        this._pickingRadius = pickingRadius;\n      }\n\n      if (typeof onLayerClick !== 'undefined') {\n        this._onLayerClick = onLayerClick;\n      }\n\n      if (typeof onLayerHover !== 'undefined') {\n        this._onLayerHover = onLayerHover;\n      }\n\n      this._validateEventHandling();\n    }\n  }, {\n    key: 'updateLayers',\n    value: function updateLayers(_ref4) {\n      var newLayers = _ref4.newLayers; // TODO - something is generating state updates that cause rerender of the same\n\n      if (newLayers === this.lastRenderedLayers) {\n        log.log(3, 'Ignoring layer update due to layer array not changed');\n        return this;\n      }\n\n      this.lastRenderedLayers = newLayers;\n      assert(this.context.viewport, 'LayerManager.updateLayers: viewport not set'); // Filter out any null layers\n\n      newLayers = newLayers.filter(function (newLayer) {\n        return newLayer !== null;\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n          layer.context = this.context;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.prevLayers = this.layers;\n\n      var _updateLayers2 = this._updateLayers({\n        oldLayers: this.prevLayers,\n        newLayers: newLayers\n      }),\n          error = _updateLayers2.error,\n          generatedLayers = _updateLayers2.generatedLayers;\n\n      this.layers = generatedLayers; // Throw first error found, if any\n\n      if (error) {\n        throw error;\n      }\n\n      return this;\n    }\n  }, {\n    key: 'drawLayers',\n    value: function drawLayers(_ref5) {\n      var pass = _ref5.pass;\n      assert(this.context.viewport, 'LayerManager.drawLayers: viewport not set');\n\n      _drawLayers({\n        layers: this.layers,\n        pass: pass\n      });\n\n      return this;\n    } // Pick the closest info at given coordinate\n\n  }, {\n    key: 'pickLayer',\n    value: function pickLayer(_ref6) {\n      var x = _ref6.x,\n          y = _ref6.y,\n          mode = _ref6.mode,\n          _ref6$radius = _ref6.radius,\n          radius = _ref6$radius === undefined ? 0 : _ref6$radius,\n          layerIds = _ref6.layerIds;\n      var gl = this.context.gl;\n      var layers = this.getLayers({\n        layerIds: layerIds\n      });\n      return pickLayers(gl, {\n        x: x,\n        y: y,\n        radius: radius,\n        layers: layers,\n        mode: mode,\n        viewport: this.context.viewport,\n        pickingFBO: this._getPickingBuffer(),\n        lastPickedInfo: this.context.lastPickedInfo\n      });\n    } // Get all unique infos within a bounding box\n\n  }, {\n    key: 'queryLayer',\n    value: function queryLayer(_ref7) {\n      var x = _ref7.x,\n          y = _ref7.y,\n          width = _ref7.width,\n          height = _ref7.height,\n          layerIds = _ref7.layerIds;\n      var gl = this.context.gl;\n      var layers = layerIds ? this.layers.filter(function (layer) {\n        return layerIds.indexOf(layer.id) >= 0;\n      }) : this.layers;\n      return queryLayers(gl, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        layers: layers,\n        mode: 'query',\n        viewport: this.context.viewport,\n        pickingFBO: this._getPickingBuffer()\n      });\n    }\n  }, {\n    key: 'needsRedraw',\n    value: function needsRedraw() {\n      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref8$clearRedrawFlag = _ref8.clearRedrawFlags,\n          clearRedrawFlags = _ref8$clearRedrawFlag === undefined ? false : _ref8$clearRedrawFlag;\n\n      if (!this.context.viewport) {\n        return false;\n      }\n\n      var redraw = this._needsRedraw;\n\n      if (clearRedrawFlags) {\n        this._needsRedraw = false;\n      } // Make sure that buffer is cleared once when layer list becomes empty\n\n\n      if (this.layers.length === 0) {\n        if (this.screenCleared === false) {\n          redraw = true;\n          this.screenCleared = true;\n          return true;\n        }\n      } else if (this.screenCleared === true) {\n        this.screenCleared = false;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var layer = _step2.value;\n          redraw = redraw || layer.getNeedsRedraw({\n            clearRedrawFlags: clearRedrawFlags\n          });\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return redraw;\n    } //\n    // PRIVATE METHODS\n    //\n\n  }, {\n    key: '_getPickingBuffer',\n    value: function _getPickingBuffer() {\n      var gl = this.context.gl; // Create a frame buffer if not already available\n\n      this.context.pickingFBO = this.context.pickingFBO || new Framebuffer(gl, {\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      }); // Resize it to current canvas size (this is a noop if size hasn't changed)\n\n      this.context.pickingFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n      return this.context.pickingFBO;\n    } // Match all layers, checking for caught errors\n    // To avoid having an exception in one layer disrupt other layers\n\n  }, {\n    key: '_updateLayers',\n    value: function _updateLayers(_ref9) {\n      var oldLayers = _ref9.oldLayers,\n          newLayers = _ref9.newLayers; // Create old layer map\n\n      var oldLayerMap = {};\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = oldLayers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var oldLayer = _step3.value;\n\n          if (oldLayerMap[oldLayer.id]) {\n            log.once(0, 'Multiple old layers with same id ' + layerName(oldLayer));\n          } else {\n            oldLayerMap[oldLayer.id] = oldLayer;\n            oldLayer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n          }\n        } // Allocate array for generated layers\n\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var generatedLayers = []; // Match sublayers\n\n      var error = this._matchSublayers({\n        newLayers: newLayers,\n        oldLayerMap: oldLayerMap,\n        generatedLayers: generatedLayers\n      });\n\n      var error2 = this._finalizeOldLayers(oldLayers);\n\n      var firstError = error || error2;\n      return {\n        error: firstError,\n        generatedLayers: generatedLayers\n      };\n    }\n    /* eslint-disable max-statements */\n\n  }, {\n    key: '_matchSublayers',\n    value: function _matchSublayers(_ref10) {\n      var _this = this;\n\n      var newLayers = _ref10.newLayers,\n          oldLayerMap = _ref10.oldLayerMap,\n          generatedLayers = _ref10.generatedLayers; // Filter out any null layers\n\n      newLayers = newLayers.filter(function (newLayer) {\n        return newLayer !== null;\n      });\n      var error = null;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var newLayer = _step4.value;\n          newLayer.context = _this.context;\n\n          try {\n            // 1. given a new coming layer, find its matching layer\n            var oldLayer = oldLayerMap[newLayer.id];\n            oldLayerMap[newLayer.id] = null;\n\n            if (oldLayer === null) {\n              log.once(0, 'Multiple new layers with same id ' + layerName(newLayer));\n            } // Only transfer state at this stage. We must not generate exceptions\n            // until all layers' state have been transferred\n\n\n            if (oldLayer) {\n              _this._transferLayerState(oldLayer, newLayer);\n\n              _this._updateLayer(newLayer);\n\n              updateLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)\n            } else {\n              _this._initializeNewLayer(newLayer);\n\n              initLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)\n            }\n\n            generatedLayers.push(newLayer); // Call layer lifecycle method: render sublayers\n\n            var props = newLayer.props,\n                oldProps = newLayer.oldProps;\n            var sublayers = newLayer.isComposite ? newLayer._renderLayers({\n              oldProps: oldProps,\n              props: props,\n              context: _this.context,\n              oldContext: _this.oldContext,\n              changeFlags: newLayer.diffProps(oldProps, props, _this.context)\n            }) : null; // End layer lifecycle method: render sublayers\n\n            if (sublayers) {\n              // Flatten the returned array, removing any null, undefined or false\n              // this allows layers to render sublayers conditionally\n              // (see CompositeLayer.renderLayers docs)\n              sublayers = flatten(sublayers, {\n                filter: Boolean\n              }); // populate reference to parent layer\n\n              sublayers.forEach(function (layer) {\n                layer.parentLayer = newLayer;\n              });\n\n              _this._matchSublayers({\n                newLayers: sublayers,\n                oldLayerMap: oldLayerMap,\n                generatedLayers: generatedLayers\n              });\n            }\n          } catch (err) {\n            log.once(0, 'deck.gl error during matching of ' + layerName(newLayer) + ' ' + err, err); // Save first error\n\n            error = error || err;\n          }\n        };\n\n        for (var _iterator4 = newLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          _loop();\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return error;\n    }\n  }, {\n    key: '_transferLayerState',\n    value: function _transferLayerState(oldLayer, newLayer) {\n      var state = oldLayer.state,\n          props = oldLayer.props; // sanity check\n\n      assert(state, 'deck.gl sanity check - Matching layer has no state');\n\n      if (newLayer !== oldLayer) {\n        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer); // Move state\n\n        state.layer = newLayer;\n        newLayer.state = state; // Update model layer reference\n\n        if (state.model) {\n          state.model.userData.layer = newLayer;\n        } // Keep a temporary ref to the old props, for prop comparison\n\n\n        newLayer.oldProps = props; // oldLayer.state = null;\n\n        newLayer.lifecycle = LIFECYCLE.MATCHED;\n        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n      } else {\n        log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);\n        newLayer.lifecycle = LIFECYCLE.MATCHED;\n        newLayer.oldProps = newLayer.props; // TODO - we could avoid prop comparisons in this case\n      }\n    } // Update the old layers that were not matched\n\n  }, {\n    key: '_finalizeOldLayers',\n    value: function _finalizeOldLayers(oldLayers) {\n      var error = null; // Matched layers have lifecycle state \"outdated\"\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = oldLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var layer = _step5.value;\n\n          if (layer.lifecycle === LIFECYCLE.AWAITING_FINALIZATION) {\n            error = error || this._finalizeLayer(layer);\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return error;\n    } // Initializes a single layer, calling layer methods\n\n  }, {\n    key: '_initializeNewLayer',\n    value: function _initializeNewLayer(layer) {\n      var error = null; // Check if new layer, and initialize it's state\n\n      if (!layer.state) {\n        log(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));\n\n        try {\n          layer.initializeLayer({\n            oldProps: {},\n            props: layer.props,\n            oldContext: this.oldContext,\n            context: this.context,\n            changeFlags: layer.diffProps({}, layer.props, this.context)\n          });\n          layer.lifecycle = LIFECYCLE.INITIALIZED;\n        } catch (err) {\n          log.once(0, 'deck.gl error during initialization of ' + layerName(layer) + ' ' + err, err); // Save first error\n\n          error = error || err;\n        } // Set back pointer (used in picking)\n\n\n        if (layer.state) {\n          layer.state.layer = layer; // Save layer on model for picking purposes\n          // TODO - store on model.userData rather than directly on model\n        }\n\n        if (layer.state && layer.state.model) {\n          layer.state.model.userData.layer = layer;\n        }\n      }\n\n      return error;\n    } // Updates a single layer, calling layer methods\n\n  }, {\n    key: '_updateLayer',\n    value: function _updateLayer(layer) {\n      var oldProps = layer.oldProps,\n          props = layer.props;\n      var error = null;\n\n      if (oldProps) {\n        try {\n          layer.updateLayer({\n            oldProps: oldProps,\n            props: props,\n            context: this.context,\n            oldContext: this.oldContext,\n            changeFlags: layer.diffProps(oldProps, layer.props, this.context)\n          });\n        } catch (err) {\n          log.once(0, 'deck.gl error during update of ' + layerName(layer), err); // Save first error\n\n          error = err;\n        }\n\n        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layerName(layer));\n      }\n\n      return error;\n    } // Finalizes a single layer\n\n  }, {\n    key: '_finalizeLayer',\n    value: function _finalizeLayer(layer) {\n      var error = null;\n      var state = layer.state;\n\n      if (state) {\n        try {\n          layer.finalizeLayer();\n        } catch (err) {\n          log.once(0, 'deck.gl error during finalization of ' + layerName(layer), err); // Save first error\n\n          error = err;\n        } // layer.state = null;\n\n\n        layer.lifecycle = LIFECYCLE.FINALIZED;\n        log(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));\n      }\n\n      return error;\n    }\n    /**\n     * Warn if a deck-level mouse event has been specified,\n     * but no layers are `pickable`.\n     */\n\n  }, {\n    key: '_validateEventHandling',\n    value: function _validateEventHandling() {\n      if (this.onLayerClick || this.onLayerHover) {\n        if (this.layers.length && !this.layers.some(function (layer) {\n          return layer.props.pickable;\n        })) {\n          log.once(1, 'You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');\n        }\n      }\n    }\n    /**\n     * Route click events to layers.\n     * `pickLayer` will call the `onClick` prop of any picked layer,\n     * and `onLayerClick` is called directly from here\n     * with any picking info generated by `pickLayer`.\n     * @param {Object} event  An object encapsulating an input event,\n     *                        with the following shape:\n     *                        {Object: {x, y}} offsetCenter: center of the event\n     *                        {Object} srcEvent:             native JS Event object\n     */\n\n  }, {\n    key: '_onClick',\n    value: function _onClick(event) {\n      var pos = event.offsetCenter;\n\n      if (!pos) {\n        return;\n      }\n\n      var selectedInfos = this.pickLayer({\n        x: pos.x,\n        y: pos.y,\n        radius: this._pickingRadius,\n        mode: 'click'\n      });\n\n      if (selectedInfos.length) {\n        var firstInfo = selectedInfos.find(function (info) {\n          return info.index >= 0;\n        });\n\n        if (this._onLayerClick) {\n          this._onLayerClick(firstInfo, selectedInfos, event.srcEvent);\n        }\n      }\n    }\n    /**\n     * Route click events to layers.\n     * `pickLayer` will call the `onHover` prop of any picked layer,\n     * and `onLayerHover` is called directly from here\n     * with any picking info generated by `pickLayer`.\n     * @param {Object} event  An object encapsulating an input event,\n     *                        with the following shape:\n     *                        {Object: {x, y}} offsetCenter: center of the event\n     *                        {Object} srcEvent:             native JS Event object\n     */\n\n  }, {\n    key: '_onPointerMove',\n    value: function _onPointerMove(event) {\n      if (event.isDown) {\n        // Do not trigger onHover callbacks if mouse button is down\n        return;\n      }\n\n      var pos = event.offsetCenter; // TODO: consider using this.eventManager.element size instead of layerManager.context\n      // but do so in a way that doesn't cause reflow (e.g. `offsetWidth/Height`).\n      // maybe the event object offers offsetCenter as a 0<>1 value as well?\n      // since it's already doing size calculations...\n\n      var _context$viewport = this.context.viewport,\n          width = _context$viewport.width,\n          height = _context$viewport.height;\n\n      if (!pos || pos.x < 0 || pos.y < 0 || pos.x > width || pos.y > height) {\n        // Check if pointer is inside the canvas\n        return;\n      }\n\n      var selectedInfos = this.pickLayer({\n        x: pos.x,\n        y: pos.y,\n        radius: this._pickingRadius,\n        mode: 'hover'\n      });\n\n      if (selectedInfos.length) {\n        var firstInfo = selectedInfos.find(function (info) {\n          return info.index >= 0;\n        });\n\n        if (this._onLayerHover) {\n          this._onLayerHover(firstInfo, selectedInfos, event.srcEvent);\n        }\n      }\n    } // SEER INTEGRATION\n\n    /**\n     * Called upon Seer initialization, manually sends layers data.\n     */\n\n  }, {\n    key: '_initSeer',\n    value: function _initSeer() {\n      this.layers.forEach(function (layer) {\n        initLayerInSeer(layer);\n        updateLayerInSeer(layer);\n      });\n    }\n    /**\n     * On Seer property edition, set override and update layers.\n     */\n\n  }, {\n    key: '_editSeer',\n    value: function _editSeer(payload) {\n      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {\n        return;\n      }\n\n      setPropOverrides(payload.itemKey, payload.valuePath.slice(1), payload.value);\n      var newLayers = this.layers.map(function (layer) {\n        return new layer.constructor(layer.props);\n      });\n      this.updateLayers({\n        newLayers: newLayers\n      });\n    }\n  }]);\n\n  return LayerManager;\n}();\n\nexport default LayerManager;","map":null,"metadata":{},"sourceType":"module"}