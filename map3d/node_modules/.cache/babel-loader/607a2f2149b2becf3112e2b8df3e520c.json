{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport { GL } from './gl-constants';\nimport Texture from './texture'; // import {withParameters} from './context';\n\nimport assert from 'assert';\nvar FACES = [GL.TEXTURE_CUBE_MAP_POSITIVE_X, GL.TEXTURE_CUBE_MAP_NEGATIVE_X, GL.TEXTURE_CUBE_MAP_POSITIVE_Y, GL.TEXTURE_CUBE_MAP_NEGATIVE_Y, GL.TEXTURE_CUBE_MAP_POSITIVE_Z, GL.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n\nvar TextureCube =\n/*#__PURE__*/\nfunction (_Texture) {\n  _inherits(TextureCube, _Texture);\n\n  function TextureCube(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TextureCube);\n\n    var _this = _possibleConstructorReturn(this, (TextureCube.__proto__ || Object.getPrototypeOf(TextureCube)).call(this, gl, Object.assign({}, opts, {\n      target: GL.TEXTURE_CUBE_MAP\n    })));\n\n    _this.initialize(opts);\n\n    Object.seal(_this);\n    return _this;\n  }\n  /* eslint-disable max-len, max-statements */\n\n\n  _createClass(TextureCube, [{\n    key: 'initialize',\n    value: function initialize() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$format = opts.format,\n          format = _opts$format === undefined ? GL.RGBA : _opts$format,\n          _opts$mipmaps = opts.mipmaps,\n          mipmaps = _opts$mipmaps === undefined ? true : _opts$mipmaps;\n      var _opts$width = opts.width,\n          width = _opts$width === undefined ? 1 : _opts$width,\n          _opts$height = opts.height,\n          height = _opts$height === undefined ? 1 : _opts$height,\n          _opts$type = opts.type,\n          type = _opts$type === undefined ? GL.UNSIGNED_BYTE : _opts$type,\n          dataFormat = opts.dataFormat; // Deduce width and height based on one of the faces\n\n      var _deduceParameters = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat\n      });\n\n      type = _deduceParameters.type;\n      dataFormat = _deduceParameters.dataFormat; // Enforce cube\n\n      var _deduceImageSize = this._deduceImageSize({\n        data: opts[GL.TEXTURE_CUBE_MAP_POSITIVE_X],\n        width: width,\n        height: height\n      });\n\n      width = _deduceImageSize.width;\n      height = _deduceImageSize.height;\n      assert(width === height); // Temporarily apply any pixel store paramaters and build textures\n      // withParameters(this.gl, opts, () => {\n      //   for (const face of CUBE_MAP_FACES) {\n      //     this.setImageData({\n      //       target: face,\n      //       data: opts[face],\n      //       width, height, format, type, dataFormat, border, mipmaps\n      //     });\n      //   }\n      // });\n\n      this.setCubeMapImageData(opts); // Called here so that GL.\n      // TODO - should genMipmap() be called on the cubemap or on the faces?\n\n      if (mipmaps) {\n        this.generateMipmap(opts);\n      } // Store opts for accessors\n\n\n      this.opts = opts;\n    }\n  }, {\n    key: 'subImage',\n    value: function subImage(_ref) {\n      var face = _ref.face,\n          data = _ref.data,\n          _ref$x = _ref.x,\n          x = _ref$x === undefined ? 0 : _ref$x,\n          _ref$y = _ref.y,\n          y = _ref$y === undefined ? 0 : _ref$y,\n          _ref$mipmapLevel = _ref.mipmapLevel,\n          mipmapLevel = _ref$mipmapLevel === undefined ? 0 : _ref$mipmapLevel;\n      return this._subImage({\n        target: face,\n        data: data,\n        x: x,\n        y: y,\n        mipmapLevel: mipmapLevel\n      });\n    }\n    /* eslint-disable max-statements, max-len */\n\n  }, {\n    key: 'setCubeMapImageData',\n    value: function setCubeMapImageData(_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height,\n          pixels = _ref2.pixels,\n          data = _ref2.data,\n          _ref2$border = _ref2.border,\n          border = _ref2$border === undefined ? 0 : _ref2$border,\n          _ref2$format = _ref2.format,\n          format = _ref2$format === undefined ? GL.RGBA : _ref2$format,\n          _ref2$type = _ref2.type,\n          type = _ref2$type === undefined ? GL.UNSIGNED_BYTE : _ref2$type,\n          _ref2$generateMipmap = _ref2.generateMipmap,\n          generateMipmap = _ref2$generateMipmap === undefined ? false : _ref2$generateMipmap;\n      var gl = this.gl;\n      pixels = pixels || data;\n      this.bind();\n\n      if (this.width || this.height) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = FACES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var face = _step.value;\n            gl.texImage2D(face, 0, format, width, height, border, format, type, pixels[face]);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = FACES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var _face = _step2.value;\n            gl.texImage2D(_face, 0, format, format, type, pixels[_face]);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'bind',\n    value: function bind() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          index = _ref3.index;\n\n      if (index !== undefined) {\n        this.gl.activeTexture(GL.TEXTURE0 + index);\n      }\n\n      this.gl.bindTexture(GL.TEXTURE_CUBE_MAP, this.handle);\n      return index;\n    }\n  }, {\n    key: 'unbind',\n    value: function unbind() {\n      this.gl.bindTexture(GL.TEXTURE_CUBE_MAP, null);\n      return this;\n    }\n  }]);\n\n  return TextureCube;\n}(Texture);\n\nexport default TextureCube;\nTextureCube.FACES = FACES;","map":null,"metadata":{},"sourceType":"module"}