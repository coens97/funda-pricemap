{"ast":null,"code":"/*\n** Copyright (c) 2012 The Khronos Group Inc.\n**\n** Permission is hereby granted, free of charge, to any person obtaining a\n** copy of this software and/or associated documentation files (the\n** \"Materials\"), to deal in the Materials without restriction, including\n** without limitation the rights to use, copy, modify, merge, publish,\n** distribute, sublicense, and/or sell copies of the Materials, and to\n** permit persons to whom the Materials are furnished to do so, subject to\n** the following conditions:\n**\n** The above copyright notice and this permission notice shall be included\n** in all copies or substantial portions of the Materials.\n**\n** THE MATERIALS ARE PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.\n*/\n//Ported to node by Marcin Ignac on 2016-05-20\n// Various functions for helping debug WebGL apps.\nWebGLDebugUtils = function () {\n  var window; //polyfill window in node\n\n  if (typeof window == 'undefined') {\n    window = global;\n  }\n  /**\n   * Wrapped logging function.\n   * @param {string} msg Message to log.\n   */\n\n\n  var log = function log(msg) {\n    if (window.console && window.console.log) {\n      window.console.log(msg);\n    }\n  };\n  /**\n   * Wrapped error logging function.\n   * @param {string} msg Message to log.\n   */\n\n\n  var error = function error(msg) {\n    if (window.console && window.console.error) {\n      window.console.error(msg);\n    } else {\n      log(msg);\n    }\n  };\n  /**\n   * Which arguments are enums based on the number of arguments to the function.\n   * So\n   *    'texImage2D': {\n   *       9: { 0:true, 2:true, 6:true, 7:true },\n   *       6: { 0:true, 2:true, 3:true, 4:true },\n   *    },\n   *\n   * means if there are 9 arguments then 6 and 7 are enums, if there are 6\n   * arguments 3 and 4 are enums\n   *\n   * @type {!Object.<number, !Object.<number, string>}\n   */\n\n\n  var glValidEnumContexts = {\n    // Generic setters and getters\n    'enable': {\n      1: {\n        0: true\n      }\n    },\n    'disable': {\n      1: {\n        0: true\n      }\n    },\n    'getParameter': {\n      1: {\n        0: true\n      }\n    },\n    // Rendering\n    'drawArrays': {\n      3: {\n        0: true\n      }\n    },\n    'drawElements': {\n      4: {\n        0: true,\n        2: true\n      }\n    },\n    // Shaders\n    'createShader': {\n      1: {\n        0: true\n      }\n    },\n    'getShaderParameter': {\n      2: {\n        1: true\n      }\n    },\n    'getProgramParameter': {\n      2: {\n        1: true\n      }\n    },\n    'getShaderPrecisionFormat': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    // Vertex attributes\n    'getVertexAttrib': {\n      2: {\n        1: true\n      }\n    },\n    'vertexAttribPointer': {\n      6: {\n        2: true\n      }\n    },\n    // Textures\n    'bindTexture': {\n      2: {\n        0: true\n      }\n    },\n    'activeTexture': {\n      1: {\n        0: true\n      }\n    },\n    'getTexParameter': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'texParameterf': {\n      3: {\n        0: true,\n        1: true\n      }\n    },\n    'texParameteri': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    // texImage2D and texSubImage2D are defined below with WebGL 2 entrypoints\n    'copyTexImage2D': {\n      8: {\n        0: true,\n        2: true\n      }\n    },\n    'copyTexSubImage2D': {\n      8: {\n        0: true\n      }\n    },\n    'generateMipmap': {\n      1: {\n        0: true\n      }\n    },\n    // compressedTexImage2D and compressedTexSubImage2D are defined below with WebGL 2 entrypoints\n    // Buffer objects\n    'bindBuffer': {\n      2: {\n        0: true\n      }\n    },\n    // bufferData and bufferSubData are defined below with WebGL 2 entrypoints\n    'getBufferParameter': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    // Renderbuffers and framebuffers\n    'pixelStorei': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    // readPixels is defined below with WebGL 2 entrypoints\n    'bindRenderbuffer': {\n      2: {\n        0: true\n      }\n    },\n    'bindFramebuffer': {\n      2: {\n        0: true\n      }\n    },\n    'checkFramebufferStatus': {\n      1: {\n        0: true\n      }\n    },\n    'framebufferRenderbuffer': {\n      4: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'framebufferTexture2D': {\n      5: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'getFramebufferAttachmentParameter': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'getRenderbufferParameter': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'renderbufferStorage': {\n      4: {\n        0: true,\n        1: true\n      }\n    },\n    // Frame buffer operations (clear, blend, depth test, stencil)\n    'clear': {\n      1: {\n        0: {\n          'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT']\n        }\n      }\n    },\n    'depthFunc': {\n      1: {\n        0: true\n      }\n    },\n    'blendFunc': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'blendFuncSeparate': {\n      4: {\n        0: true,\n        1: true,\n        2: true,\n        3: true\n      }\n    },\n    'blendEquation': {\n      1: {\n        0: true\n      }\n    },\n    'blendEquationSeparate': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'stencilFunc': {\n      3: {\n        0: true\n      }\n    },\n    'stencilFuncSeparate': {\n      4: {\n        0: true,\n        1: true\n      }\n    },\n    'stencilMaskSeparate': {\n      2: {\n        0: true\n      }\n    },\n    'stencilOp': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'stencilOpSeparate': {\n      4: {\n        0: true,\n        1: true,\n        2: true,\n        3: true\n      }\n    },\n    // Culling\n    'cullFace': {\n      1: {\n        0: true\n      }\n    },\n    'frontFace': {\n      1: {\n        0: true\n      }\n    },\n    // ANGLE_instanced_arrays extension\n    'drawArraysInstancedANGLE': {\n      4: {\n        0: true\n      }\n    },\n    'drawElementsInstancedANGLE': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    // EXT_blend_minmax extension\n    'blendEquationEXT': {\n      1: {\n        0: true\n      }\n    },\n    // WebGL 2 Buffer objects\n    'bufferData': {\n      3: {\n        0: true,\n        2: true\n      },\n      // WebGL 1\n      4: {\n        0: true,\n        2: true\n      },\n      // WebGL 2\n      5: {\n        0: true,\n        2: true // WebGL 2\n\n      }\n    },\n    'bufferSubData': {\n      3: {\n        0: true\n      },\n      // WebGL 1\n      4: {\n        0: true\n      },\n      // WebGL 2\n      5: {\n        0: true // WebGL 2\n\n      }\n    },\n    'copyBufferSubData': {\n      5: {\n        0: true,\n        1: true\n      }\n    },\n    'getBufferSubData': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      },\n      5: {\n        0: true\n      }\n    },\n    // WebGL 2 Framebuffer objects\n    'blitFramebuffer': {\n      10: {\n        8: {\n          'enumBitwiseOr': ['COLOR_BUFFER_BIT', 'DEPTH_BUFFER_BIT', 'STENCIL_BUFFER_BIT']\n        },\n        9: true\n      }\n    },\n    'framebufferTextureLayer': {\n      5: {\n        0: true,\n        1: true\n      }\n    },\n    'invalidateFramebuffer': {\n      2: {\n        0: true\n      }\n    },\n    'invalidateSubFramebuffer': {\n      6: {\n        0: true\n      }\n    },\n    'readBuffer': {\n      1: {\n        0: true\n      }\n    },\n    // WebGL 2 Renderbuffer objects\n    'getInternalformatParameter': {\n      3: {\n        0: true,\n        1: true,\n        2: true\n      }\n    },\n    'renderbufferStorageMultisample': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    // WebGL 2 Texture objects\n    'texStorage2D': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    'texStorage3D': {\n      6: {\n        0: true,\n        2: true\n      }\n    },\n    'texImage2D': {\n      9: {\n        0: true,\n        2: true,\n        6: true,\n        7: true\n      },\n      // WebGL 1 & 2\n      6: {\n        0: true,\n        2: true,\n        3: true,\n        4: true\n      },\n      // WebGL 1\n      10: {\n        0: true,\n        2: true,\n        6: true,\n        7: true // WebGL 2\n\n      }\n    },\n    'texImage3D': {\n      10: {\n        0: true,\n        2: true,\n        7: true,\n        8: true\n      },\n      11: {\n        0: true,\n        2: true,\n        7: true,\n        8: true\n      }\n    },\n    'texSubImage2D': {\n      9: {\n        0: true,\n        6: true,\n        7: true\n      },\n      // WebGL 1 & 2\n      7: {\n        0: true,\n        4: true,\n        5: true\n      },\n      // WebGL 1\n      10: {\n        0: true,\n        6: true,\n        7: true // WebGL 2\n\n      }\n    },\n    'texSubImage3D': {\n      11: {\n        0: true,\n        8: true,\n        9: true\n      },\n      12: {\n        0: true,\n        8: true,\n        9: true\n      }\n    },\n    'copyTexSubImage3D': {\n      9: {\n        0: true\n      }\n    },\n    'compressedTexImage2D': {\n      7: {\n        0: true,\n        2: true\n      },\n      // WebGL 1 & 2\n      8: {\n        0: true,\n        2: true\n      },\n      // WebGL 2\n      9: {\n        0: true,\n        2: true // WebGL 2\n\n      }\n    },\n    'compressedTexImage3D': {\n      8: {\n        0: true,\n        2: true\n      },\n      9: {\n        0: true,\n        2: true\n      },\n      10: {\n        0: true,\n        2: true\n      }\n    },\n    'compressedTexSubImage2D': {\n      8: {\n        0: true,\n        6: true\n      },\n      // WebGL 1 & 2\n      9: {\n        0: true,\n        6: true\n      },\n      // WebGL 2\n      10: {\n        0: true,\n        6: true // WebGL 2\n\n      }\n    },\n    'compressedTexSubImage3D': {\n      10: {\n        0: true,\n        8: true\n      },\n      11: {\n        0: true,\n        8: true\n      },\n      12: {\n        0: true,\n        8: true\n      }\n    },\n    // WebGL 2 Vertex attribs\n    'vertexAttribIPointer': {\n      5: {\n        2: true\n      }\n    },\n    // WebGL 2 Writing to the drawing buffer\n    'drawArraysInstanced': {\n      4: {\n        0: true\n      }\n    },\n    'drawElementsInstanced': {\n      5: {\n        0: true,\n        2: true\n      }\n    },\n    'drawRangeElements': {\n      6: {\n        0: true,\n        4: true\n      }\n    },\n    // WebGL 2 Reading back pixels\n    'readPixels': {\n      7: {\n        4: true,\n        5: true\n      },\n      // WebGL 1 & 2\n      8: {\n        4: true,\n        5: true // WebGL 2\n\n      }\n    },\n    // WebGL 2 Multiple Render Targets\n    'clearBufferfv': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      }\n    },\n    'clearBufferiv': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      }\n    },\n    'clearBufferuiv': {\n      3: {\n        0: true\n      },\n      4: {\n        0: true\n      }\n    },\n    'clearBufferfi': {\n      4: {\n        0: true\n      }\n    },\n    // WebGL 2 Query objects\n    'beginQuery': {\n      2: {\n        0: true\n      }\n    },\n    'endQuery': {\n      1: {\n        0: true\n      }\n    },\n    'getQuery': {\n      2: {\n        0: true,\n        1: true\n      }\n    },\n    'getQueryParameter': {\n      2: {\n        1: true\n      }\n    },\n    // WebGL 2 Sampler objects\n    'samplerParameteri': {\n      3: {\n        1: true,\n        2: true\n      }\n    },\n    'samplerParameterf': {\n      3: {\n        1: true\n      }\n    },\n    'getSamplerParameter': {\n      2: {\n        1: true\n      }\n    },\n    // WebGL 2 Sync objects\n    'fenceSync': {\n      2: {\n        0: true,\n        1: {\n          'enumBitwiseOr': []\n        }\n      }\n    },\n    'clientWaitSync': {\n      3: {\n        1: {\n          'enumBitwiseOr': ['SYNC_FLUSH_COMMANDS_BIT']\n        }\n      }\n    },\n    'waitSync': {\n      3: {\n        1: {\n          'enumBitwiseOr': []\n        }\n      }\n    },\n    'getSyncParameter': {\n      2: {\n        1: true\n      }\n    },\n    // WebGL 2 Transform Feedback\n    'bindTransformFeedback': {\n      2: {\n        0: true\n      }\n    },\n    'beginTransformFeedback': {\n      1: {\n        0: true\n      }\n    },\n    'transformFeedbackVaryings': {\n      3: {\n        2: true\n      }\n    },\n    // WebGL2 Uniform Buffer Objects and Transform Feedback Buffers\n    'bindBufferBase': {\n      3: {\n        0: true\n      }\n    },\n    'bindBufferRange': {\n      5: {\n        0: true\n      }\n    },\n    'getIndexedParameter': {\n      2: {\n        0: true\n      }\n    },\n    'getActiveUniforms': {\n      3: {\n        2: true\n      }\n    },\n    'getActiveUniformBlockParameter': {\n      3: {\n        2: true\n      }\n    }\n  };\n  /**\n   * Map of numbers to names.\n   * @type {Object}\n   */\n\n  var glEnums = null;\n  /**\n   * Map of names to numbers.\n   * @type {Object}\n   */\n\n  var enumStringToValue = null;\n  /**\n   * Initializes this module. Safe to call more than once.\n   * @param {!WebGLRenderingContext} ctx A WebGL context. If\n   *    you have more than one context it doesn't matter which one\n   *    you pass in, it is only used to pull out constants.\n   */\n\n  function init(ctx) {\n    if (glEnums == null) {\n      glEnums = {};\n      enumStringToValue = {};\n\n      for (var propertyName in ctx) {\n        if (typeof ctx[propertyName] == 'number') {\n          glEnums[ctx[propertyName]] = propertyName;\n          enumStringToValue[propertyName] = ctx[propertyName];\n        }\n      }\n    }\n  }\n  /**\n   * Checks the utils have been initialized.\n   */\n\n\n  function checkInit() {\n    if (glEnums == null) {\n      throw 'WebGLDebugUtils.init(ctx) not called';\n    }\n  }\n  /**\n   * Returns true or false if value matches any WebGL enum\n   * @param {*} value Value to check if it might be an enum.\n   * @return {boolean} True if value matches one of the WebGL defined enums\n   */\n\n\n  function mightBeEnum(value) {\n    checkInit();\n    return glEnums[value] !== undefined;\n  }\n  /**\n   * Gets an string version of an WebGL enum.\n   *\n   * Example:\n   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n   *\n   * @param {number} value Value to return an enum for\n   * @return {string} The string version of the enum.\n   */\n\n\n  function glEnumToString(value) {\n    checkInit();\n    var name = glEnums[value];\n    return name !== undefined ? \"gl.\" + name : \"/*UNKNOWN WebGL ENUM*/ 0x\" + value.toString(16) + \"\";\n  }\n  /**\n   * Returns the string version of a WebGL argument.\n   * Attempts to convert enum arguments to strings.\n   * @param {string} functionName the name of the WebGL function.\n   * @param {number} numArgs the number of arguments passed to the function.\n   * @param {number} argumentIndx the index of the argument.\n   * @param {*} value The value of the argument.\n   * @return {string} The value as a string.\n   */\n\n\n  function glFunctionArgToString(functionName, numArgs, argumentIndex, value) {\n    var funcInfo = glValidEnumContexts[functionName];\n\n    if (funcInfo !== undefined) {\n      var funcInfo = funcInfo[numArgs];\n\n      if (funcInfo !== undefined) {\n        if (funcInfo[argumentIndex]) {\n          if (typeof funcInfo[argumentIndex] === 'object' && funcInfo[argumentIndex]['enumBitwiseOr'] !== undefined) {\n            var enums = funcInfo[argumentIndex]['enumBitwiseOr'];\n            var orResult = 0;\n            var orEnums = [];\n\n            for (var i = 0; i < enums.length; ++i) {\n              var enumValue = enumStringToValue[enums[i]];\n\n              if ((value & enumValue) !== 0) {\n                orResult |= enumValue;\n                orEnums.push(glEnumToString(enumValue));\n              }\n            }\n\n            if (orResult === value) {\n              return orEnums.join(' | ');\n            } else {\n              return glEnumToString(value);\n            }\n          } else {\n            return glEnumToString(value);\n          }\n        }\n      }\n    }\n\n    if (value === null) {\n      return \"null\";\n    } else if (value === undefined) {\n      return \"undefined\";\n    } else {\n      return value.toString();\n    }\n  }\n  /**\n   * Converts the arguments of a WebGL function to a string.\n   * Attempts to convert enum arguments to strings.\n   *\n   * @param {string} functionName the name of the WebGL function.\n   * @param {number} args The arguments.\n   * @return {string} The arguments as a string.\n   */\n\n\n  function glFunctionArgsToString(functionName, args) {\n    // apparently we can't do args.join(\",\");\n    var argStr = \"\";\n    var numArgs = args.length;\n\n    for (var ii = 0; ii < numArgs; ++ii) {\n      argStr += (ii == 0 ? '' : ', ') + glFunctionArgToString(functionName, numArgs, ii, args[ii]);\n    }\n\n    return argStr;\n  }\n\n  ;\n\n  function makePropertyWrapper(wrapper, original, propertyName) {\n    //log(\"wrap prop: \" + propertyName);\n    wrapper.__defineGetter__(propertyName, function () {\n      return original[propertyName];\n    }); // TODO(gmane): this needs to handle properties that take more than\n    // one value?\n\n\n    wrapper.__defineSetter__(propertyName, function (value) {\n      //log(\"set: \" + propertyName);\n      original[propertyName] = value;\n    });\n  } // Makes a function that calls a function on another object.\n\n\n  function makeFunctionWrapper(original, functionName) {\n    //log(\"wrap fn: \" + functionName);\n    var f = original[functionName];\n    return function () {\n      //log(\"call: \" + functionName);\n      var result = f.apply(original, arguments);\n      return result;\n    };\n  }\n  /**\n   * Given a WebGL context returns a wrapped context that calls\n   * gl.getError after every command and calls a function if the\n   * result is not gl.NO_ERROR.\n   *\n   * @param {!WebGLRenderingContext} ctx The webgl context to\n   *        wrap.\n   * @param {!function(err, funcName, args): void} opt_onErrorFunc\n   *        The function to call when gl.getError returns an\n   *        error. If not specified the default function calls\n   *        console.log with a message.\n   * @param {!function(funcName, args): void} opt_onFunc The\n   *        function to call when each webgl function is called.\n   *        You can use this to log all calls for example.\n   * @param {!WebGLRenderingContext} opt_err_ctx The webgl context\n   *        to call getError on if different than ctx.\n   */\n\n\n  function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc, opt_err_ctx) {\n    opt_err_ctx = opt_err_ctx || ctx;\n    init(ctx);\n\n    opt_onErrorFunc = opt_onErrorFunc || function (err, functionName, args) {\n      // apparently we can't do args.join(\",\");\n      var argStr = \"\";\n      var numArgs = args.length;\n\n      for (var ii = 0; ii < numArgs; ++ii) {\n        argStr += (ii == 0 ? '' : ', ') + glFunctionArgToString(functionName, numArgs, ii, args[ii]);\n      }\n\n      error(\"WebGL error \" + glEnumToString(err) + \" in \" + functionName + \"(\" + argStr + \")\");\n    }; // Holds booleans for each GL error so after we get the error ourselves\n    // we can still return it to the client app.\n\n\n    var glErrorShadow = {}; // Makes a function that calls a WebGL function and then calls getError.\n\n    function makeErrorWrapper(ctx, functionName) {\n      return function () {\n        if (opt_onFunc) {\n          opt_onFunc(functionName, arguments);\n        }\n\n        var result = ctx[functionName].apply(ctx, arguments);\n        var err = opt_err_ctx.getError();\n\n        if (err != 0) {\n          glErrorShadow[err] = true;\n          opt_onErrorFunc(err, functionName, arguments);\n        }\n\n        return result;\n      };\n    } // Make a an object that has a copy of every property of the WebGL context\n    // but wraps all functions.\n\n\n    var wrapper = {};\n\n    for (var propertyName in ctx) {\n      if (typeof ctx[propertyName] == 'function') {\n        if (propertyName != 'getExtension') {\n          wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);\n        } else {\n          var wrapped = makeErrorWrapper(ctx, propertyName);\n\n          wrapper[propertyName] = function () {\n            var result = wrapped.apply(ctx, arguments);\n\n            if (!result) {\n              return null;\n            }\n\n            return makeDebugContext(result, opt_onErrorFunc, opt_onFunc, opt_err_ctx);\n          };\n        }\n      } else {\n        makePropertyWrapper(wrapper, ctx, propertyName);\n      }\n    } // Override the getError function with one that returns our saved results.\n\n\n    wrapper.getError = function () {\n      for (var err in glErrorShadow) {\n        if (glErrorShadow.hasOwnProperty(err)) {\n          if (glErrorShadow[err]) {\n            glErrorShadow[err] = false;\n            return err;\n          }\n        }\n      }\n\n      return ctx.NO_ERROR;\n    };\n\n    return wrapper;\n  }\n\n  function resetToInitialState(ctx) {\n    var isWebGL2RenderingContext = !!ctx.createTransformFeedback;\n\n    if (isWebGL2RenderingContext) {\n      ctx.bindVertexArray(null);\n    }\n\n    var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);\n    var tmp = ctx.createBuffer();\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);\n\n    for (var ii = 0; ii < numAttribs; ++ii) {\n      ctx.disableVertexAttribArray(ii);\n      ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);\n      ctx.vertexAttrib1f(ii, 0);\n\n      if (isWebGL2RenderingContext) {\n        ctx.vertexAttribDivisor(ii, 0);\n      }\n    }\n\n    ctx.deleteBuffer(tmp);\n    var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);\n\n    for (var ii = 0; ii < numTextureUnits; ++ii) {\n      ctx.activeTexture(ctx.TEXTURE0 + ii);\n      ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);\n      ctx.bindTexture(ctx.TEXTURE_2D, null);\n\n      if (isWebGL2RenderingContext) {\n        ctx.bindTexture(ctx.TEXTURE_2D_ARRAY, null);\n        ctx.bindTexture(ctx.TEXTURE_3D, null);\n        ctx.bindSampler(ii, null);\n      }\n    }\n\n    ctx.activeTexture(ctx.TEXTURE0);\n    ctx.useProgram(null);\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);\n    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);\n    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n    ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\n    ctx.disable(ctx.BLEND);\n    ctx.disable(ctx.CULL_FACE);\n    ctx.disable(ctx.DEPTH_TEST);\n    ctx.disable(ctx.DITHER);\n    ctx.disable(ctx.SCISSOR_TEST);\n    ctx.blendColor(0, 0, 0, 0);\n    ctx.blendEquation(ctx.FUNC_ADD);\n    ctx.blendFunc(ctx.ONE, ctx.ZERO);\n    ctx.clearColor(0, 0, 0, 0);\n    ctx.clearDepth(1);\n    ctx.clearStencil(-1);\n    ctx.colorMask(true, true, true, true);\n    ctx.cullFace(ctx.BACK);\n    ctx.depthFunc(ctx.LESS);\n    ctx.depthMask(true);\n    ctx.depthRange(0, 1);\n    ctx.frontFace(ctx.CCW);\n    ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);\n    ctx.lineWidth(1);\n    ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);\n    ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);\n    ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);\n    ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false); // TODO: Delete this IF.\n\n    if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\n      ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);\n    }\n\n    ctx.polygonOffset(0, 0);\n    ctx.sampleCoverage(1, false);\n    ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);\n    ctx.stencilMask(0xFFFFFFFF);\n    ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);\n    ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);\n\n    if (isWebGL2RenderingContext) {\n      ctx.drawBuffers([ctx.BACK]);\n      ctx.readBuffer(ctx.BACK);\n      ctx.bindBuffer(ctx.COPY_READ_BUFFER, null);\n      ctx.bindBuffer(ctx.COPY_WRITE_BUFFER, null);\n      ctx.bindBuffer(ctx.PIXEL_PACK_BUFFER, null);\n      ctx.bindBuffer(ctx.PIXEL_UNPACK_BUFFER, null);\n      var numTransformFeedbacks = ctx.getParameter(ctx.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS);\n\n      for (var ii = 0; ii < numTransformFeedbacks; ++ii) {\n        ctx.bindBufferBase(ctx.TRANSFORM_FEEDBACK_BUFFER, ii, null);\n      }\n\n      var numUBOs = ctx.getParameter(ctx.MAX_UNIFORM_BUFFER_BINDINGS);\n\n      for (var ii = 0; ii < numUBOs; ++ii) {\n        ctx.bindBufferBase(ctx.UNIFORM_BUFFER, ii, null);\n      }\n\n      ctx.disable(ctx.RASTERIZER_DISCARD);\n      ctx.pixelStorei(ctx.UNPACK_IMAGE_HEIGHT, 0);\n      ctx.pixelStorei(ctx.UNPACK_SKIP_IMAGES, 0);\n      ctx.pixelStorei(ctx.UNPACK_ROW_LENGTH, 0);\n      ctx.pixelStorei(ctx.UNPACK_SKIP_ROWS, 0);\n      ctx.pixelStorei(ctx.UNPACK_SKIP_PIXELS, 0);\n      ctx.pixelStorei(ctx.PACK_ROW_LENGTH, 0);\n      ctx.pixelStorei(ctx.PACK_SKIP_ROWS, 0);\n      ctx.pixelStorei(ctx.PACK_SKIP_PIXELS, 0);\n      ctx.hint(ctx.FRAGMENT_SHADER_DERIVATIVE_HINT, ctx.DONT_CARE);\n    } // TODO: This should NOT be needed but Firefox fails with 'hint'\n\n\n    while (ctx.getError()) {\n      ;\n    }\n  }\n\n  function makeLostContextSimulatingCanvas(canvas) {\n    var unwrappedContext_;\n    var wrappedContext_;\n    var onLost_ = [];\n    var onRestored_ = [];\n    var wrappedContext_ = {};\n    var contextId_ = 1;\n    var contextLost_ = false;\n    var resourceId_ = 0;\n    var resourceDb_ = [];\n    var numCallsToLoseContext_ = 0;\n    var numCalls_ = 0;\n    var canRestore_ = false;\n    var restoreTimeout_ = 0;\n    var isWebGL2RenderingContext; // Holds booleans for each GL error so can simulate errors.\n\n    var glErrorShadow_ = {};\n\n    canvas.getContext = function (f) {\n      return function () {\n        var ctx = f.apply(canvas, arguments); // Did we get a context and is it a WebGL context?\n\n        if (ctx instanceof WebGLRenderingContext || window.WebGL2RenderingContext && ctx instanceof WebGL2RenderingContext) {\n          if (ctx != unwrappedContext_) {\n            if (unwrappedContext_) {\n              throw \"got different context\";\n            }\n\n            isWebGL2RenderingContext = window.WebGL2RenderingContext && ctx instanceof WebGL2RenderingContext;\n            unwrappedContext_ = ctx;\n            wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);\n          }\n\n          return wrappedContext_;\n        }\n\n        return ctx;\n      };\n    }(canvas.getContext);\n\n    function wrapEvent(listener) {\n      if (typeof listener == \"function\") {\n        return listener;\n      } else {\n        return function (info) {\n          listener.handleEvent(info);\n        };\n      }\n    }\n\n    var addOnContextLostListener = function addOnContextLostListener(listener) {\n      onLost_.push(wrapEvent(listener));\n    };\n\n    var addOnContextRestoredListener = function addOnContextRestoredListener(listener) {\n      onRestored_.push(wrapEvent(listener));\n    };\n\n    function wrapAddEventListener(canvas) {\n      var f = canvas.addEventListener;\n\n      canvas.addEventListener = function (type, listener, bubble) {\n        switch (type) {\n          case 'webglcontextlost':\n            addOnContextLostListener(listener);\n            break;\n\n          case 'webglcontextrestored':\n            addOnContextRestoredListener(listener);\n            break;\n\n          default:\n            f.apply(canvas, arguments);\n        }\n      };\n    }\n\n    wrapAddEventListener(canvas);\n\n    canvas.loseContext = function () {\n      if (!contextLost_) {\n        contextLost_ = true;\n        numCallsToLoseContext_ = 0;\n        ++contextId_;\n\n        while (unwrappedContext_.getError()) {\n          ;\n        }\n\n        clearErrors();\n        glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;\n        var event = makeWebGLContextEvent(\"context lost\");\n        var callbacks = onLost_.slice();\n        setTimeout(function () {\n          //log(\"numCallbacks:\" + callbacks.length);\n          for (var ii = 0; ii < callbacks.length; ++ii) {\n            //log(\"calling callback:\" + ii);\n            callbacks[ii](event);\n          }\n\n          if (restoreTimeout_ >= 0) {\n            setTimeout(function () {\n              canvas.restoreContext();\n            }, restoreTimeout_);\n          }\n        }, 0);\n      }\n    };\n\n    canvas.restoreContext = function () {\n      if (contextLost_) {\n        if (onRestored_.length) {\n          setTimeout(function () {\n            if (!canRestore_) {\n              throw \"can not restore. webglcontestlost listener did not call event.preventDefault\";\n            }\n\n            freeResources();\n            resetToInitialState(unwrappedContext_);\n            contextLost_ = false;\n            numCalls_ = 0;\n            canRestore_ = false;\n            var callbacks = onRestored_.slice();\n            var event = makeWebGLContextEvent(\"context restored\");\n\n            for (var ii = 0; ii < callbacks.length; ++ii) {\n              callbacks[ii](event);\n            }\n          }, 0);\n        }\n      }\n    };\n\n    canvas.loseContextInNCalls = function (numCalls) {\n      if (contextLost_) {\n        throw \"You can not ask a lost contet to be lost\";\n      }\n\n      numCallsToLoseContext_ = numCalls_ + numCalls;\n    };\n\n    canvas.getNumCalls = function () {\n      return numCalls_;\n    };\n\n    canvas.setRestoreTimeout = function (timeout) {\n      restoreTimeout_ = timeout;\n    };\n\n    function isWebGLObject(obj) {\n      //return false;\n      return obj instanceof WebGLBuffer || obj instanceof WebGLFramebuffer || obj instanceof WebGLProgram || obj instanceof WebGLRenderbuffer || obj instanceof WebGLShader || obj instanceof WebGLTexture;\n    }\n\n    function checkResources(args) {\n      for (var ii = 0; ii < args.length; ++ii) {\n        var arg = args[ii];\n\n        if (isWebGLObject(arg)) {\n          return arg.__webglDebugContextLostId__ == contextId_;\n        }\n      }\n\n      return true;\n    }\n\n    function clearErrors() {\n      var k = Object.keys(glErrorShadow_);\n\n      for (var ii = 0; ii < k.length; ++ii) {\n        delete glErrorShadow_[k[ii]];\n      }\n    }\n\n    function loseContextIfTime() {\n      ++numCalls_;\n\n      if (!contextLost_) {\n        if (numCallsToLoseContext_ == numCalls_) {\n          canvas.loseContext();\n        }\n      }\n    } // Makes a function that simulates WebGL when out of context.\n\n\n    function makeLostContextFunctionWrapper(ctx, functionName) {\n      var f = ctx[functionName];\n      return function () {\n        // log(\"calling:\" + functionName);\n        // Only call the functions if the context is not lost.\n        loseContextIfTime();\n\n        if (!contextLost_) {\n          //if (!checkResources(arguments)) {\n          //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;\n          //  return;\n          //}\n          var result = f.apply(ctx, arguments);\n          return result;\n        }\n      };\n    }\n\n    function freeResources() {\n      for (var ii = 0; ii < resourceDb_.length; ++ii) {\n        var resource = resourceDb_[ii];\n\n        if (resource instanceof WebGLBuffer) {\n          unwrappedContext_.deleteBuffer(resource);\n        } else if (resource instanceof WebGLFramebuffer) {\n          unwrappedContext_.deleteFramebuffer(resource);\n        } else if (resource instanceof WebGLProgram) {\n          unwrappedContext_.deleteProgram(resource);\n        } else if (resource instanceof WebGLRenderbuffer) {\n          unwrappedContext_.deleteRenderbuffer(resource);\n        } else if (resource instanceof WebGLShader) {\n          unwrappedContext_.deleteShader(resource);\n        } else if (resource instanceof WebGLTexture) {\n          unwrappedContext_.deleteTexture(resource);\n        } else if (isWebGL2RenderingContext) {\n          if (resource instanceof WebGLQuery) {\n            unwrappedContext_.deleteQuery(resource);\n          } else if (resource instanceof WebGLSampler) {\n            unwrappedContext_.deleteSampler(resource);\n          } else if (resource instanceof WebGLSync) {\n            unwrappedContext_.deleteSync(resource);\n          } else if (resource instanceof WebGLTransformFeedback) {\n            unwrappedContext_.deleteTransformFeedback(resource);\n          } else if (resource instanceof WebGLVertexArrayObject) {\n            unwrappedContext_.deleteVertexArray(resource);\n          }\n        }\n      }\n    }\n\n    function makeWebGLContextEvent(statusMessage) {\n      return {\n        statusMessage: statusMessage,\n        preventDefault: function preventDefault() {\n          canRestore_ = true;\n        }\n      };\n    }\n\n    return canvas;\n\n    function makeLostContextSimulatingContext(ctx) {\n      // copy all functions and properties to wrapper\n      for (var propertyName in ctx) {\n        if (typeof ctx[propertyName] == 'function') {\n          wrappedContext_[propertyName] = makeLostContextFunctionWrapper(ctx, propertyName);\n        } else {\n          makePropertyWrapper(wrappedContext_, ctx, propertyName);\n        }\n      } // Wrap a few functions specially.\n\n\n      wrappedContext_.getError = function () {\n        loseContextIfTime();\n\n        if (!contextLost_) {\n          var err;\n\n          while (err = unwrappedContext_.getError()) {\n            glErrorShadow_[err] = true;\n          }\n        }\n\n        for (var err in glErrorShadow_) {\n          if (glErrorShadow_[err]) {\n            delete glErrorShadow_[err];\n            return err;\n          }\n        }\n\n        return wrappedContext_.NO_ERROR;\n      };\n\n      var creationFunctions = [\"createBuffer\", \"createFramebuffer\", \"createProgram\", \"createRenderbuffer\", \"createShader\", \"createTexture\"];\n\n      if (isWebGL2RenderingContext) {\n        creationFunctions.push(\"createQuery\", \"createSampler\", \"fenceSync\", \"createTransformFeedback\", \"createVertexArray\");\n      }\n\n      for (var ii = 0; ii < creationFunctions.length; ++ii) {\n        var functionName = creationFunctions[ii];\n\n        wrappedContext_[functionName] = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return null;\n            }\n\n            var obj = f.apply(ctx, arguments);\n            obj.__webglDebugContextLostId__ = contextId_;\n            resourceDb_.push(obj);\n            return obj;\n          };\n        }(ctx[functionName]);\n      }\n\n      var functionsThatShouldReturnNull = [\"getActiveAttrib\", \"getActiveUniform\", \"getBufferParameter\", \"getContextAttributes\", \"getAttachedShaders\", \"getFramebufferAttachmentParameter\", \"getParameter\", \"getProgramParameter\", \"getProgramInfoLog\", \"getRenderbufferParameter\", \"getShaderParameter\", \"getShaderInfoLog\", \"getShaderSource\", \"getTexParameter\", \"getUniform\", \"getUniformLocation\", \"getVertexAttrib\"];\n\n      if (isWebGL2RenderingContext) {\n        functionsThatShouldReturnNull.push(\"getInternalformatParameter\", \"getQuery\", \"getQueryParameter\", \"getSamplerParameter\", \"getSyncParameter\", \"getTransformFeedbackVarying\", \"getIndexedParameter\", \"getUniformIndices\", \"getActiveUniforms\", \"getActiveUniformBlockParameter\", \"getActiveUniformBlockName\");\n      }\n\n      for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {\n        var functionName = functionsThatShouldReturnNull[ii];\n\n        wrappedContext_[functionName] = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return null;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_[functionName]);\n      }\n\n      var isFunctions = [\"isBuffer\", \"isEnabled\", \"isFramebuffer\", \"isProgram\", \"isRenderbuffer\", \"isShader\", \"isTexture\"];\n\n      if (isWebGL2RenderingContext) {\n        isFunctions.push(\"isQuery\", \"isSampler\", \"isSync\", \"isTransformFeedback\", \"isVertexArray\");\n      }\n\n      for (var ii = 0; ii < isFunctions.length; ++ii) {\n        var functionName = isFunctions[ii];\n\n        wrappedContext_[functionName] = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return false;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_[functionName]);\n      }\n\n      wrappedContext_.checkFramebufferStatus = function (f) {\n        return function () {\n          loseContextIfTime();\n\n          if (contextLost_) {\n            return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;\n          }\n\n          return f.apply(ctx, arguments);\n        };\n      }(wrappedContext_.checkFramebufferStatus);\n\n      wrappedContext_.getAttribLocation = function (f) {\n        return function () {\n          loseContextIfTime();\n\n          if (contextLost_) {\n            return -1;\n          }\n\n          return f.apply(ctx, arguments);\n        };\n      }(wrappedContext_.getAttribLocation);\n\n      wrappedContext_.getVertexAttribOffset = function (f) {\n        return function () {\n          loseContextIfTime();\n\n          if (contextLost_) {\n            return 0;\n          }\n\n          return f.apply(ctx, arguments);\n        };\n      }(wrappedContext_.getVertexAttribOffset);\n\n      wrappedContext_.isContextLost = function () {\n        return contextLost_;\n      };\n\n      if (isWebGL2RenderingContext) {\n        wrappedContext_.getFragDataLocation = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return -1;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.getFragDataLocation);\n\n        wrappedContext_.clientWaitSync = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return wrappedContext_.WAIT_FAILED;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.clientWaitSync);\n\n        wrappedContext_.getUniformBlockIndex = function (f) {\n          return function () {\n            loseContextIfTime();\n\n            if (contextLost_) {\n              return wrappedContext_.INVALID_INDEX;\n            }\n\n            return f.apply(ctx, arguments);\n          };\n        }(wrappedContext_.getUniformBlockIndex);\n      }\n\n      return wrappedContext_;\n    }\n  }\n\n  return {\n    /**\n     * Initializes this module. Safe to call more than once.\n     * @param {!WebGLRenderingContext} ctx A WebGL context. If\n     *    you have more than one context it doesn't matter which one\n     *    you pass in, it is only used to pull out constants.\n     */\n    'init': init,\n\n    /**\n     * Returns true or false if value matches any WebGL enum\n     * @param {*} value Value to check if it might be an enum.\n     * @return {boolean} True if value matches one of the WebGL defined enums\n     */\n    'mightBeEnum': mightBeEnum,\n\n    /**\n     * Gets an string version of an WebGL enum.\n     *\n     * Example:\n     *   WebGLDebugUtil.init(ctx);\n     *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\n     *\n     * @param {number} value Value to return an enum for\n     * @return {string} The string version of the enum.\n     */\n    'glEnumToString': glEnumToString,\n\n    /**\n     * Converts the argument of a WebGL function to a string.\n     * Attempts to convert enum arguments to strings.\n     *\n     * Example:\n     *   WebGLDebugUtil.init(ctx);\n     *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 2, 0, gl.TEXTURE_2D);\n     *\n     * would return 'TEXTURE_2D'\n     *\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} numArgs The number of arguments\n     * @param {number} argumentIndx the index of the argument.\n     * @param {*} value The value of the argument.\n     * @return {string} The value as a string.\n     */\n    'glFunctionArgToString': glFunctionArgToString,\n\n    /**\n     * Converts the arguments of a WebGL function to a string.\n     * Attempts to convert enum arguments to strings.\n     *\n     * @param {string} functionName the name of the WebGL function.\n     * @param {number} args The arguments.\n     * @return {string} The arguments as a string.\n     */\n    'glFunctionArgsToString': glFunctionArgsToString,\n\n    /**\n     * Given a WebGL context returns a wrapped context that calls\n     * gl.getError after every command and calls a function if the\n     * result is not NO_ERROR.\n     *\n     * You can supply your own function if you want. For example, if you'd like\n     * an exception thrown on any GL error you could do this\n     *\n     *    function throwOnGLError(err, funcName, args) {\n     *      throw WebGLDebugUtils.glEnumToString(err) +\n     *            \" was caused by call to \" + funcName;\n     *    };\n     *\n     *    ctx = WebGLDebugUtils.makeDebugContext(\n     *        canvas.getContext(\"webgl\"), throwOnGLError);\n     *\n     * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\n     * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\n     *     to call when gl.getError returns an error. If not specified the default\n     *     function calls console.log with a message.\n     * @param {!function(funcName, args): void} opt_onFunc The\n     *     function to call when each webgl function is called. You\n     *     can use this to log all calls for example.\n     */\n    'makeDebugContext': makeDebugContext,\n\n    /**\n     * Given a canvas element returns a wrapped canvas element that will\n     * simulate lost context. The canvas returned adds the following functions.\n     *\n     * loseContext:\n     *   simulates a lost context event.\n     *\n     * restoreContext:\n     *   simulates the context being restored.\n     *\n     * lostContextInNCalls:\n     *   loses the context after N gl calls.\n     *\n     * getNumCalls:\n     *   tells you how many gl calls there have been so far.\n     *\n     * setRestoreTimeout:\n     *   sets the number of milliseconds until the context is restored\n     *   after it has been lost. Defaults to 0. Pass -1 to prevent\n     *   automatic restoring.\n     *\n     * @param {!Canvas} canvas The canvas element to wrap.\n     */\n    'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,\n\n    /**\n     * Resets a context to the initial state.\n     * @param {!WebGLRenderingContext} ctx The webgl context to\n     *     reset.\n     */\n    'resetToInitialState': resetToInitialState\n  };\n}();\n\nmodule.exports = WebGLDebugUtils;","map":null,"metadata":{},"sourceType":"script"}