{"ast":null,"code":"import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\"; // // import assert from 'assert'; // TODO\n\nvar TYPE_DEFINITIONS = {\n  boolean: {\n    validate: function validate(value, propType) {\n      return true;\n    }\n  },\n  number: {\n    validateType: function validateType(value, propType) {\n      return 'value' in propType && (!('max' in propType) || Number.isFinite(propType.max)) && (!('min' in propType) || Number.isFinite(propType.min));\n    },\n    validate: function validate(value, propType) {\n      return Number.isFinite(value) && (!('max' in propType) || value <= propType.max) && (!('min' in propType) || value >= propType.min);\n    }\n  }\n};\nexport function parsePropTypes(propDefs) {\n  var propTypes = {};\n  var defaultProps = {};\n\n  var _arr = Object.entries(propDefs);\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var _arr$_i = _slicedToArray(_arr[_i], 2),\n        propName = _arr$_i[0],\n        propDef = _arr$_i[1];\n\n    var propType = parsePropType(propName, propDef);\n    propTypes[propName] = propType;\n    defaultProps[propName] = propType.value;\n  }\n\n  return {\n    propTypes: propTypes,\n    defaultProps: defaultProps\n  };\n} // Parses one property definition entry. Either contains:\n// * a valid prop type object ({type, ...})\n// * or just a default value, in which case type and name inference is used\n\nfunction parsePropType(name, propDef) {\n  switch (getTypeOf(propDef)) {\n    case 'object':\n      propDef = normalizePropType(name, propDef);\n      return parsePropDefinition(propDef);\n\n    case 'array':\n      return guessArrayType(name, propDef);\n\n    case 'boolean':\n      return {\n        name: name,\n        type: 'boolean',\n        value: propDef\n      };\n\n    case 'number':\n      return guessNumberType(name, propDef);\n\n    case 'function':\n      return {\n        name: name,\n        type: 'function',\n        value: propDef\n      };\n    // return guessFunctionType(name, propDef);\n\n    default:\n      return {\n        name: name,\n        type: 'unknown',\n        value: propDef\n      };\n  }\n}\n\nfunction guessArrayType(name, array) {\n  if (/color/i.test(name) && (array.length === 3 || array.length === 4)) {\n    return {\n      name: name,\n      type: 'color',\n      value: array\n    };\n  }\n\n  return {\n    name: name,\n    type: 'array',\n    value: array\n  };\n}\n\nfunction normalizePropType(name, propDef) {\n  if (!('type' in propDef)) {\n    if (!('value' in propDef)) {\n      // If no type and value this object is likely the value\n      return {\n        name: name,\n        type: 'object',\n        value: propDef\n      };\n    }\n\n    return Object.assign({\n      name: name,\n      type: getTypeOf(propDef.value)\n    }, propDef);\n  }\n\n  return Object.assign({\n    name: name\n  }, propDef);\n}\n\nfunction parsePropDefinition(propDef) {\n  var type = propDef.type;\n  var typeDefinition = TYPE_DEFINITIONS[type] || {};\n  var typeValidator = typeDefinition.typeValidator;\n\n  if (typeValidator) {// assert(typeValidator(propDef), 'Illegal prop type');\n  }\n\n  return propDef;\n}\n\nfunction guessNumberType(name, value) {\n  var isKnownProp = /radius|scale|width|height|pixel|size|miter/i.test(name) && /^((?!scale).)*$/.test(name);\n  var max = isKnownProp ? 100 : 1;\n  var min = 0;\n  return {\n    name: name,\n    type: 'number',\n    max: Math.max(value, max),\n    min: Math.min(value, min),\n    value: value\n  };\n} // improved version of javascript typeof that can distinguish arrays and null values\n\n\nfunction getTypeOf(value) {\n  if (Array.isArray(value) || ArrayBuffer.isView(value)) {\n    return 'array';\n  }\n\n  if (value === null) {\n    return 'null';\n  }\n\n  return _typeof(value);\n}","map":null,"metadata":{},"sourceType":"module"}