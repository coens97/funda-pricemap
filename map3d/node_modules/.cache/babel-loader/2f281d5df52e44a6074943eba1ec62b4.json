{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PICKING_RES = exports.MAX_POINT_LIGHTS = exports.MAX_TEXTURES = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _math = require('../packages/math');\n\nvar _utils = require('../utils');\n\nvar _group = require('../core/group');\n\nvar _group2 = _interopRequireDefault(_group);\n\nvar _pickModels2 = require('../core/pick-models');\n\nvar _pickModels3 = _interopRequireDefault(_pickModels2);\n\nvar _assert = require('assert');\n\nvar _assert2 = _interopRequireDefault(_assert);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // Scene Object management and rendering\n\n/* eslint-disable max-statements, no-try-catch */\n\n\nvar MAX_TEXTURES = exports.MAX_TEXTURES = 10;\nvar MAX_POINT_LIGHTS = exports.MAX_POINT_LIGHTS = 4;\nvar PICKING_RES = exports.PICKING_RES = 4;\nvar INVALID_ARGUMENT = 'LumaGL.Scene invalid argument';\nvar DEFAULT_SCENE_OPTS = {\n  lights: {\n    enable: false,\n    // ambient light\n    ambient: {\n      r: 0.2,\n      g: 0.2,\n      b: 0.2\n    },\n    // directional light\n    directional: {\n      direction: {\n        x: 1,\n        y: 1,\n        z: 1\n      },\n      color: {\n        r: 0,\n        g: 0,\n        b: 0 // point light\n        // points: []\n\n      }\n    }\n  },\n  effects: {\n    fog: false // { near, far, color }\n\n  },\n  clearColor: true,\n  clearDepth: true,\n  backgroundColor: {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 1\n  },\n  backgroundDepth: 1\n}; // Scene class\n\nvar Scene = function (_Group) {\n  _inherits(Scene, _Group);\n\n  function Scene(gl, opts) {\n    _classCallCheck(this, Scene);\n\n    (0, _assert2.default)(gl, INVALID_ARGUMENT);\n    opts = (0, _utils.merge)(DEFAULT_SCENE_OPTS, opts);\n\n    var _this = _possibleConstructorReturn(this, (Scene.__proto__ || Object.getPrototypeOf(Scene)).call(this, opts));\n\n    _this.gl = gl;\n    _this.config = opts;\n    _this.needsRedraw = false;\n    Object.seal(_this);\n    return _this;\n  }\n\n  _createClass(Scene, [{\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw() {\n      var redraw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.needsRedraw = redraw;\n      return this;\n    }\n  }, {\n    key: 'getNeedsRedraw',\n    value: function getNeedsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$clearRedrawFlags = _ref.clearRedrawFlags,\n          clearRedrawFlags = _ref$clearRedrawFlags === undefined ? false : _ref$clearRedrawFlags;\n\n      var redraw = false;\n      redraw = redraw || this.needsRedraw;\n      this.needsRedraw = this.needsRedraw && !clearRedrawFlags;\n      this.traverse(function (model) {\n        redraw = redraw || model.getNeedsRedraw({\n          clearRedrawFlags: clearRedrawFlags\n        });\n      });\n      return redraw;\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      var gl = this.gl;\n\n      if (this.config.clearColor) {\n        var bg = this.config.backgroundColor;\n        gl.clearColor(bg.r, bg.g, bg.b, bg.a);\n      }\n\n      if (this.config.clearDepth) {\n        gl.clearDepth(this.config.backgroundDepth);\n      }\n\n      if (this.config.clearColor && this.config.clearDepth) {\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n      } else if (this.config.clearColor) {\n        gl.clear(gl.COLOR_BUFFER_BIT);\n      } else if (this.config.clearDepth) {\n        gl.clear(gl.DEPTH_BUFFER_BIT);\n      }\n\n      return this;\n    } // Renders all objects in the scene.\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.clear(); // Go through each model and render it.\n\n      this.traverse(function (model) {\n        if (model.display) {\n          _this2.renderObject({\n            model: model,\n            uniforms: uniforms\n          });\n        }\n      });\n      return this;\n    }\n  }, {\n    key: 'renderObject',\n    value: function renderObject(_ref2) {\n      var model = _ref2.model,\n          uniforms = _ref2.uniforms; // Setup lighting and scene effects like fog, etc.\n\n      uniforms = Object.assign({}, this.getSceneUniforms(), uniforms);\n      model.render(uniforms);\n      return this;\n    }\n  }, {\n    key: 'pickModels',\n    value: function pickModels() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var x = opts.x,\n          y = opts.y,\n          _opts$uniforms = opts.uniforms,\n          uniforms = _opts$uniforms === undefined ? {} : _opts$uniforms;\n      return (0, _pickModels3.default)(this.gl, Object.assign({\n        group: this,\n        position: [x, y],\n        uniforms: uniforms\n      }, opts));\n    } // Setup the lighting system: ambient, directional, point lights.\n\n  }, {\n    key: 'getSceneUniforms',\n    value: function getSceneUniforms() {\n      // Setup Lighting\n      var _config$lights = this.config.lights,\n          enable = _config$lights.enable,\n          ambient = _config$lights.ambient,\n          directional = _config$lights.directional,\n          points = _config$lights.points; // Set light uniforms. Ambient and directional lights.\n\n      return Object.assign({}, this.getEffectsUniforms(), {\n        enableLights: enable\n      }, enable && ambient ? this.getAmbientUniforms(ambient) : {}, enable && directional ? this.getDirectionalUniforms(directional) : {}, enable && points ? this.getPointUniforms(points) : {});\n    }\n  }, {\n    key: 'getAmbientUniforms',\n    value: function getAmbientUniforms(ambient) {\n      return {\n        ambientColor: [ambient.r, ambient.g, ambient.b]\n      };\n    }\n  }, {\n    key: 'getDirectionalUniforms',\n    value: function getDirectionalUniforms(directional) {\n      var color = directional.color,\n          direction = directional.direction; // Normalize lighting direction vector\n\n      var dir = new _math.Vector3(direction.x, direction.y, direction.z).normalize().scale(-1, -1, -1);\n      return {\n        directionalColor: [color.r, color.g, color.b],\n        lightingDirection: [dir.x, dir.y, dir.z]\n      };\n    }\n  }, {\n    key: 'getPointUniforms',\n    value: function getPointUniforms(points) {\n      points = points instanceof Array ? points : [points];\n      var numberPoints = points.length;\n      var uniforms = {\n        numberPoints: numberPoints\n      };\n      var pointLocations = [];\n      var pointColors = [];\n      var enableSpecular = [];\n      var pointSpecularColors = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = points[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var point = _step.value;\n          var position = point.position,\n              color = point.color,\n              diffuse = point.diffuse,\n              specular = point.specular;\n          var pointColor = color || diffuse;\n          pointLocations.push(position.x, position.y, position.z);\n          pointColors.push(pointColor.r, pointColor.g, pointColor.b); // Add specular color\n\n          enableSpecular.push(Number(Boolean(specular)));\n\n          if (specular) {\n            pointSpecularColors.push(specular.r, specular.g, specular.b);\n          } else {\n            pointSpecularColors.push(0, 0, 0);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (pointLocations.length) {\n        Object.assign(uniforms, {\n          pointLocation: pointLocations,\n          pointColor: pointColors,\n          enableSpecular: enableSpecular,\n          pointSpecularColor: pointSpecularColors\n        });\n      }\n\n      return uniforms;\n    } // Setup effects like fog, etc.\n\n  }, {\n    key: 'getEffectsUniforms',\n    value: function getEffectsUniforms() {\n      var fog = this.config.effects.fog;\n\n      if (fog) {\n        var _fog$color = fog.color,\n            color = _fog$color === undefined ? {\n          r: 0.5,\n          g: 0.5,\n          b: 0.5\n        } : _fog$color;\n        return {\n          hasFog: true,\n          fogNear: fog.near,\n          fogFar: fog.far,\n          fogColor: [color.r, color.g, color.b]\n        };\n      }\n\n      return {\n        hasFog: false\n      };\n    }\n  }]);\n\n  return Scene;\n}(_group2.default);\n\nexports.default = Scene;\nScene.MAX_TEXTURES = 4;\nScene.MAX_POINT_LIGHTS = 4;\nScene.PICKING_RES = 4;","map":null,"metadata":{},"sourceType":"script"}