{"ast":null,"code":"var _UNIFORM_SETTERS;\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport Texture from './texture';\nimport { formatValue } from '../utils';\nimport assert from 'assert'; // Local constants, will be \"collapsed\" during minification\n// WebGL1\n\nvar GL_FLOAT = 0x1406;\nvar GL_FLOAT_VEC2 = 0x8B50;\nvar GL_FLOAT_VEC3 = 0x8B51;\nvar GL_FLOAT_VEC4 = 0x8B52;\nvar GL_INT = 0x1404;\nvar GL_INT_VEC2 = 0x8B53;\nvar GL_INT_VEC3 = 0x8B54;\nvar GL_INT_VEC4 = 0x8B55;\nvar GL_BOOL = 0x8B56;\nvar GL_BOOL_VEC2 = 0x8B57;\nvar GL_BOOL_VEC3 = 0x8B58;\nvar GL_BOOL_VEC4 = 0x8B59;\nvar GL_FLOAT_MAT2 = 0x8B5A;\nvar GL_FLOAT_MAT3 = 0x8B5B;\nvar GL_FLOAT_MAT4 = 0x8B5C;\nvar GL_SAMPLER_2D = 0x8B5E;\nvar GL_SAMPLER_CUBE = 0x8B60; // WebGL2\n\nvar GL_UNSIGNED_INT = 0x1405;\nvar GL_UNSIGNED_INT_VEC2 = 0x8DC6;\nvar GL_UNSIGNED_INT_VEC3 = 0x8DC7;\nvar GL_UNSIGNED_INT_VEC4 = 0x8DC8;\n/* eslint-disable camelcase */\n\nvar GL_FLOAT_MAT2x3 = 0x8B65;\nvar GL_FLOAT_MAT2x4 = 0x8B66;\nvar GL_FLOAT_MAT3x2 = 0x8B67;\nvar GL_FLOAT_MAT3x4 = 0x8B68;\nvar GL_FLOAT_MAT4x2 = 0x8B69;\nvar GL_FLOAT_MAT4x3 = 0x8B6A;\nvar GL_SAMPLER_3D = 0x8B5F;\nvar GL_SAMPLER_2D_SHADOW = 0x8B62;\nvar GL_SAMPLER_2D_ARRAY = 0x8DC1;\nvar GL_SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;\nvar GL_SAMPLER_CUBE_SHADOW = 0x8DC5;\nvar GL_INT_SAMPLER_2D = 0x8DCA;\nvar GL_INT_SAMPLER_3D = 0x8DCB;\nvar GL_INT_SAMPLER_CUBE = 0x8DCC;\nvar GL_INT_SAMPLER_2D_ARRAY = 0x8DCF;\nvar GL_UNSIGNED_INT_SAMPLER_2D = 0x8DD2;\nvar GL_UNSIGNED_INT_SAMPLER_3D = 0x8DD3;\nvar GL_UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;\nvar GL_UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;\n/* TODO - create static Float32...Arrays and copy into those instead of minting new ones?\nconst arrays = {};\nfunction getTypedArray(type, data) {\n  if (flatArrayLength > 1) {\n    setter = val => {\n      if (!(val instanceof TypedArray)) {\n        const typedArray = new TypedArray(flatArrayLength);\n        typedArray.set(val);\n        val = typedArray;\n      }\n      assert(val.length === flatArrayLength);\n    };\n  }\n}\n// TODO - handle array uniforms\n*/\n\nvar UNIFORM_SETTERS = (_UNIFORM_SETTERS = {}, _defineProperty(_UNIFORM_SETTERS, GL_FLOAT, function (gl, location, value) {\n  return gl.uniform1f(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC2, function (gl, location, value) {\n  return gl.uniform2fv(location, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC3, function (gl, location, value) {\n  return gl.uniform3fv(location, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_VEC4, function (gl, location, value) {\n  return gl.uniform4fv(location, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC2, function (gl, location, value) {\n  return gl.uniform2iv(location, new Int32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC3, function (gl, location, value) {\n  return gl.uniform3iv(location, new Int32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_VEC4, function (gl, location, value) {\n  return gl.uniform4iv(location, new Int32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC2, function (gl, location, value) {\n  return gl.uniform2iv(location, new Int32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC3, function (gl, location, value) {\n  return gl.uniform3fv(location, new Int32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_BOOL_VEC4, function (gl, location, value) {\n  return gl.uniform4iv(location, new Int32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2, function (gl, location, value) {\n  return gl.uniformMatrix2fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3, function (gl, location, value) {\n  return gl.uniformMatrix3fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4, function (gl, location, value) {\n  return gl.uniformMatrix4fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_CUBE, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT, function (gl, location, value) {\n  return gl.uniform1ui(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC2, function (gl, location, value) {\n  return gl.uniform2uiv(location, new Uint32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC3, function (gl, location, value) {\n  return gl.uniform3uiv(location, new Uint32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_VEC4, function (gl, location, value) {\n  return gl.uniform4uiv(location, new Uint32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2x3, function (gl, location, value) {\n  return gl.uniformMatrix2x3fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT2x4, function (gl, location, value) {\n  return gl.uniformMatrix2x4fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3x2, function (gl, location, value) {\n  return gl.uniformMatrix3x2fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT3x4, function (gl, location, value) {\n  return gl.uniformMatrix3x4fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4x2, function (gl, location, value) {\n  return gl.uniformMatrix4x2fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_FLOAT_MAT4x3, function (gl, location, value) {\n  return gl.uniformMatrix4x3fv(location, false, new Float32Array(value));\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_3D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_SHADOW, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_ARRAY, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_2D_ARRAY_SHADOW, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_SAMPLER_CUBE_SHADOW, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_2D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_3D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_CUBE, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_INT_SAMPLER_2D_ARRAY, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_2D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_3D, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_CUBE, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _defineProperty(_UNIFORM_SETTERS, GL_UNSIGNED_INT_SAMPLER_2D_ARRAY, function (gl, location, value) {\n  return gl.uniform1i(location, value);\n}), _UNIFORM_SETTERS);\nexport function parseUniformName(name) {\n  // name = name[name.length - 1] === ']' ?\n  // name.substr(0, name.length - 3) : name;\n  // if array name then clean the array brackets\n  var UNIFORM_NAME_REGEXP = /([^\\[]*)(\\[[0-9]+\\])?/;\n  var matches = name.match(UNIFORM_NAME_REGEXP);\n\n  if (!matches || matches.length < 2) {\n    throw new Error('Failed to parse GLSL uniform name ' + name);\n  }\n\n  return {\n    name: matches[1],\n    length: matches[2] || 1,\n    isArray: Boolean(matches[2])\n  };\n} // Returns a Magic Uniform Setter\n\n/* eslint-disable complexity */\n\nexport function getUniformSetter(gl, location, info) {\n  var setter = UNIFORM_SETTERS[info.type];\n\n  if (!setter) {\n    throw new Error('Unknown GLSL uniform type ' + info.type);\n  }\n\n  return setter.bind(null, gl, location);\n} // Basic checks of uniform values without knowledge of program\n// To facilitate early detection of e.g. undefined values in JavaScript\n\nexport function checkUniformValues(uniforms, source) {\n  for (var uniformName in uniforms) {\n    var value = uniforms[uniformName];\n\n    if (!checkUniformValue(value)) {\n      // Add space to source\n      source = source ? source + ' ' : ''; // Value could be unprintable so write the object on console\n\n      console.error(source + ' Bad uniform ' + uniformName, value); // eslint-disable-line\n\n      /* eslint-enable no-console */\n\n      throw new Error(source + ' Bad uniform ' + uniformName);\n    }\n  }\n\n  return true;\n}\n\nfunction checkUniformValue(value) {\n  var ok = true; // Test for texture (for sampler uniforms)\n  // WebGL2: if (value instanceof Texture || value instanceof Sampler) {\n\n  if (value instanceof Texture) {\n    ok = true; // Check that every element in array is a number, and at least 1 element\n  } else if (Array.isArray(value)) {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var element = _step.value;\n\n        if (!isFinite(element)) {\n          ok = false;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    ok = ok && value.length > 0; // Typed arrays can only contain numbers, but check length\n  } else if (ArrayBuffer.isView(value)) {\n    ok = value.length > 0; // Check that single value is a number\n  } else if (!isFinite(value)) {\n    ok = false;\n  }\n\n  return ok;\n} // Prepares a table suitable for console.table\n\n/* eslint-disable max-statements */\n\n\nexport function getUniformsTable() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$header = _ref.header,\n      header = _ref$header === undefined ? 'Uniforms' : _ref$header,\n      program = _ref.program,\n      uniforms = _ref.uniforms;\n\n  assert(program);\n  var uniformLocations = program._uniformSetters;\n\n  var table = _defineProperty({}, header, {}); // Add program's provided uniforms\n\n\n  for (var uniformName in uniformLocations) {\n    var uniform = uniforms[uniformName];\n\n    if (uniform !== undefined) {\n      table[uniformName] = {\n        Type: uniform,\n        Value: formatValue(uniform)\n      };\n    }\n  } // Add program's unprovided uniforms\n\n\n  for (var _uniformName in uniformLocations) {\n    var _uniform = uniforms[_uniformName];\n\n    if (_uniform === undefined) {\n      table[_uniformName] = {\n        Type: 'NOT PROVIDED',\n        Value: 'N/A'\n      };\n    }\n  }\n\n  var unusedTable = {};\n  var unusedCount = 0; // List any unused uniforms\n\n  for (var _uniformName2 in uniforms) {\n    var _uniform2 = uniforms[_uniformName2];\n\n    if (!table[_uniformName2]) {\n      unusedCount++;\n      unusedTable[_uniformName2] = {\n        Type: 'NOT USED: ' + _uniform2,\n        Value: formatValue(_uniform2)\n      };\n    }\n  }\n\n  return {\n    table: table,\n    unusedTable: unusedTable,\n    unusedCount: unusedCount\n  };\n}","map":null,"metadata":{},"sourceType":"module"}