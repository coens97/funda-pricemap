{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport assert from '../utils/assert';\nimport { Framebuffer, _ShaderCache as ShaderCache } from 'luma.gl';\nimport seer from 'seer';\nimport Layer from './layer';\nimport { drawLayers as _drawLayers } from './draw-layers';\nimport { pickObject as _pickObject, pickVisibleObjects } from './pick-layers';\nimport { LIFECYCLE } from '../lifecycle/constants';\nimport log from '../utils/log';\nimport { flatten } from '../utils/flatten';\nimport { Stats } from 'probe.gl';\nimport Viewport from '../viewports/viewport';\nimport { setPropOverrides, layerEditListener, seerInitListener, initLayerInSeer, updateLayerInSeer } from './seer-integration';\nvar LOG_PRIORITY_LIFECYCLE = 2;\nvar LOG_PRIORITY_LIFECYCLE_MINOR = 4; // CONTEXT IS EXPOSED TO LAYERS\n\nvar INITIAL_CONTEXT = Object.seal({\n  layerManager: null,\n  gl: null,\n  // Settings\n  useDevicePixels: true,\n  // Exposed in case custom layers need to adjust sizes\n  // General resources\n  stats: null,\n  // for tracking lifecycle performance\n  // Make sure context.viewport is not empty on the first layer initialization\n  viewport: new Viewport({\n    id: 'DEFAULT-INITIAL-VIEWPORT'\n  }),\n  // Current viewport, exposed to layers for project* function\n  // GL Resources\n  shaderCache: null,\n  pickingFBO: null,\n  // Screen-size framebuffer that layers can reuse\n  // State\n  lastPickedInfo: null,\n  animationProps: null,\n  userData: {} // Place for any custom app `context`\n\n});\n\nvar layerName = function layerName(layer) {\n  return layer instanceof Layer ? \"\".concat(layer) : !layer ? 'null' : 'invalid';\n};\n\nvar LayerManager =\n/*#__PURE__*/\nfunction () {\n  // eslint-disable-next-line\n  function LayerManager(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        stats = _ref.stats;\n\n    _classCallCheck(this, LayerManager); // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n    // `this.lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n\n\n    this.lastRenderedLayers = [];\n    this.layers = [];\n    this.context = Object.assign({}, INITIAL_CONTEXT, {\n      layerManager: this,\n      gl: gl,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      shaderCache: new ShaderCache({\n        gl: gl,\n        _cachePrograms: true\n      }),\n      stats: stats || new Stats({\n        id: 'deck.gl'\n      }),\n      lastPickedInfo: {\n        // For callback tracking and autohighlight\n        index: -1,\n        layerId: null\n      }\n    });\n    this.layerFilter = null;\n    this.drawPickingColors = false;\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = false;\n    this._activateViewport = this._activateViewport.bind(this); // Seer integration\n\n    this._initSeer = this._initSeer.bind(this);\n    this._editSeer = this._editSeer.bind(this);\n    Object.seal(this);\n    seerInitListener(this._initSeer);\n    layerEditListener(this._editSeer);\n  } // Method to call when the layer manager is not needed anymore.\n  // Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.\n\n\n  _createClass(LayerManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      seer.removeListener(this._initSeer);\n      seer.removeListener(this._editSeer);\n    } // Check if a redraw is needed\n\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,\n          clearRedrawFlags = _ref2$clearRedrawFlag === void 0 ? true : _ref2$clearRedrawFlag;\n\n      return this._checkIfNeedsRedraw(clearRedrawFlags);\n    } // Check if a deep update of all layers is needed\n\n  }, {\n    key: \"needsUpdate\",\n    value: function needsUpdate() {\n      return this._needsUpdate;\n    } // Layers will be redrawn (in next animation frame)\n\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      this._needsRedraw = this._needsRedraw || reason;\n    } // Layers will be updated deeply (in next animation frame)\n    // Potentially regenerating attributes and sub layers\n\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate(reason) {\n      this._needsUpdate = this._needsUpdate || reason;\n    } // Gets an (optionally) filtered list of layers\n\n  }, {\n    key: \"getLayers\",\n    value: function getLayers() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$layerIds = _ref3.layerIds,\n          layerIds = _ref3$layerIds === void 0 ? null : _ref3$layerIds; // Filtering by layerId compares beginning of strings, so that sublayers will be included\n      // Dependes on the convention of adding suffixes to the parent's layer name\n\n\n      return layerIds ? this.layers.filter(function (layer) {\n        return layerIds.find(function (layerId) {\n          return layer.id.indexOf(layerId) === 0;\n        });\n      }) : this.layers;\n    }\n    /**\n     * Set props needed for layer rendering and picking.\n     * Parameters are to be passed as a single object, with the following values:\n     * @param {Boolean} useDevicePixels\n     */\n\n    /* eslint-disable complexity, max-statements */\n\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      // TODO - For now we set layers before viewports to preserve changeFlags\n      if ('layers' in props) {\n        this.setLayers(props.layers);\n      }\n\n      if ('layerFilter' in props) {\n        if (this.layerFilter !== props.layerFilter) {\n          this.layerFilter = props.layerFilter;\n          this.setNeedsRedraw('layerFilter changed');\n        }\n      }\n\n      if ('drawPickingColors' in props) {\n        if (props.drawPickingColors !== this.drawPickingColors) {\n          this.drawPickingColors = props.drawPickingColors;\n          this.setNeedsRedraw('drawPickingColors changed');\n        }\n      } // A way for apps to add data to context that can be accessed in layers\n\n\n      if ('userData' in props) {\n        this.context.userData = props.userData;\n      }\n\n      if ('useDevicePixels' in props) {\n        this.context.useDevicePixels = props.useDevicePixels;\n      }\n    }\n    /* eslint-enable complexity, max-statements */\n    // Supply a new layer list, initiating sublayer generation and layer matching\n\n  }, {\n    key: \"setLayers\",\n    value: function setLayers(newLayers) {\n      // TODO - something is generating state updates that cause rerender of the same\n      if (newLayers === this.lastRenderedLayers) {\n        log.log(3, 'Ignoring layer update due to layer array not changed')();\n        return this;\n      }\n\n      this.lastRenderedLayers = newLayers;\n      newLayers = flatten(newLayers, {\n        filter: Boolean\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n          layer.context = this.context;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _this$_updateLayers = this._updateLayers({\n        oldLayers: this.layers,\n        newLayers: newLayers\n      }),\n          error = _this$_updateLayers.error,\n          generatedLayers = _this$_updateLayers.generatedLayers;\n\n      this.layers = generatedLayers; // Throw first error found, if any\n\n      if (error) {\n        throw error;\n      }\n\n      return this;\n    } // Update layers from last cycle if `setNeedsUpdate()` has been called\n\n  }, {\n    key: \"updateLayers\",\n    value: function updateLayers() {\n      // NOTE: For now, even if only some layer has changed, we update all layers\n      // to ensure that layer id maps etc remain consistent even if different\n      // sublayers are rendered\n      var reason = this.needsUpdate();\n\n      if (reason) {\n        this.setNeedsRedraw(\"updating layers: \".concat(reason)); // HACK - Call with a copy of lastRenderedLayers to trigger a full update\n\n        this.setLayers(_toConsumableArray(this.lastRenderedLayers));\n      }\n    } //\n    // METHODS FOR LAYERS\n    //\n    // Draw all layers in all views\n\n  }, {\n    key: \"drawLayers\",\n    value: function drawLayers(_ref4) {\n      var _ref4$pass = _ref4.pass,\n          pass = _ref4$pass === void 0 ? 'render to screen' : _ref4$pass,\n          viewports = _ref4.viewports,\n          views = _ref4.views,\n          _ref4$redrawReason = _ref4.redrawReason,\n          redrawReason = _ref4$redrawReason === void 0 ? 'unknown reason' : _ref4$redrawReason,\n          _ref4$customRender = _ref4.customRender,\n          customRender = _ref4$customRender === void 0 ? false : _ref4$customRender;\n      var drawPickingColors = this.drawPickingColors;\n      var _this$context = this.context,\n          gl = _this$context.gl,\n          useDevicePixels = _this$context.useDevicePixels; // render this viewport\n\n      _drawLayers(gl, {\n        layers: this.layers,\n        viewports: viewports,\n        views: views,\n        onViewportActive: this._activateViewport,\n        useDevicePixels: useDevicePixels,\n        drawPickingColors: drawPickingColors,\n        pass: pass,\n        layerFilter: this.layerFilter,\n        redrawReason: redrawReason,\n        customRender: customRender\n      });\n    } // Pick the closest info at given coordinate\n\n  }, {\n    key: \"pickObject\",\n    value: function pickObject(_ref5) {\n      var x = _ref5.x,\n          y = _ref5.y,\n          mode = _ref5.mode,\n          _ref5$radius = _ref5.radius,\n          radius = _ref5$radius === void 0 ? 0 : _ref5$radius,\n          layerIds = _ref5.layerIds,\n          viewports = _ref5.viewports,\n          _ref5$depth = _ref5.depth,\n          depth = _ref5$depth === void 0 ? 1 : _ref5$depth;\n      var _this$context2 = this.context,\n          gl = _this$context2.gl,\n          useDevicePixels = _this$context2.useDevicePixels;\n      var layers = this.getLayers({\n        layerIds: layerIds\n      });\n      return _pickObject(gl, {\n        // User params\n        x: x,\n        y: y,\n        radius: radius,\n        layers: layers,\n        mode: mode,\n        layerFilter: this.layerFilter,\n        depth: depth,\n        // Injected params\n        viewports: viewports,\n        onViewportActive: this._activateViewport,\n        pickingFBO: this._getPickingBuffer(),\n        lastPickedInfo: this.context.lastPickedInfo,\n        useDevicePixels: useDevicePixels\n      });\n    } // Get all unique infos within a bounding box\n\n  }, {\n    key: \"pickObjects\",\n    value: function pickObjects(_ref6) {\n      var x = _ref6.x,\n          y = _ref6.y,\n          width = _ref6.width,\n          height = _ref6.height,\n          layerIds = _ref6.layerIds,\n          viewports = _ref6.viewports;\n      var _this$context3 = this.context,\n          gl = _this$context3.gl,\n          useDevicePixels = _this$context3.useDevicePixels;\n      var layers = this.getLayers({\n        layerIds: layerIds\n      });\n      return pickVisibleObjects(gl, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        layers: layers,\n        layerFilter: this.layerFilter,\n        mode: 'pickObjects',\n        viewports: viewports,\n        onViewportActive: this._activateViewport,\n        pickingFBO: this._getPickingBuffer(),\n        useDevicePixels: useDevicePixels\n      });\n    } //\n    // PRIVATE METHODS\n    //\n\n  }, {\n    key: \"_checkIfNeedsRedraw\",\n    value: function _checkIfNeedsRedraw(clearRedrawFlags) {\n      var redraw = this._needsRedraw;\n\n      if (clearRedrawFlags) {\n        this._needsRedraw = false;\n      } // This layers list doesn't include sublayers, relying on composite layers\n\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var layer = _step2.value; // Call every layer to clear their flags\n\n          var layerNeedsRedraw = layer.getNeedsRedraw({\n            clearRedrawFlags: clearRedrawFlags\n          });\n          redraw = redraw || layerNeedsRedraw;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return redraw;\n    } // Make a viewport \"current\" in layer context, updating viewportChanged flags\n\n  }, {\n    key: \"_activateViewport\",\n    value: function _activateViewport(viewport) {\n      var oldViewport = this.context.viewport;\n      var viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n\n      if (viewportChanged) {\n        log.log(4, 'Viewport changed', viewport)();\n        this.context.viewport = viewport; // Update layers states\n        // Let screen space layers update their state based on viewport\n\n        var _iteratorNormalCompletion3 = true;\n        var _didIteratorError3 = false;\n        var _iteratorError3 = undefined;\n\n        try {\n          for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n            var layer = _step3.value;\n            layer.setChangeFlags({\n              viewportChanged: 'Viewport changed'\n            });\n\n            this._updateLayer(layer);\n          }\n        } catch (err) {\n          _didIteratorError3 = true;\n          _iteratorError3 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n              _iterator3.return();\n            }\n          } finally {\n            if (_didIteratorError3) {\n              throw _iteratorError3;\n            }\n          }\n        }\n      }\n\n      assert(this.context.viewport, 'LayerManager: viewport not set');\n      return this;\n    }\n  }, {\n    key: \"_getPickingBuffer\",\n    value: function _getPickingBuffer() {\n      var gl = this.context.gl; // Create a frame buffer if not already available\n\n      this.context.pickingFBO = this.context.pickingFBO || new Framebuffer(gl); // Resize it to current canvas size (this is a noop if size hasn't changed)\n\n      this.context.pickingFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n      return this.context.pickingFBO;\n    } // Match all layers, checking for caught errors\n    // To avoid having an exception in one layer disrupt other layers\n    // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n\n  }, {\n    key: \"_updateLayers\",\n    value: function _updateLayers(_ref7) {\n      var oldLayers = _ref7.oldLayers,\n          newLayers = _ref7.newLayers; // Create old layer map\n\n      var oldLayerMap = {};\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var oldLayer = _step4.value;\n\n          if (oldLayerMap[oldLayer.id]) {\n            log.warn(\"Multiple old layers with same id \".concat(layerName(oldLayer)))();\n          } else {\n            oldLayerMap[oldLayer.id] = oldLayer;\n          }\n        } // Allocate array for generated layers\n\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var generatedLayers = []; // Match sublayers\n\n      var error = this._updateSublayersRecursively({\n        newLayers: newLayers,\n        oldLayerMap: oldLayerMap,\n        generatedLayers: generatedLayers\n      }); // Finalize unmatched layers\n\n\n      var error2 = this._finalizeOldLayers(oldLayerMap);\n\n      this._needsUpdate = false;\n      var firstError = error || error2;\n      return {\n        error: firstError,\n        generatedLayers: generatedLayers\n      };\n    } // Note: adds generated layers to `generatedLayers` array parameter\n\n  }, {\n    key: \"_updateSublayersRecursively\",\n    value: function _updateSublayersRecursively(_ref8) {\n      var newLayers = _ref8.newLayers,\n          oldLayerMap = _ref8.oldLayerMap,\n          generatedLayers = _ref8.generatedLayers;\n      var error = null;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var newLayer = _step5.value;\n          newLayer.context = this.context; // Given a new coming layer, find its matching old layer (if any)\n\n          var oldLayer = oldLayerMap[newLayer.id];\n\n          if (oldLayer === null) {\n            // null, rather than undefined, means this id was originally there\n            log.warn(\"Multiple new layers with same id \".concat(layerName(newLayer)))();\n          } // Remove the old layer from candidates, as it has been matched with this layer\n\n\n          oldLayerMap[newLayer.id] = null;\n          var sublayers = null; // We must not generate exceptions until after layer matching is complete\n\n          try {\n            if (!oldLayer) {\n              this._initializeLayer(newLayer);\n\n              initLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)\n            } else {\n              this._transferLayerState(oldLayer, newLayer);\n\n              this._updateLayer(newLayer);\n\n              updateLayerInSeer(newLayer); // Updates layer in seer chrome extension (if connected)\n            }\n\n            generatedLayers.push(newLayer); // Call layer lifecycle method: render sublayers\n\n            sublayers = newLayer.isComposite && newLayer.getSubLayers(); // End layer lifecycle method: render sublayers\n          } catch (err) {\n            log.warn(\"error during matching of \".concat(layerName(newLayer)), err);\n            error = error || err; // Record first exception\n          }\n\n          if (sublayers) {\n            this._updateSublayersRecursively({\n              newLayers: sublayers,\n              oldLayerMap: oldLayerMap,\n              generatedLayers: generatedLayers\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return error;\n    } // Finalize any old layers that were not matched\n\n  }, {\n    key: \"_finalizeOldLayers\",\n    value: function _finalizeOldLayers(oldLayerMap) {\n      var error = null;\n\n      for (var layerId in oldLayerMap) {\n        var layer = oldLayerMap[layerId];\n\n        if (layer) {\n          error = error || this._finalizeLayer(layer);\n        }\n      }\n\n      return error;\n    } // EXCEPTION SAFE LAYER ACCESS\n    // Initializes a single layer, calling layer methods\n\n  }, {\n    key: \"_initializeLayer\",\n    value: function _initializeLayer(layer) {\n      log.log(LOG_PRIORITY_LIFECYCLE, \"initializing \".concat(layerName(layer)))();\n      var error = null;\n\n      try {\n        layer._initialize();\n\n        layer.lifecycle = LIFECYCLE.INITIALIZED;\n      } catch (err) {\n        log.warn(\"error while initializing \".concat(layerName(layer), \"\\n\"), err)();\n        error = error || err; // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n      } // Set back pointer (used in picking)\n\n\n      layer.internalState.layer = layer; // Save layer on model for picking purposes\n      // store on model.userData rather than directly on model\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = layer.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var model = _step6.value;\n          model.userData.layer = layer;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return error;\n    }\n  }, {\n    key: \"_transferLayerState\",\n    value: function _transferLayerState(oldLayer, newLayer) {\n      newLayer._transferState(oldLayer);\n\n      newLayer.lifecycle = LIFECYCLE.MATCHED;\n\n      if (newLayer !== oldLayer) {\n        log.log(LOG_PRIORITY_LIFECYCLE_MINOR, \"matched \".concat(layerName(newLayer)), oldLayer, '->', newLayer)();\n        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n      } else {\n        log.log(LOG_PRIORITY_LIFECYCLE_MINOR, \"Matching layer is unchanged \".concat(newLayer.id))();\n      }\n    } // Updates a single layer, cleaning all flags\n\n  }, {\n    key: \"_updateLayer\",\n    value: function _updateLayer(layer) {\n      log.log(LOG_PRIORITY_LIFECYCLE_MINOR, \"updating \".concat(layer, \" because: \").concat(layer.printChangeFlags()))();\n      var error = null;\n\n      try {\n        layer._update();\n      } catch (err) {\n        log.warn(\"error during update of \".concat(layerName(layer)), err)(); // Save first error\n\n        error = err;\n      }\n\n      return error;\n    } // Finalizes a single layer\n\n  }, {\n    key: \"_finalizeLayer\",\n    value: function _finalizeLayer(layer) {\n      assert(layer.lifecycle !== LIFECYCLE.AWAITING_FINALIZATION);\n      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n      var error = null;\n      this.setNeedsRedraw(\"finalized \".concat(layerName(layer)));\n\n      try {\n        layer._finalize();\n      } catch (err) {\n        log.warn(\"error during finalization of \".concat(layerName(layer)), err)();\n        error = err;\n      }\n\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n      log.log(LOG_PRIORITY_LIFECYCLE, \"finalizing \".concat(layerName(layer)));\n      return error;\n    } // SEER INTEGRATION\n\n    /**\n     * Called upon Seer initialization, manually sends layers data.\n     */\n\n  }, {\n    key: \"_initSeer\",\n    value: function _initSeer() {\n      this.layers.forEach(function (layer) {\n        initLayerInSeer(layer);\n        updateLayerInSeer(layer);\n      });\n    }\n    /**\n     * On Seer property edition, set override and update layers.\n     */\n\n  }, {\n    key: \"_editSeer\",\n    value: function _editSeer(payload) {\n      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {\n        return;\n      }\n\n      setPropOverrides(payload.itemKey, payload.valuePath.slice(1), payload.value);\n      var newLayers = this.layers.map(function (layer) {\n        return new layer.constructor(layer.props);\n      });\n      this.updateLayers({\n        newLayers: newLayers\n      });\n    }\n  }]);\n\n  return LayerManager;\n}();\n\nexport { LayerManager as default };","map":null,"metadata":{},"sourceType":"module"}