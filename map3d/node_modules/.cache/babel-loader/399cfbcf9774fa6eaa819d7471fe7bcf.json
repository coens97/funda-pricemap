{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport luma from '../init';\nimport { assertWebGLContext, isWebGL2, getKey, getKeyValue } from '../webgl-utils';\nimport { uid } from '../utils';\nimport { stubRemovedMethods as _stubRemovedMethods } from '../utils';\nimport assert from '../utils/assert';\nvar ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods'; // TODO - Handle context loss\n// function glGetContextLossCount(gl) {\n//   return (gl.luma && gl.luma.glCount) || 0;\n// }\n\nvar Resource =\n/*#__PURE__*/\nfunction () {\n  function Resource(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Resource);\n\n    assertWebGLContext(gl);\n    var id = opts.id,\n        _opts$userData = opts.userData,\n        userData = _opts$userData === void 0 ? {} : _opts$userData;\n    this.gl = gl; // this.ext = polyfillContext(gl);\n\n    this.id = id || uid(this.constructor.name);\n    this.userData = userData;\n    this._bound = false; // Set the handle\n    // If handle was provided, use it, otherwise create a new handle\n    // TODO - Stores the handle with context loss information\n    // this.glCount = glGetContextLossCount(this.gl);\n    // Default VertexArray needs to be created with null handle, so compare against undefined\n\n    this._handle = opts.handle;\n\n    if (this._handle === undefined) {\n      this._handle = this._createHandle();\n    }\n\n    this._addStats();\n  }\n\n  _createClass(Resource, [{\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.constructor.name, \"(\").concat(this.id, \")\");\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$deleteChildren = _ref.deleteChildren,\n          deleteChildren = _ref$deleteChildren === void 0 ? false : _ref$deleteChildren; // Delete this object, and get refs to any children\n\n\n      var children = this._handle && this._deleteHandle(this._handle);\n\n      this._handle = null;\n\n      this._removeStats(); // Optionally, recursively delete the children\n\n\n      if (children && deleteChildren) {\n        children.filter(Boolean).forEach(function (child) {\n          child.delete();\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var funcOrHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.handle;\n\n      if (typeof funcOrHandle !== 'function') {\n        this._bindHandle(funcOrHandle);\n\n        return this;\n      }\n\n      var value;\n\n      if (!this._bound) {\n        this._bindHandle(this.handle);\n\n        this._bound = true;\n        value = funcOrHandle();\n        this._bound = false;\n\n        this._bindHandle(null);\n      } else {\n        value = funcOrHandle();\n      }\n\n      return value;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.bind(null);\n    }\n    /**\n     * Query a Resource parameter\n     *\n     * @param {GLenum} pname\n     * @return {GLint|GLfloat|GLenum} param\n     */\n\n  }, {\n    key: \"getParameter\",\n    value: function getParameter(pname) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      pname = getKeyValue(this.gl, pname);\n      assert(pname);\n      var parameters = this.constructor.PARAMETERS || {}; // Use parameter definitions to handle unsupported parameters\n\n      var parameter = parameters[pname];\n\n      if (parameter) {\n        var isWebgl2 = isWebGL2(this.gl); // Check if we can query for this parameter\n\n        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));\n\n        if (!parameterAvailable) {\n          var webgl1Default = parameter.webgl1;\n          var webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;\n          var defaultValue = isWebgl2 ? webgl2Default : webgl1Default;\n          return defaultValue;\n        }\n      } // If unknown parameter - Could be a valid parameter not covered by PARAMS\n      // Attempt to query for it and let WebGL report errors\n\n\n      return this._getParameter(pname, opts);\n    } // Many resources support a getParameter call -\n    // getParameters will get all parameters - slow but useful for debugging\n    // eslint-disable-next-line complexity\n\n  }, {\n    key: \"getParameters\",\n    value: function getParameters() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _ref2 = {},\n          parameters = _ref2.parameters,\n          keys = _ref2.keys; // Get parameter definitions for this Resource\n\n      var PARAMETERS = this.constructor.PARAMETERS || {};\n      var isWebgl2 = isWebGL2(this.gl);\n      var values = {}; // Query all parameters if no list provided\n\n      var parameterKeys = parameters || Object.keys(PARAMETERS); // WEBGL limits\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = parameterKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var pname = _step.value;\n          var parameter = PARAMETERS[pname]; // Check if this parameter is available on this platform\n\n          var parameterAvailable = parameter && (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));\n\n          if (parameterAvailable) {\n            var key = keys ? getKey(this.gl, pname) : pname;\n            values[key] = this.getParameter(pname, opts);\n\n            if (keys && parameter.type === 'GLenum') {\n              values[key] = getKey(this.gl, values[key]);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return values;\n    }\n    /**\n     * Update a Resource setting\n     *\n     * @todo - cache parameter to avoid issuing WebGL calls?\n     *\n     * @param {GLenum} pname - parameter (GL constant, value or key)\n     * @param {GLint|GLfloat|GLenum} value\n     * @return {Resource} returns self to enable chaining\n     */\n\n  }, {\n    key: \"setParameter\",\n    value: function setParameter(pname, value) {\n      pname = getKeyValue(this.gl, pname);\n      assert(pname);\n      var parameters = this.constructor.PARAMETERS || {};\n      var parameter = parameters[pname];\n\n      if (parameter) {\n        var isWebgl2 = isWebGL2(this.gl); // Check if this parameter is available on this platform\n\n        var parameterAvailable = (!('webgl2' in parameter) || isWebgl2) && (!('extension' in parameter) || this.gl.getExtension(parameter.extension));\n\n        if (!parameterAvailable) {\n          throw new Error('Parameter not available on this platform');\n        } // Handle string keys\n\n\n        if (parameter.type === 'GLenum') {\n          value = getKeyValue(value);\n        }\n      } // If unknown parameter - Could be a valid parameter not covered by PARAMS\n      // attempt to set it and let WebGL report errors\n\n\n      this._setParameter(pname, value);\n\n      return this;\n    }\n    /*\n     * Batch update resource parameters\n     * Assumes the subclass supports a setParameter call\n     */\n\n  }, {\n    key: \"setParameters\",\n    value: function setParameters(parameters) {\n      for (var pname in parameters) {\n        this.setParameter(pname, parameters[pname]);\n      }\n\n      return this;\n    } // Install stubs for removed methods\n\n  }, {\n    key: \"stubRemovedMethods\",\n    value: function stubRemovedMethods(className, version, methodNames) {\n      return _stubRemovedMethods(this, className, version, methodNames);\n    } // PUBLIC VIRTUAL METHODS\n\n  }, {\n    key: \"initialize\",\n    value: function initialize(opts) {} // PROTECTED METHODS - These must be overridden by subclass\n\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);\n    }\n  }, {\n    key: \"_bindHandle\",\n    value: function _bindHandle() {\n      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);\n    }\n  }, {\n    key: \"_getOptsFromHandle\",\n    value: function _getOptsFromHandle() {\n      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname, opts) {\n      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);\n    }\n    /**\n     * @param {GLenum} pname\n     * @param {GLint|GLfloat|GLenum} param\n     * @return {Sampler} returns self to enable chaining\n     */\n\n  }, {\n    key: \"_setParameter\",\n    value: function _setParameter(pname, value) {\n      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);\n    } // PRIVATE METHODS\n\n  }, {\n    key: \"_context\",\n    value: function _context() {\n      this.gl.luma = this.gl.luma || {};\n      return this.gl.luma;\n    }\n  }, {\n    key: \"_addStats\",\n    value: function _addStats() {\n      var name = this.constructor.name;\n      var stats = luma.stats;\n      stats.resourceCount = stats.resourceCount || 0;\n      stats.resourceMap = stats.resourceMap || {}; // Resource creation stats\n\n      stats.resourceCount++;\n      stats.resourceMap[name] = stats.resourceMap[name] || {\n        created: 0,\n        active: 0\n      };\n      stats.resourceMap[name].created++;\n      stats.resourceMap[name].active++;\n    }\n  }, {\n    key: \"_removeStats\",\n    value: function _removeStats() {\n      var name = this.constructor.name;\n      var stats = luma.stats;\n      stats.resourceMap[name].active--;\n    }\n  }, {\n    key: \"handle\",\n    get: function get() {\n      // TODO - Add context loss handling\n      // Will regenerate and reinitialize the handle if necessary\n      // const glCount = glGetContextLossCount(this.gl);\n      // if (this.glCount !== glCount) {\n      //   this._handle = this._createHandle(this.opts);\n      //   this._glCount = glCount;\n      //   // Reinitialize object\n      //   this.initialize(this.opts);\n      // }\n      return this._handle;\n    }\n  }]);\n\n  return Resource;\n}();\n\nexport { Resource as default };","map":null,"metadata":{},"sourceType":"module"}