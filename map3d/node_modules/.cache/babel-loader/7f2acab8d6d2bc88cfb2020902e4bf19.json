{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n/* eslint-disable no-inline-comments, max-len */\n\n\nimport GL from '../webgl-utils/constants';\nimport { pushContextState, popContextState } from '../webgl-utils/track-context-state';\nimport { log } from '../utils';\nimport { isWebGL2 } from './context';\nimport assert from 'assert'; // map of parameter setter function names, parameter constants, default values and types\n// - Uses gl function names, except when setter function exist that are named differently\n// - When the WebGL api offers <setter> and <setter>Separate (e.g. blendEquation and\n//   blendEquationSeparate, we use non-separate name, but accept both non-separate and\n//   separate arguments. Thus, a `getParameter` call will always return all the separate values\n//   in an array, in a form that can be accepted by the setter.\n\nexport var LUMA_SETTERS = {\n  bindFramebuffer: function bindFramebuffer(gl, args) {\n    assert(args.length === 2, 'bindFramebuffer needs two arguments, target and handle');\n\n    var _args = _slicedToArray(args, 2),\n        target = _args[0],\n        handle = _args[1];\n\n    if (target === GL.FRAMEBUFFER) {\n      if (isWebGL2(gl)) {\n        // NOTE: https://www.khronos.org/registry/OpenGL/extensions/EXT/EXT_framebuffer_blit.txt\n        // As per above spec, under WebGL2, FRAMEBUFFER binding updates both READ_FRAMEBUFFER and DRAW_FRAMEBUFFER\n        // This generates two bindFramebuffer calls so that our cache is correct\n        gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, handle);\n        gl.bindFramebuffer(GL.READ_FRAMEBUFFER, handle);\n      } else {\n        gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n      }\n    } else {\n      // handle GL.DRAW_FRAMEBUFFER and GL.READ_FRAMEBUFFER\n      gl.bindFramebuffer(target, handle);\n    }\n  },\n  blend: function blend(gl, value) {\n    return value ? gl.enable(GL.BLEND) : gl.disable(GL.BLEND);\n  },\n  blendColor: function blendColor(gl, value) {\n    return gl.blendColor.apply(gl, _toConsumableArray(value));\n  },\n  blendEquation: function blendEquation(gl, args) {\n    args = isArray(args) ? args : [args, args];\n    gl.blendEquationSeparate.apply(gl, _toConsumableArray(args));\n  },\n  blendFunc: function blendFunc(gl, args) {\n    args = isArray(args) && args.length === 2 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;\n    gl.blendFuncSeparate.apply(gl, _toConsumableArray(args));\n  },\n  clearColor: function clearColor(gl, value) {\n    return gl.clearColor.apply(gl, _toConsumableArray(value));\n  },\n  clearDepth: function clearDepth(gl, value) {\n    return gl.clearDepth(value);\n  },\n  clearStencil: function clearStencil(gl, value) {\n    return gl.clearStencil(value);\n  },\n  colorMask: function colorMask(gl, value) {\n    return gl.colorMask.apply(gl, _toConsumableArray(value));\n  },\n  cull: function cull(gl, value) {\n    return value ? gl.enable(GL.CULL_FACE) : gl.disable(GL.CULL_FACE);\n  },\n  cullFace: function cullFace(gl, value) {\n    return gl.cullFace(value);\n  },\n  depthTest: function depthTest(gl, value) {\n    return value ? gl.enable(GL.DEPTH_TEST) : gl.disable(GL.DEPTH_TEST);\n  },\n  depthFunc: function depthFunc(gl, value) {\n    return gl.depthFunc(value);\n  },\n  depthMask: function depthMask(gl, value) {\n    return gl.depthMask(value);\n  },\n  depthRange: function depthRange(gl, value) {\n    return gl.depthRange.apply(gl, _toConsumableArray(value));\n  },\n  dither: function dither(gl, value) {\n    return value ? gl.enable(GL.DITHER) : gl.disable(GL.DITHER);\n  },\n  derivativeHint: function derivativeHint(gl, value) {\n    // gl1: 'OES_standard_derivatives'\n    gl.hint(GL.FRAGMENT_SHADER_DERIVATIVE_HINT, value);\n  },\n  frontFace: function frontFace(gl, value) {\n    return gl.frontFace(value);\n  },\n  mipmapHint: function mipmapHint(gl, value) {\n    return gl.hint(GL.GENERATE_MIPMAP_HINT, value);\n  },\n  lineWidth: function lineWidth(gl, value) {\n    return gl.lineWidth(value);\n  },\n  polygonOffsetFill: function polygonOffsetFill(gl, value) {\n    return value ? gl.enable(GL.POLYGON_OFFSET_FILL) : gl.disable(GL.POLYGON_OFFSET_FILL);\n  },\n  polygonOffset: function polygonOffset(gl, value) {\n    return gl.polygonOffset.apply(gl, _toConsumableArray(value));\n  },\n  sampleCoverage: function sampleCoverage(gl, value) {\n    return gl.sampleCoverage.apply(gl, _toConsumableArray(value));\n  },\n  scissorTest: function scissorTest(gl, value) {\n    return value ? gl.enable(GL.SCISSOR_TEST) : gl.disable(GL.SCISSOR_TEST);\n  },\n  scissor: function scissor(gl, value) {\n    return gl.scissor.apply(gl, _toConsumableArray(value));\n  },\n  stencilTest: function stencilTest(gl, value) {\n    return value ? gl.enable(GL.STENCIL_TEST) : gl.disable(GL.STENCIL_TEST);\n  },\n  stencilMask: function stencilMask(gl, value) {\n    value = isArray(value) ? value : [value, value];\n\n    var _value = value,\n        _value2 = _slicedToArray(_value, 2),\n        mask = _value2[0],\n        backMask = _value2[1];\n\n    gl.stencilMaskSeparate(GL.FRONT, mask);\n    gl.stencilMaskSeparate(GL.BACK, backMask);\n  },\n  stencilFunc: function stencilFunc(gl, args) {\n    args = isArray(args) && args.length === 3 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;\n\n    var _args2 = args,\n        _args3 = _slicedToArray(_args2, 6),\n        func = _args3[0],\n        ref = _args3[1],\n        mask = _args3[2],\n        backFunc = _args3[3],\n        backRef = _args3[4],\n        backMask = _args3[5];\n\n    gl.stencilFuncSeparate(GL.FRONT, func, ref, mask);\n    gl.stencilFuncSeparate(GL.BACK, backFunc, backRef, backMask);\n  },\n  stencilOp: function stencilOp(gl, args) {\n    args = isArray(args) && args.length === 3 ? [].concat(_toConsumableArray(args), _toConsumableArray(args)) : args;\n\n    var _args4 = args,\n        _args5 = _slicedToArray(_args4, 6),\n        sfail = _args5[0],\n        dpfail = _args5[1],\n        dppass = _args5[2],\n        backSfail = _args5[3],\n        backDpfail = _args5[4],\n        backDppass = _args5[5];\n\n    gl.stencilOpSeparate(GL.FRONT, sfail, dpfail, dppass);\n    gl.stencilOpSeparate(GL.BACK, backSfail, backDpfail, backDppass);\n  },\n  viewport: function viewport(gl, value) {\n    return gl.viewport.apply(gl, _toConsumableArray(value));\n  }\n}; // HELPERS\n\nfunction isArray(array) {\n  return Array.isArray(array) || ArrayBuffer.isView(array);\n} // GETTERS AND SETTERS\n// Get the parameter value(s) from the context\n\n\nexport { getParameter } from '../webgl-utils/set-parameters'; // Get the parameters from the context\n\nexport { getParameters } from '../webgl-utils/set-parameters'; // Resets gl state to default values.\n\nexport { resetParameters } from '../webgl-utils/set-parameters'; // Get the parameter value(s) from the context\n\nimport { setParameters as glSetParameters } from '../webgl-utils/set-parameters'; // Set the parameter value(s) by key to the context\n// Sets value with key to context.\n// Value may be \"normalized\" (in case a short form is supported). In that case\n// the normalized value is retured.\n\nexport function setParameters(gl, parameters) {\n  glSetParameters(gl, parameters);\n\n  for (var key in parameters) {\n    var setter = LUMA_SETTERS[key];\n\n    if (setter) {\n      setter(gl, parameters[key], key);\n    }\n  }\n} // VERY LIMITED / BASIC GL STATE MANAGEMENT\n// Executes a function with gl states temporarily set, exception safe\n// Currently support pixelStorage, scissor test and framebuffer binding\n\nexport function withParameters(gl, parameters, func) {\n  // assertWebGLContext(gl);\n  var frameBuffer = parameters.frameBuffer,\n      _parameters$nocatch = parameters.nocatch,\n      nocatch = _parameters$nocatch === undefined ? true : _parameters$nocatch;\n  var framebuffer = parameters.framebuffer;\n\n  if (frameBuffer) {\n    log.deprecated('withParameters({frameBuffer})', 'withParameters({framebuffer})');\n    framebuffer = frameBuffer;\n  } // Define a helper function that will reset state after the function call\n\n\n  function resetStateAfterCall() {\n    popContextState(gl);\n  }\n\n  pushContextState(gl);\n  setParameters(gl, parameters);\n\n  if (framebuffer) {\n    framebuffer.bind();\n  } // Setup is done, call the function\n\n\n  var value = void 0;\n\n  if (nocatch) {\n    // Avoid try catch to minimize debugging impact for safe execution paths\n    value = func(gl);\n    resetStateAfterCall();\n  } else {\n    // Wrap in a try-catch to ensure that parameters are restored on exceptions\n    try {\n      value = func(gl);\n    } finally {\n      resetStateAfterCall();\n    }\n  }\n\n  return value;\n} // DEPRECATED\n\nexport function withState() {\n  log.deprecated('withState', 'withParameters');\n  return withParameters.apply(undefined, arguments);\n}\nexport function glContextWithState() {\n  log.deprecated('glContextWithState', 'withParameters');\n  return withParameters.apply(undefined, arguments);\n}","map":null,"metadata":{},"sourceType":"module"}