{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport Resource from './resource';\nimport { parseGLSLCompilerError, getShaderName } from '../webgl-utils';\nimport { assertWebGLContext } from '../webgl-utils';\nimport { uid, log } from '../utils';\nimport assert from '../utils/assert';\nvar ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\nvar GL_FRAGMENT_SHADER = 0x8B30;\nvar GL_VERTEX_SHADER = 0x8B31;\nvar GL_COMPILE_STATUS = 0x8B81;\nvar GL_SHADER_TYPE = 0x8B4F; // For now this is an internal class\n\nexport var Shader =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Shader, _Resource);\n\n  _createClass(Shader, null, [{\n    key: \"getTypeName\",\n    value: function getTypeName(shaderType) {\n      switch (shaderType) {\n        case GL_VERTEX_SHADER:\n          return 'vertex-shader';\n\n        case GL_FRAGMENT_SHADER:\n          return 'fragment-shader';\n\n        default:\n          assert(false);\n          return 'unknown';\n      }\n    }\n    /* eslint-disable max-statements */\n\n  }]);\n\n  function Shader(gl, props) {\n    var _this;\n\n    _classCallCheck(this, Shader);\n\n    assertWebGLContext(gl); // Validate arguments\n\n    assert(typeof props.source === 'string', ERR_SOURCE); // Deduce an id, from shader source, or supplied id, or shader type\n\n    var id = getShaderName(props.source, null) || props.id || uid(\"unnamed \".concat(Shader.getTypeName(props.shaderType)));\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Shader).call(this, gl, {\n      id: id\n    }));\n    _this.shaderType = props.shaderType;\n    _this.source = props.source;\n\n    _this.initialize(props);\n\n    return _this;\n  }\n\n  _createClass(Shader, [{\n    key: \"initialize\",\n    value: function initialize(_ref) {\n      var source = _ref.source;\n      var shaderName = getShaderName(source, null);\n\n      if (shaderName) {\n        this.id = uid(shaderName);\n      }\n\n      this._compile(source);\n    } // Accessors\n\n  }, {\n    key: \"getParameter\",\n    value: function getParameter(pname) {\n      return this.gl.getShaderParameter(this.handle, pname);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.getTypeName(this.shaderType), \":\").concat(this.id);\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return getShaderName(this.source) || 'unnamed-shader';\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.gl.getShaderSource(this.handle);\n    } // Debug method - Returns translated source if available\n\n  }, {\n    key: \"getTranslatedSource\",\n    value: function getTranslatedSource() {\n      var extension = this.gl.getExtension('WEBGL_debug_shaders');\n      return extension ? extension.getTranslatedShaderSource(this.handle) : 'No translated source available. WEBGL_debug_shaders not implemented';\n    } // PRIVATE METHODS\n\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      this.gl.shaderSource(this.handle, this.source);\n      this.gl.compileShader(this.handle); // TODO - For performance reasons, avoid checking shader compilation errors on production?\n      // TODO - Load log even when no error reported, to catch warnings?\n      // https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n\n      var compileStatus = this.getParameter(GL_COMPILE_STATUS);\n\n      if (!compileStatus) {\n        var infoLog = this.gl.getShaderInfoLog(this.handle);\n\n        var _parseGLSLCompilerErr = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id),\n            shaderName = _parseGLSLCompilerErr.shaderName,\n            errors = _parseGLSLCompilerErr.errors,\n            warnings = _parseGLSLCompilerErr.warnings;\n\n        log.error(\"GLSL compilation errors in \".concat(shaderName, \"\\n\").concat(errors))();\n        log.warn(\"GLSL compilation warnings in \".concat(shaderName, \"\\n\").concat(warnings))();\n        throw new Error(\"GLSL compilation errors in \".concat(shaderName));\n      }\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteShader(this.handle);\n    }\n  }, {\n    key: \"_getOptsFromHandle\",\n    value: function _getOptsFromHandle() {\n      return {\n        type: this.getParameter(GL_SHADER_TYPE),\n        source: this.getSource()\n      };\n    }\n  }]);\n\n  return Shader;\n}(Resource);\nexport var VertexShader =\n/*#__PURE__*/\nfunction (_Shader) {\n  _inherits(VertexShader, _Shader);\n\n  function VertexShader(gl, props) {\n    _classCallCheck(this, VertexShader); // DEPRECATED: Support old constructor signature: VertexShader(gl, source)\n\n\n    if (typeof props === 'string') {\n      log.deprecated('new FragmentShader(gl, source)', 'new FragmentShader(gl, {source})', '6.1');\n      props = {\n        source: props\n      };\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(VertexShader).call(this, gl, Object.assign({}, props, {\n      shaderType: GL_VERTEX_SHADER\n    })));\n  } // PRIVATE METHODS\n\n\n  _createClass(VertexShader, [{\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createShader(GL_VERTEX_SHADER);\n    }\n  }]);\n\n  return VertexShader;\n}(Shader);\nexport var FragmentShader =\n/*#__PURE__*/\nfunction (_Shader2) {\n  _inherits(FragmentShader, _Shader2);\n\n  function FragmentShader(gl, props) {\n    _classCallCheck(this, FragmentShader); // DEPRECATED: Support old constructor signature: FragmentShader(gl, source)\n\n\n    if (typeof props === 'string') {\n      log.deprecated('new FragmentShader(gl, source)', 'new FragmentShader(gl, {source})', '6.1');\n      props = {\n        source: props\n      };\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(FragmentShader).call(this, gl, Object.assign({}, props, {\n      shaderType: GL_FRAGMENT_SHADER\n    })));\n  } // PRIVATE METHODS\n\n\n  _createClass(FragmentShader, [{\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createShader(GL_FRAGMENT_SHADER);\n    }\n  }]);\n\n  return FragmentShader;\n}(Shader);","map":null,"metadata":{},"sourceType":"module"}