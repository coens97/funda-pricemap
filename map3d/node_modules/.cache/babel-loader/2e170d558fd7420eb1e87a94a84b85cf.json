{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { Layer } from '../../../lib';\nimport { fp64ify } from '../../../lib/utils/fp64';\nimport { GL, Model, Geometry } from 'luma.gl';\nimport { flatten, log } from '../../../lib/utils';\nimport earcut from 'earcut';\nimport vec3_normalize from 'gl-vec3/normalize';\nimport extrudedChoroplethVertex from './extruded-choropleth-layer-vertex.glsl';\nimport extrudedChoroplethFragment from './extruded-choropleth-layer-fragment.glsl';\nvar DEFAULT_COLOR = [180, 180, 200, 255];\nvar DEFAULT_AMBIENT_COLOR = [255, 255, 255];\nvar DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT = 0.1;\nvar DEFAULT_POINTLIGHT_LOCATION = [40.4406, -79.9959, 100];\nvar DEFAULT_POINTLIGHT_COLOR = [255, 255, 255];\nvar DEFAULT_POINTLIGHT_ATTENUATION = 1.0;\nvar DEFAULT_MATERIAL_SPECULAR_COLOR = [255, 255, 255];\nvar DEFAULT_MATERIAL_SHININESS = 1;\nvar defaultProps = {\n  opacity: 1,\n  elevation: 1\n};\n\nvar ExtrudedChoroplethLayer64 = function (_Layer) {\n  _inherits(ExtrudedChoroplethLayer64, _Layer);\n\n  function ExtrudedChoroplethLayer64(props) {\n    _classCallCheck(this, ExtrudedChoroplethLayer64);\n\n    var _this = _possibleConstructorReturn(this, (ExtrudedChoroplethLayer64.__proto__ || Object.getPrototypeOf(ExtrudedChoroplethLayer64)).call(this, props));\n\n    log.once('ExtrudedChoroplethLayer64 is deprecated. Consider using GeoJsonLayer instead');\n    return _this;\n  }\n\n  _createClass(ExtrudedChoroplethLayer64, [{\n    key: 'getShaders',\n    value: function getShaders() {\n      return {\n        vs: extrudedChoroplethVertex,\n        fs: extrudedChoroplethFragment,\n        modules: ['project64']\n      };\n    }\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {\n      var attributeManager = this.state.attributeManager;\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: this.calculateIndices\n        },\n        positions: {\n          size: 4,\n          update: this.calculatePositions\n        },\n        heights: {\n          size: 2,\n          update: this.calculateHeights\n        },\n        normals: {\n          size: 3,\n          update: this.calculateNormals\n        },\n        colors: {\n          size: 4,\n          update: this.calculateColors\n        }\n      });\n      var gl = this.context.gl;\n      this.setState({\n        numInstances: 0,\n        model: this.getModel(gl)\n      });\n    }\n  }, {\n    key: 'updateState',\n    value: function updateState(_ref) {\n      var changeFlags = _ref.changeFlags;\n      var attributeManager = this.state.attributeManager;\n\n      if (changeFlags.dataChanged) {\n        this.extractExtrudedChoropleth();\n        attributeManager.invalidateAll();\n      }\n\n      var _props = this.props,\n          elevation = _props.elevation,\n          ambientColor = _props.ambientColor,\n          pointLightColor = _props.pointLightColor,\n          pointLightLocation = _props.pointLightLocation,\n          pointLightAmbientCoefficient = _props.pointLightAmbientCoefficient,\n          pointLightAttenuation = _props.pointLightAttenuation,\n          materialSpecularColor = _props.materialSpecularColor,\n          materialShininess = _props.materialShininess;\n      this.setUniforms({\n        elevation: Number.isFinite(elevation) ? elevation : 1,\n        uAmbientColor: ambientColor || DEFAULT_AMBIENT_COLOR,\n        uPointLightAmbientCoefficient: pointLightAmbientCoefficient || DEFAULT_POINTLIGHT_AMBIENT_COEFFICIENT,\n        uPointLightLocation: pointLightLocation || DEFAULT_POINTLIGHT_LOCATION,\n        uPointLightColor: pointLightColor || DEFAULT_POINTLIGHT_COLOR,\n        uPointLightAttenuation: pointLightAttenuation || DEFAULT_POINTLIGHT_ATTENUATION,\n        uMaterialSpecularColor: materialSpecularColor || DEFAULT_MATERIAL_SPECULAR_COLOR,\n        uMaterialShininess: materialShininess || DEFAULT_MATERIAL_SHININESS\n      });\n    }\n  }, {\n    key: 'draw',\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      this.state.model.render(uniforms);\n    }\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(opts) {\n      var info = _get(ExtrudedChoroplethLayer64.prototype.__proto__ || Object.getPrototypeOf(ExtrudedChoroplethLayer64.prototype), 'getPickingInfo', this).call(this, opts);\n\n      var index = this.decodePickingColor(info.color);\n      var feature = index >= 0 ? this.props.data.features[index] : null;\n      info.feature = feature;\n      info.object = feature;\n      return info;\n    }\n  }, {\n    key: 'getModel',\n    value: function getModel(gl) {\n      // Make sure we have 32 bit support\n      // TODO - this could be done automatically by luma in \"draw\"\n      // when it detects 32 bit indices\n      if (!gl.getExtension('OES_element_index_uint')) {\n        throw new Error('Extruded choropleth layer needs 32 bit indices');\n      } // Buildings are 3d so depth test should be enabled\n      // TODO - it is a little heavy handed to have a layer set this\n      // Alternatively, check depth test and warn if not set, or add a prop\n      // setDepthTest that is on by default.\n\n\n      gl.enable(GL.DEPTH_TEST);\n      gl.depthFunc(GL.LEQUAL);\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: this.props.drawWireframe ? GL.LINES : GL.TRIANGLES\n        }),\n        vertexCount: 0,\n        isIndexed: true\n      }));\n    } // each top vertex is on 3 surfaces\n    // each bottom vertex is on 2 surfaces\n\n  }, {\n    key: 'calculatePositions',\n    value: function calculatePositions(attribute) {\n      var _this2 = this;\n\n      var positions = this.state.positions;\n\n      if (!positions) {\n        positions = flatten(this.state.groupedVertices.map(function (vertices) {\n          var topVertices = Array.prototype.concat.apply([], vertices);\n          var baseVertices = topVertices.map(function (v) {\n            return [v[0], v[1], 0];\n          });\n          return _this2.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n        }));\n      }\n\n      attribute.value = new Float32Array(positions.length / 3 * 4);\n\n      for (var i = 0; i < positions.length / 3; i++) {\n        var _fp64ify = fp64ify(positions[i * 3 + 0]);\n\n        var _fp64ify2 = _slicedToArray(_fp64ify, 2);\n\n        attribute.value[i * 4 + 0] = _fp64ify2[0];\n        attribute.value[i * 4 + 1] = _fp64ify2[1];\n\n        var _fp64ify3 = fp64ify(positions[i * 3 + 1]);\n\n        var _fp64ify4 = _slicedToArray(_fp64ify3, 2);\n\n        attribute.value[i * 4 + 2] = _fp64ify4[0];\n        attribute.value[i * 4 + 3] = _fp64ify4[1];\n      }\n    }\n  }, {\n    key: 'calculateHeights',\n    value: function calculateHeights(attribute) {\n      var _this3 = this;\n\n      var positions = this.state.positions;\n\n      if (!positions) {\n        positions = flatten(this.state.groupedVertices.map(function (vertices) {\n          var topVertices = Array.prototype.concat.apply([], vertices);\n          var baseVertices = topVertices.map(function (v) {\n            return [v[0], v[1], 0];\n          });\n          return _this3.props.drawWireframe ? [topVertices, baseVertices] : [topVertices, topVertices, topVertices, baseVertices, baseVertices];\n        }));\n      }\n\n      attribute.value = new Float32Array(positions.length / 3 * 2);\n\n      for (var i = 0; i < positions.length / 3; i++) {\n        var _fp64ify5 = fp64ify(positions[i * 3 + 2] + 0.1);\n\n        var _fp64ify6 = _slicedToArray(_fp64ify5, 2);\n\n        attribute.value[i * 2 + 0] = _fp64ify6[0];\n        attribute.value[i * 2 + 1] = _fp64ify6[1];\n      }\n    }\n  }, {\n    key: 'calculateNormals',\n    value: function calculateNormals(attribute) {\n      var _this4 = this;\n\n      var up = [0, 1, 0];\n      var normals = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n        var topNormals = new Array(countVertices(vertices)).fill(up);\n        var sideNormals = vertices.map(function (polygon) {\n          return _this4.calculateSideNormals(polygon);\n        });\n        var sideNormalsForward = sideNormals.map(function (n) {\n          return n[0];\n        });\n        var sideNormalsBackward = sideNormals.map(function (n) {\n          return n[1];\n        });\n        return _this4.props.drawWireframe ? [topNormals, topNormals] : [topNormals, sideNormalsForward, sideNormalsBackward, sideNormalsForward, sideNormalsBackward];\n      });\n      attribute.value = new Float32Array(flatten(normals));\n    }\n  }, {\n    key: 'calculateSideNormals',\n    value: function calculateSideNormals(vertices) {\n      var numVertices = vertices.length;\n      var normals = [];\n\n      for (var i = 0; i < numVertices - 1; i++) {\n        var n = getNormal(vertices[i], vertices[i + 1]);\n        normals.push(n);\n      }\n\n      return [[].concat(normals, [normals[0]]), [normals[0]].concat(normals)];\n    }\n  }, {\n    key: 'calculateIndices',\n    value: function calculateIndices(attribute) {\n      var _this5 = this; // adjust index offset for multiple buildings\n\n\n      var multiplier = this.props.drawWireframe ? 2 : 5;\n      var offsets = this.state.groupedVertices.reduce(function (acc, vertices) {\n        return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + countVertices(vertices) * multiplier]);\n      }, [0]);\n      var indices = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n        return _this5.props.drawWireframe ? // 1. get sequentially ordered indices of each building wireframe\n        // 2. offset them by the number of indices in previous buildings\n        _this5.calculateContourIndices(vertices, offsets[buildingIndex]) : // 1. get triangulated indices for the internal areas\n        // 2. offset them by the number of indices in previous buildings\n        _this5.calculateSurfaceIndices(vertices, offsets[buildingIndex]);\n      });\n      attribute.value = new Uint32Array(flatten(indices));\n      attribute.target = GL.ELEMENT_ARRAY_BUFFER;\n      this.state.model.setVertexCount(attribute.value.length / attribute.size);\n    }\n  }, {\n    key: 'calculateColors',\n    value: function calculateColors(attribute) {\n      var _this6 = this;\n\n      var colors = this.state.groupedVertices.map(function (vertices, buildingIndex) {\n        var color = _this6.props.color;\n        var baseColor = color || DEFAULT_COLOR;\n        var topColor = color || DEFAULT_COLOR;\n        var numVertices = countVertices(vertices);\n        var topColors = new Array(numVertices).fill(topColor);\n        var baseColors = new Array(numVertices).fill(baseColor);\n        return _this6.props.drawWireframe ? [topColors, baseColors] : [topColors, topColors, topColors, baseColors, baseColors];\n      });\n      attribute.value = new Float32Array(flatten(colors));\n    }\n  }, {\n    key: 'extractExtrudedChoropleth',\n    value: function extractExtrudedChoropleth() {\n      var _this7 = this;\n\n      var data = this.props.data; // Generate a flat list of buildings\n\n      this.state.buildings = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        var _loop = function _loop() {\n          var _state$buildings;\n\n          var building = _step.value;\n          var properties = building.properties,\n              geometry = building.geometry;\n          var coordinates = geometry.coordinates,\n              type = geometry.type;\n\n          if (!properties.height) {\n            properties.height = Math.random() * 1000;\n          }\n\n          switch (type) {\n            case 'MultiPolygon':\n              // Maps to multiple buildings\n              var buildings = coordinates.map(function (coords) {\n                return {\n                  coordinates: coords,\n                  properties: properties\n                };\n              });\n\n              (_state$buildings = _this7.state.buildings).push.apply(_state$buildings, _toConsumableArray(buildings));\n\n              break;\n\n            case 'Polygon':\n              // Maps to a single building\n              _this7.state.buildings.push({\n                coordinates: coordinates,\n                properties: properties\n              });\n\n              break;\n\n            default: // We are ignoring Points for now\n\n          }\n        };\n\n        for (var _iterator = data.features[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          _loop();\n        } // Generate vertices for the building list\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.state.groupedVertices = this.state.buildings.map(function (building) {\n        return building.coordinates.map(function (polygon) {\n          return polygon.map(function (coordinate) {\n            return [coordinate[0], coordinate[1], building.properties.height || 10];\n          });\n        });\n      });\n    }\n  }, {\n    key: 'calculateContourIndices',\n    value: function calculateContourIndices(vertices, offset) {\n      var stride = countVertices(vertices);\n      return vertices.map(function (polygon) {\n        var indices = [offset];\n        var numVertices = polygon.length; // building top\n        // use vertex pairs for GL.LINES => [0, 1, 1, 2, 2, ..., n-1, n-1, 0]\n\n        for (var i = 1; i < numVertices - 1; i++) {\n          indices.push(i + offset, i + offset);\n        }\n\n        indices.push(offset); // building sides\n\n        for (var _i = 0; _i < numVertices - 1; _i++) {\n          indices.push(_i + offset, _i + stride + offset);\n        }\n\n        offset += numVertices;\n        return indices;\n      });\n    }\n  }, {\n    key: 'calculateSurfaceIndices',\n    value: function calculateSurfaceIndices(vertices, offset) {\n      var stride = countVertices(vertices);\n      var holes = null;\n      var quad = [[0, 1], [0, 3], [1, 2], [1, 2], [0, 3], [1, 4]];\n\n      if (vertices.length > 1) {\n        holes = vertices.reduce(function (acc, polygon) {\n          return [].concat(_toConsumableArray(acc), [acc[acc.length - 1] + polygon.length]);\n        }, [0]).slice(1, vertices.length);\n      }\n\n      var topIndices = earcut(flatten(vertices), holes, 3).map(function (index) {\n        return index + offset;\n      });\n      var sideIndices = vertices.map(function (polygon) {\n        var numVertices = polygon.length; // building top\n\n        var indices = []; // building sides\n\n        for (var i = 0; i < numVertices - 1; i++) {\n          indices.push.apply(indices, _toConsumableArray(drawRectangle(i)));\n        }\n\n        offset += numVertices;\n        return indices;\n      });\n      return [topIndices, sideIndices];\n\n      function drawRectangle(i) {\n        return quad.map(function (v) {\n          return i + v[0] + stride * v[1] + offset;\n        });\n      }\n    }\n  }]);\n\n  return ExtrudedChoroplethLayer64;\n}(Layer);\n\nexport default ExtrudedChoroplethLayer64;\nExtrudedChoroplethLayer64.layerName = 'ExtrudedChoroplethLayer64';\nExtrudedChoroplethLayer64.defaultProps = defaultProps;\n/*\n * helpers\n */\n// get normal vector of line segment\n\nfunction getNormal(p1, p2) {\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    return [1, 0, 0];\n  }\n\n  var degrees2radians = Math.PI / 180;\n  var lon1 = degrees2radians * p1[0];\n  var lon2 = degrees2radians * p2[0];\n  var lat1 = degrees2radians * p1[1];\n  var lat2 = degrees2radians * p2[1];\n  var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n  var b = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n  return vec3_normalize([], [b, 0, -a]);\n} // count number of vertices in geojson polygon\n\n\nfunction countVertices(vertices) {\n  return vertices.reduce(function (count, polygon) {\n    return count + polygon.length;\n  }, 0);\n}","map":null,"metadata":{},"sourceType":"module"}