{"ast":null,"code":"function _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport { Layer, log } from '@deck.gl/core';\nimport GL from 'luma.gl/constants';\nimport { Model, CylinderGeometry, fp64 } from 'luma.gl';\nvar fp64LowPart = fp64.fp64LowPart;\nimport vs from './hexagon-cell-layer-vertex.glsl';\nimport fs from './hexagon-cell-layer-fragment.glsl';\nvar DEFAULT_COLOR = [255, 0, 255, 255];\nvar defaultProps = {\n  hexagonVertices: null,\n  radius: null,\n  angle: null,\n  coverage: {\n    type: 'number',\n    min: 0,\n    max: 1,\n    value: 1\n  },\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  extruded: true,\n  fp64: false,\n  getCentroid: function getCentroid(x) {\n    return x.centroid;\n  },\n  getColor: DEFAULT_COLOR,\n  getElevation: 1000,\n  lightSettings: {}\n};\n\nvar HexagonCellLayer =\n/*#__PURE__*/\nfunction (_Layer) {\n  _inherits(HexagonCellLayer, _Layer);\n\n  function HexagonCellLayer(props) {\n    _classCallCheck(this, HexagonCellLayer);\n\n    var missingProps = false;\n\n    if (!props.hexagonVertices && (!props.radius || !Number.isFinite(props.angle))) {\n      log.once(0, 'HexagonCellLayer: Either hexagonVertices or radius and angle are ' + 'needed to calculate primitive hexagon.')();\n      missingProps = true;\n    } else if (props.hexagonVertices && (!Array.isArray(props.hexagonVertices) || props.hexagonVertices.length < 6)) {\n      log.once(0, 'HexagonCellLayer: hexagonVertices needs to be an array of 6 points')();\n      missingProps = true;\n    }\n\n    if (missingProps) {\n      log.once(0, 'Now using 1000 meter as default radius, 0 as default angle')();\n      props.radius = 1000;\n      props.angle = 0;\n    }\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(HexagonCellLayer).call(this, props));\n  }\n\n  _createClass(HexagonCellLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n      return {\n        vs: vs,\n        fs: fs,\n        modules: [projectModule, 'lighting', 'picking']\n      };\n    }\n    /**\n     * DeckGL calls initializeState when GL context is available\n     * Essentially a deferred constructor\n     */\n\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var attributeManager = this.getAttributeManager();\n      /* eslint-disable max-len */\n\n      attributeManager.addInstanced({\n        instancePositions: {\n          size: 2,\n          transition: true,\n          accessor: 'getCentroid'\n        },\n        instanceElevations: {\n          size: 1,\n          transition: true,\n          accessor: 'getElevation'\n        },\n        instancePositions64xyLow: {\n          size: 2,\n          accessor: 'getCentroid',\n          update: this.calculateInstancePositions64xyLow\n        },\n        instanceColors: {\n          size: 4,\n          type: GL.UNSIGNED_BYTE,\n          transition: true,\n          accessor: 'getColor',\n          defaultValue: DEFAULT_COLOR\n        }\n      });\n      /* eslint-enable max-len */\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      _get(_getPrototypeOf(HexagonCellLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      if (props.fp64 !== oldProps.fp64) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model.delete();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n\n      if (props.hexagonVertices !== oldProps.hexagonVertices || props.radius !== oldProps.radius || props.angle !== oldProps.angle) {\n        this.updateRadiusAngle();\n      }\n    }\n  }, {\n    key: \"updateRadiusAngle\",\n    value: function updateRadiusAngle() {\n      var _this$props = this.props,\n          angle = _this$props.angle,\n          radius = _this$props.radius;\n      var hexagonVertices = this.props.hexagonVertices;\n\n      if (Array.isArray(hexagonVertices) && hexagonVertices.length >= 6) {\n        // calculate angle and vertices from hexagonVertices if provided\n        var vertices = this.props.hexagonVertices;\n        var vertex0 = vertices[0];\n        var vertex3 = vertices[3]; // transform to space coordinates\n\n        var viewport = this.context.viewport;\n\n        var _viewport$getDistance = viewport.getDistanceScales(),\n            pixelsPerMeter = _viewport$getDistance.pixelsPerMeter;\n\n        var spaceCoord0 = this.projectFlat(vertex0);\n        var spaceCoord3 = this.projectFlat(vertex3); // distance between two close centroids\n\n        var dx = spaceCoord0[0] - spaceCoord3[0];\n        var dy = spaceCoord0[1] - spaceCoord3[1];\n        var dxy = Math.sqrt(dx * dx + dy * dy); // Calculate angle that the perpendicular hexagon vertex axis is tilted\n\n        angle = Math.acos(dx / dxy) * -Math.sign(dy) + Math.PI / 2;\n        radius = dxy / 2 / pixelsPerMeter[0];\n      }\n\n      this.setState({\n        angle: angle,\n        radius: radius\n      });\n    }\n  }, {\n    key: \"getCylinderGeometry\",\n    value: function getCylinderGeometry(radius) {\n      return new CylinderGeometry({\n        radius: radius,\n        topRadius: radius,\n        bottomRadius: radius,\n        topCap: true,\n        bottomCap: true,\n        height: 1,\n        verticalAxis: 'z',\n        nradial: 6,\n        nvertical: 1\n      });\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: this.getCylinderGeometry(1),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      }));\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props2 = this.props,\n          elevationScale = _this$props2.elevationScale,\n          extruded = _this$props2.extruded,\n          coverage = _this$props2.coverage;\n      var _this$state = this.state,\n          radius = _this$state.radius,\n          angle = _this$state.angle;\n      this.state.model.render(Object.assign({}, uniforms, {\n        radius: radius,\n        angle: angle,\n        extruded: extruded,\n        coverage: coverage,\n        elevationScale: elevationScale\n      }));\n    }\n  }, {\n    key: \"calculateInstancePositions64xyLow\",\n    value: function calculateInstancePositions64xyLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      var _this$props3 = this.props,\n          data = _this$props3.data,\n          getCentroid = _this$props3.getCentroid;\n      var value = attribute.value;\n      var i = 0;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = data[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          var position = getCentroid(object);\n          value[i++] = fp64LowPart(position[0]);\n          value[i++] = fp64LowPart(position[1]);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return HexagonCellLayer;\n}(Layer);\n\nexport { HexagonCellLayer as default };\nHexagonCellLayer.layerName = 'HexagonCellLayer';\nHexagonCellLayer.defaultProps = defaultProps;","map":null,"metadata":{},"sourceType":"module"}