{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport assert from '../utils/assert';\nimport { deepEqual } from '../utils/deep-equal';\nimport View from '../views/view';\nimport Viewport from '../viewports/viewport';\nimport log from '../utils/log';\nimport { flatten } from '../utils/flatten';\n\nvar ViewManager =\n/*#__PURE__*/\nfunction () {\n  function ViewManager() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ViewManager); // List of view descriptors, gets re-evaluated when width/height changes\n\n\n    this.views = [];\n    this.width = 100;\n    this.height = 100;\n    this.viewState = {};\n    this.controllers = {};\n    this._viewports = []; // Generated viewports\n\n    this._viewportMap = {};\n    this._isUpdating = false;\n    this._needsRedraw = 'Initial render';\n    this._needsUpdate = true;\n    this._eventManager = props.eventManager;\n    this._eventCallbacks = {\n      onViewStateChange: props.onViewStateChange,\n      onInteractiveStateChange: props.onInteractiveStateChange\n    };\n    Object.seal(this); // Init with default map viewport\n\n    this.setProps(props);\n  }\n\n  _createClass(ViewManager, [{\n    key: \"finalize\",\n    value: function finalize() {\n      for (var key in this.controllers) {\n        if (this.controllers[key]) {\n          this.controllers[key].finalize();\n        }\n      }\n\n      this.controllers = {};\n    } // Check if a redraw is needed\n\n  }, {\n    key: \"needsRedraw\",\n    value: function needsRedraw() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref$clearRedrawFlags = _ref.clearRedrawFlags,\n          clearRedrawFlags = _ref$clearRedrawFlags === void 0 ? true : _ref$clearRedrawFlags;\n\n      var redraw = this._needsRedraw;\n\n      if (clearRedrawFlags) {\n        this._needsRedraw = false;\n      }\n\n      return redraw;\n    } // Layers will be redrawn (in next animation frame)\n\n  }, {\n    key: \"setNeedsRedraw\",\n    value: function setNeedsRedraw(reason) {\n      this._needsRedraw = this._needsRedraw || reason;\n    } // Layers will be updated deeply (in next animation frame)\n    // Potentially regenerating attributes and sub layers\n\n  }, {\n    key: \"setNeedsUpdate\",\n    value: function setNeedsUpdate(reason) {\n      this._needsUpdate = this._needsUpdate || reason;\n      this._needsRedraw = this._needsRedraw || reason;\n    }\n    /** Get a set of viewports for a given width and height\n     * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props\n     * @param rect (object, optional) - filter the viewports\n     *   + not provided - return all viewports\n     *   + {x, y} - only return viewports that contain this pixel\n     *   + {x, y, width, height} - only return viewports that overlap with this rectangle\n     */\n\n  }, {\n    key: \"getViewports\",\n    value: function getViewports(rect) {\n      if (rect) {\n        return this._viewports.filter(function (viewport) {\n          return viewport.containsPixel(rect);\n        });\n      }\n\n      return this._viewports;\n    }\n  }, {\n    key: \"getViews\",\n    value: function getViews() {\n      var viewMap = {};\n      this.views.forEach(function (view) {\n        viewMap[view.id] = view;\n      });\n      return viewMap;\n    } // Resolves a viewId string to a View, if already a View returns it.\n\n  }, {\n    key: \"getView\",\n    value: function getView(viewOrViewId) {\n      return typeof viewOrViewId === 'string' ? this.views.find(function (view) {\n        return view.id === viewOrViewId;\n      }) : viewOrViewId;\n    } // Returns the viewState for a specific viewId. Matches the viewState by\n    // 1. view.viewStateId\n    // 2. view.id\n    // 3. root viewState\n    // then applies the view's filter if any\n\n  }, {\n    key: \"getViewState\",\n    value: function getViewState(viewId) {\n      var view = this.getView(viewId); // Backward compatibility: view state for single view\n\n      var viewState = view && this.viewState[view.getViewStateId()] || this.viewState;\n      return view ? view.filterViewState(viewState) : viewState;\n    }\n  }, {\n    key: \"getViewport\",\n    value: function getViewport(viewId) {\n      return this._viewportMap[viewId];\n    }\n    /**\n     * Projects xyz (possibly latitude and longitude) to pixel coordinates in window\n     * using viewport projection parameters\n     * - [longitude, latitude] to [x, y]\n     * - [longitude, latitude, Z] => [x, y, z]\n     * Note: By default, returns top-left coordinates for canvas/SVG type render\n     *\n     * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]\n     * @param {Object} opts - options\n     * @param {Object} opts.topLeft=true - Whether projected coords are top left\n     * @return {Array} - [x, y] or [x, y, z] in top left coords\n     */\n\n  }, {\n    key: \"project\",\n    value: function project(xyz) {\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        topLeft: true\n      };\n      var viewports = this.getViewports();\n\n      for (var i = viewports.length - 1; i >= 0; --i) {\n        var viewport = viewports[i];\n\n        if (viewport.contains(xyz, opts)) {\n          return viewport.project(xyz, opts);\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Unproject pixel coordinates on screen onto world coordinates,\n     * (possibly [lon, lat]) on map.\n     * - [x, y] => [lng, lat]\n     * - [x, y, z] => [lng, lat, Z]\n     * @param {Array} xyz -\n     * @param {Object} opts - options\n     * @param {Object} opts.topLeft=true - Whether origin is top left\n     * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]\n     */\n\n  }, {\n    key: \"unproject\",\n    value: function unproject(xyz, opts) {\n      var viewports = this.getViewports();\n\n      for (var i = viewports.length - 1; i >= 0; --i) {\n        var viewport = viewports[i];\n\n        if (viewport.containsPixel(xyz, opts)) {\n          return viewport.unproject(xyz);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('views' in props) {\n        this._setViews(props.views);\n      } // TODO - support multiple view states\n\n\n      if ('viewState' in props) {\n        this._setViewState(props.viewState);\n      }\n\n      if ('width' in props || 'height' in props) {\n        this._setSize(props.width, props.height);\n      } // Important: avoid invoking _update() inside itself\n      // Nested updates result in unexpected side effects inside _rebuildViewports()\n      // when using auto control in pure-js\n\n\n      if (!this._isUpdating) {\n        this._update();\n      }\n    }\n  }, {\n    key: \"_update\",\n    value: function _update() {\n      this._isUpdating = true; // Only rebuild viewports if the update flag is set\n\n      if (this._needsUpdate) {\n        this._needsUpdate = false;\n\n        this._rebuildViewports();\n      } // If viewport transition(s) are triggered during viewports update, controller(s)\n      // will immediately call `onViewStateChange` which calls `viewManager.setProps` again.\n\n\n      if (this._needsUpdate) {\n        this._needsUpdate = false;\n\n        this._rebuildViewports();\n      }\n\n      this._isUpdating = false;\n    }\n  }, {\n    key: \"_setSize\",\n    value: function _setSize(width, height) {\n      assert(Number.isFinite(width) && Number.isFinite(height));\n\n      if (width !== this.width || height !== this.height) {\n        this.width = width;\n        this.height = height;\n        this.setNeedsUpdate('Size changed');\n      }\n    } // Update the view descriptor list and set change flag if needed\n    // Does not actually rebuild the `Viewport`s until `getViewports` is called\n\n  }, {\n    key: \"_setViews\",\n    value: function _setViews(views) {\n      // DEPRECATED: Ensure any \"naked\" Viewports are wrapped in View instances\n      views = flatten(views, {\n        filter: Boolean\n      }).map(function (view) {\n        return view instanceof Viewport ? new View({\n          viewportInstance: view\n        }) : view;\n      });\n\n      var viewsChanged = this._diffViews(views, this.views);\n\n      if (viewsChanged) {\n        this.setNeedsUpdate('views changed');\n      }\n\n      this.views = views;\n    }\n  }, {\n    key: \"_setViewState\",\n    value: function _setViewState(viewState) {\n      if (viewState) {\n        var viewStateChanged = !deepEqual(viewState, this.viewState);\n\n        if (viewStateChanged) {\n          this.setNeedsUpdate('viewState changed');\n        }\n\n        this.viewState = viewState;\n      } else {\n        log.warn('setting null viewState')();\n      }\n    } //\n    // PRIVATE METHODS\n    //\n\n  }, {\n    key: \"_onViewStateChange\",\n    value: function _onViewStateChange(viewId, event) {\n      event.viewId = viewId;\n\n      this._eventCallbacks.onViewStateChange(event);\n    }\n  }, {\n    key: \"_createController\",\n    value: function _createController(props) {\n      var Controller = props.type;\n      var controller = new Controller(Object.assign({\n        eventManager: this._eventManager,\n        // Set an internal callback that calls the prop callback if provided\n        onViewStateChange: this._onViewStateChange.bind(this, props.id),\n        onStateChange: this._eventCallbacks.onInteractiveStateChange\n      }, props));\n      return controller;\n    }\n  }, {\n    key: \"_updateController\",\n    value: function _updateController(view, viewState, viewport, controller) {\n      if (view.controller) {\n        var controllerProps = Object.assign({}, view.controller, view.defaultState, viewState, {\n          id: view.id,\n          x: viewport.x,\n          y: viewport.y,\n          width: viewport.width,\n          height: viewport.height\n        }); // TODO - check if view / controller type has changed, and replace the controller\n\n        if (controller) {\n          controller.setProps(controllerProps);\n        } else {\n          controller = this._createController(controllerProps);\n        }\n\n        return controller;\n      }\n\n      return null;\n    } // Rebuilds viewports from descriptors towards a certain window size\n\n  }, {\n    key: \"_rebuildViewports\",\n    value: function _rebuildViewports() {\n      var _this = this;\n\n      var width = this.width,\n          height = this.height,\n          views = this.views;\n      var oldControllers = this.controllers;\n      this.controllers = {};\n      this._viewports = views.map(function (view) {\n        var viewState = _this.getViewState(view);\n\n        var viewport = view.makeViewport({\n          width: width,\n          height: height,\n          viewState: viewState\n        }); // Update the controller\n\n        _this.controllers[view.id] = _this._updateController(view, viewState, viewport, oldControllers[view.id]);\n        return viewport;\n      }); // Remove unused controllers\n\n      for (var id in oldControllers) {\n        if (oldControllers[id] && !this.controllers[id]) {\n          oldControllers[id].finalize();\n        }\n      }\n\n      this._buildViewportMap();\n    }\n  }, {\n    key: \"_buildViewportMap\",\n    value: function _buildViewportMap() {\n      var _this2 = this; // Build a view id to view index\n\n\n      this._viewportMap = {};\n\n      this._viewports.forEach(function (viewport) {\n        if (viewport.id) {\n          // TODO - issue warning if multiple viewports use same id\n          _this2._viewportMap[viewport.id] = _this2._viewportMap[viewport.id] || viewport;\n        }\n      });\n    } // Check if viewport array has changed, returns true if any change\n    // Note that descriptors can be the same\n\n  }, {\n    key: \"_diffViews\",\n    value: function _diffViews(newViews, oldViews) {\n      if (newViews.length !== oldViews.length) {\n        return true;\n      }\n\n      return newViews.some(function (_, i) {\n        return !newViews[i].equals(oldViews[i]);\n      });\n    }\n  }]);\n\n  return ViewManager;\n}();\n\nexport { ViewManager as default };","map":null,"metadata":{},"sourceType":"module"}