{"ast":null,"code":"/* eslint-disable quotes */\n// WebGLRenderingContext related methods\nimport { WebGLRenderingContext, WebGL2RenderingContext } from '../webgl-utils';\nimport { createHeadlessContext } from './create-headless-context';\nimport { getCanvas } from './create-canvas';\nimport { createBrowserContext } from './create-browser-context';\nimport trackContextState from './track-context-state';\nimport { makeDebugContext } from './debug-context';\nimport { glGetDebugInfo } from './context-limits';\nimport queryManager from '../webgl-utils/query-manager';\nimport { log as _log, isBrowser } from '../utils';\nimport assert from '../utils/assert'; // Heuristic testing of contexts (to indentify debug wrappers around gl contexts)\n\nvar GL_ARRAY_BUFFER = 0x8892;\nvar GL_TEXTURE_BINDING_3D = 0x806A;\nexport var ERR_CONTEXT = 'Invalid WebGLRenderingContext';\nexport var ERR_WEBGL = ERR_CONTEXT;\nexport var ERR_WEBGL2 = 'Requires WebGL2'; // HACK: avoid use of `gl` parameter name to defeat GL constant inliner, which invalidates check\n\nexport function isWebGL(glContext) {\n  return Boolean(glContext && (glContext instanceof WebGLRenderingContext || glContext.ARRAY_BUFFER === GL_ARRAY_BUFFER));\n} // HACK: avoid use of `gl` parameter name to defeat GL constant inliner, which invalidates check\n\nexport function isWebGL2(glContext) {\n  return Boolean(glContext && (glContext instanceof WebGL2RenderingContext || glContext.TEXTURE_BINDING_3D === GL_TEXTURE_BINDING_3D));\n}\nexport function assertWebGLContext(gl) {\n  // Need to handle debug context\n  assert(isWebGL(gl), ERR_CONTEXT);\n}\nexport function assertWebGL2Context(gl) {\n  // Need to handle debug context\n  assert(isWebGL2(gl), ERR_WEBGL2);\n}\nvar contextDefaults = {\n  // COMMON CONTEXT PARAMETERS\n  // Attempt to allocate WebGL2 context\n  webgl2: true,\n  // Attempt to create a WebGL2 context (false to force webgl1)\n  webgl1: true,\n  // Attempt to create a WebGL1 context (false to fail if webgl2 not available)\n  throwOnFailure: true,\n  manageState: true,\n  // BROWSER CONTEXT PARAMETERS\n  canvas: null,\n  // A canvas element or a canvas string id\n  debug: false,\n  // Instrument context (at the expense of performance)\n  // HEADLESS CONTEXT PARAMETERS\n  width: 800,\n  // width are height are only used by headless gl\n  height: 600 // WEBGL/HEADLESS CONTEXT PARAMETERS\n  // Remaining options are passed through to context creator\n\n};\n/*\n * Change default context creation parameters.\n * Main use case is regression test suite.\n */\n\nexport function setContextDefaults() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  Object.assign(contextDefaults, {\n    width: 1,\n    height: 1\n  }, opts);\n}\n/*\n * Creates a context giving access to the WebGL API\n */\n\n/* eslint-disable complexity, max-statements */\n\nexport function createGLContext() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  opts = Object.assign({}, contextDefaults, opts);\n  var _opts = opts,\n      canvas = _opts.canvas,\n      width = _opts.width,\n      height = _opts.height,\n      throwOnError = _opts.throwOnError,\n      manageState = _opts.manageState,\n      debug = _opts.debug; // Error reporting function, enables exceptions to be disabled\n\n  function onError(message) {\n    if (throwOnError) {\n      throw new Error(message);\n    } // log.log(0, message)();\n\n\n    return null;\n  }\n\n  var gl;\n\n  if (isBrowser) {\n    // Get or create a canvas\n    var targetCanvas = getCanvas({\n      canvas: canvas,\n      width: width,\n      height: height,\n      onError: onError\n    }); // Create a WebGL context in the canvas\n\n    gl = createBrowserContext({\n      canvas: targetCanvas,\n      opts: opts\n    });\n  } else {\n    // Create a headless-gl context under Node.js\n    gl = createHeadlessContext({\n      width: width,\n      height: height,\n      opts: opts,\n      onError: onError\n    });\n  }\n\n  if (!gl) {\n    return null;\n  } // Install context state tracking\n\n\n  if (manageState) {\n    trackContextState(gl, {\n      copyState: false,\n      log: function log() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return _log.log.apply(_log, [1].concat(args))();\n      }\n    });\n  } // Add debug instrumentation to the context\n\n\n  if (isBrowser && debug) {\n    gl = makeDebugContext(gl, {\n      debug: debug\n    }); // Debug forces log level to at least 1\n\n    _log.priority = Math.max(_log.priority, 1); // Log some debug info about the context\n  } // Log context information\n\n\n  logInfo(gl); // Add to seer integration\n\n  return gl;\n}\nexport function destroyGLContext(gl) {\n  // TODO - Remove from seer integration\n  // TODO - Unregister any tracking/polyfills\n  // There is no way to delete browser based context\n  // Destroy headless gl context\n  var ext = gl.getExtension('STACKGL_destroy_context');\n\n  if (ext) {\n    ext.destroy();\n  }\n}\n/**\n * Resize the canvas' drawing buffer.\n *\n * Can match the canvas CSS size, and optionally also consider devicePixelRatio\n * Can be called every frame\n *\n * Regardless of size, the drawing buffer will always be scaled to the viewport, but\n * for best visual results, usually set to either:\n *  canvas CSS width x canvas CSS height\n *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio\n * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n *\n * resizeGLContext(gl, {width, height, useDevicePixels})\n */\n\nexport function resizeGLContext(gl) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Resize browser context\n\n  if (gl.canvas) {\n    /* global window */\n    var devicePixelRatio = opts.useDevicePixels ? window.devicePixelRatio || 1 : 1;\n    var width = \"width\" in opts ? opts.width : gl.canvas.clientWidth;\n    var height = \"height\" in opts ? opts.height : gl.canvas.clientHeight;\n    gl.canvas.width = width * devicePixelRatio;\n    gl.canvas.height = height * devicePixelRatio;\n    return;\n  } // Resize headless gl context\n\n\n  var ext = gl.getExtension('STACKGL_resize_drawingbuffer');\n\n  if (ext && \"width\" in opts && \"height\" in opts) {\n    ext.resize(opts.width, opts.height);\n  }\n} // POLLING FOR PENDING QUERIES\n// Calling this function checks all pending queries for completion\n\nexport function pollGLContext(gl) {\n  queryManager.poll(gl);\n} // HELPER METHODS\n\nfunction logInfo(gl) {\n  var webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';\n  var info = glGetDebugInfo(gl);\n  var driver = info ? \"(\".concat(info.vendor, \",\").concat(info.renderer, \")\") : '';\n  var debug = gl.debug ? ' debug' : '';\n\n  _log.once(0, \"\".concat(webGL).concat(debug, \" context \").concat(driver))();\n}","map":null,"metadata":{},"sourceType":"module"}