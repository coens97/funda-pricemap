{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport ViewState from './view-state';\nimport PerspectiveMercatorViewport from '../viewports/web-mercator-viewport';\nimport assert from 'assert';\nimport { mod } from '../utils/math-utils'; // MAPBOX LIMITS\n\nexport var MAPBOX_LIMITS = {\n  minZoom: 0,\n  maxZoom: 20,\n  minPitch: 0,\n  maxPitch: 60\n};\nvar defaultState = {\n  pitch: 0,\n  bearing: 0,\n  altitude: 1.5\n};\n\nfunction ensureFinite(value, fallbackValue) {\n  return Number.isFinite(value) ? value : fallbackValue;\n}\n\nvar MapState = function (_ViewState) {\n  _inherits(MapState, _ViewState);\n\n  function MapState() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        width = _ref.width,\n        height = _ref.height,\n        latitude = _ref.latitude,\n        longitude = _ref.longitude,\n        zoom = _ref.zoom,\n        bearing = _ref.bearing,\n        pitch = _ref.pitch,\n        altitude = _ref.altitude,\n        maxZoom = _ref.maxZoom,\n        minZoom = _ref.minZoom,\n        maxPitch = _ref.maxPitch,\n        minPitch = _ref.minPitch,\n        startPanLngLat = _ref.startPanLngLat,\n        startZoomLngLat = _ref.startZoomLngLat,\n        startBearing = _ref.startBearing,\n        startPitch = _ref.startPitch,\n        startZoom = _ref.startZoom;\n\n    _classCallCheck(this, MapState);\n\n    assert(Number.isFinite(longitude), '`longitude` must be supplied');\n    assert(Number.isFinite(latitude), '`latitude` must be supplied');\n    assert(Number.isFinite(zoom), '`zoom` must be supplied');\n\n    var _this = _possibleConstructorReturn(this, (MapState.__proto__ || Object.getPrototypeOf(MapState)).call(this, {\n      width: width,\n      height: height,\n      latitude: latitude,\n      longitude: longitude,\n      zoom: zoom,\n      bearing: bearing,\n      pitch: pitch,\n      altitude: ensureFinite(altitude, defaultState.altitude),\n      maxZoom: ensureFinite(maxZoom, MAPBOX_LIMITS.maxZoom),\n      minZoom: ensureFinite(minZoom, MAPBOX_LIMITS.minZoom),\n      maxPitch: ensureFinite(maxPitch, MAPBOX_LIMITS.maxPitch),\n      minPitch: ensureFinite(minPitch, MAPBOX_LIMITS.minPitch)\n    }));\n\n    _this._interactiveState = {\n      startPanLngLat: startPanLngLat,\n      startZoomLngLat: startZoomLngLat,\n      startBearing: startBearing,\n      startPitch: startPitch,\n      startZoom: startZoom\n    };\n    return _this;\n  }\n  /* Public API */\n\n\n  _createClass(MapState, [{\n    key: 'getInteractiveState',\n    value: function getInteractiveState() {\n      return this._interactiveState;\n    }\n    /**\n     * Start panning\n     * @param {[Number, Number]} pos - position on screen where the pointer grabs\n     */\n\n  }, {\n    key: 'panStart',\n    value: function panStart(_ref2) {\n      var pos = _ref2.pos;\n      return this._getUpdatedState({\n        startPanLngLat: this._unproject(pos)\n      });\n    }\n    /**\n     * Pan\n     * @param {[Number, Number]} pos - position on screen where the pointer is\n     * @param {[Number, Number], optional} startPos - where the pointer grabbed at\n     *   the start of the operation. Must be supplied of `panStart()` was not called\n     */\n\n  }, {\n    key: 'pan',\n    value: function pan(_ref3) {\n      var pos = _ref3.pos,\n          startPos = _ref3.startPos;\n\n      var startPanLngLat = this._interactiveState.startPanLngLat || this._unproject(startPos); // take the start lnglat and put it where the mouse is down.\n\n\n      assert(startPanLngLat, '`startPanLngLat` prop is required ' + 'for mouse pan behavior to calculate where to position the map.');\n\n      var _calculateNewLngLat2 = this._calculateNewLngLat({\n        startPanLngLat: startPanLngLat,\n        pos: pos\n      }),\n          _calculateNewLngLat3 = _slicedToArray(_calculateNewLngLat2, 2),\n          longitude = _calculateNewLngLat3[0],\n          latitude = _calculateNewLngLat3[1];\n\n      return this._getUpdatedState({\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n    /**\n     * End panning\n     * Must call if `panStart()` was called\n     */\n\n  }, {\n    key: 'panEnd',\n    value: function panEnd() {\n      return this._getUpdatedState({\n        startPanLngLat: null\n      });\n    }\n    /**\n     * Start rotating\n     * @param {[Number, Number]} pos - position on screen where the center is\n     */\n\n  }, {\n    key: 'rotateStart',\n    value: function rotateStart(_ref4) {\n      var pos = _ref4.pos;\n      return this._getUpdatedState({\n        startBearing: this._viewportProps.bearing,\n        startPitch: this._viewportProps.pitch\n      });\n    }\n    /**\n     * Rotate\n     * @param {Number} deltaScaleX - a number between [-1, 1] specifying the\n     *   change to bearing.\n     * @param {Number} deltaScaleY - a number between [-1, 1] specifying the\n     *   change to pitch. -1 sets to minPitch and 1 sets to maxPitch.\n     */\n\n  }, {\n    key: 'rotate',\n    value: function rotate(_ref5) {\n      var deltaScaleX = _ref5.deltaScaleX,\n          deltaScaleY = _ref5.deltaScaleY;\n      assert(deltaScaleX >= -1 && deltaScaleX <= 1, '`deltaScaleX` must be a number between [-1, 1]');\n      assert(deltaScaleY >= -1 && deltaScaleY <= 1, '`deltaScaleY` must be a number between [-1, 1]');\n      var _interactiveState = this._interactiveState,\n          startBearing = _interactiveState.startBearing,\n          startPitch = _interactiveState.startPitch;\n\n      if (!Number.isFinite(startBearing)) {\n        startBearing = this._viewportProps.bearing;\n      }\n\n      if (!Number.isFinite(startPitch)) {\n        startPitch = this._viewportProps.pitch;\n      }\n\n      var _calculateNewPitchAnd = this._calculateNewPitchAndBearing({\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY,\n        startBearing: startBearing,\n        startPitch: startPitch\n      }),\n          pitch = _calculateNewPitchAnd.pitch,\n          bearing = _calculateNewPitchAnd.bearing;\n\n      return this._getUpdatedState({\n        bearing: bearing,\n        pitch: pitch\n      });\n    }\n    /**\n     * End rotating\n     * Must call if `rotateStart()` was called\n     */\n\n  }, {\n    key: 'rotateEnd',\n    value: function rotateEnd() {\n      return this._getUpdatedState({\n        startBearing: null,\n        startPitch: null\n      });\n    }\n    /**\n     * Start zooming\n     * @param {[Number, Number]} pos - position on screen where the center is\n     */\n\n  }, {\n    key: 'zoomStart',\n    value: function zoomStart(_ref6) {\n      var pos = _ref6.pos;\n      return this._getUpdatedState({\n        startZoomLngLat: this._unproject(pos),\n        startZoom: this._viewportProps.zoom\n      });\n    }\n    /**\n     * Zoom\n     * @param {[Number, Number]} pos - position on screen where the current center is\n     * @param {[Number, Number]} startPos - the center position at\n     *   the start of the operation. Must be supplied of `zoomStart()` was not called\n     * @param {Number} scale - a number between [0, 1] specifying the accumulated\n     *   relative scale.\n     */\n\n  }, {\n    key: 'zoom',\n    value: function zoom(_ref7) {\n      var pos = _ref7.pos,\n          startPos = _ref7.startPos,\n          scale = _ref7.scale;\n      assert(scale > 0, '`scale` must be a positive number'); // Make sure we zoom around the current mouse position rather than map center\n\n      var startZoomLngLat = this._interactiveState.startZoomLngLat || this._unproject(startPos) || this._unproject(pos);\n\n      var startZoom = this._interactiveState.startZoom;\n\n      if (!Number.isFinite(startZoom)) {\n        startZoom = this._viewportProps.zoom;\n      } // take the start lnglat and put it where the mouse is down.\n\n\n      assert(startZoomLngLat, '`startZoomLngLat` prop is required ' + 'for zoom behavior to calculate where to position the map.');\n\n      var zoom = this._calculateNewZoom({\n        scale: scale,\n        startZoom: startZoom\n      });\n\n      var zoomedViewport = new PerspectiveMercatorViewport(Object.assign({}, this._viewportProps, {\n        zoom: zoom\n      }));\n\n      var _zoomedViewport$getLo = zoomedViewport.getLocationAtPoint({\n        lngLat: startZoomLngLat,\n        pos: pos\n      }),\n          _zoomedViewport$getLo2 = _slicedToArray(_zoomedViewport$getLo, 2),\n          longitude = _zoomedViewport$getLo2[0],\n          latitude = _zoomedViewport$getLo2[1];\n\n      return this._getUpdatedState({\n        zoom: zoom,\n        longitude: longitude,\n        latitude: latitude\n      });\n    }\n    /**\n     * End zooming\n     * Must call if `zoomStart()` was called\n     */\n\n  }, {\n    key: 'zoomEnd',\n    value: function zoomEnd() {\n      return this._getUpdatedState({\n        startZoomLngLat: null,\n        startZoom: null\n      });\n    }\n  }, {\n    key: 'moveLeft',\n    value: function moveLeft() {\n      return this._getUpdatedState({\n        bearing: this._viewportProps.bearing - 3\n      });\n    }\n  }, {\n    key: 'moveRight',\n    value: function moveRight() {\n      return this._getUpdatedState({\n        bearing: this._viewportProps.bearing + 3\n      });\n    }\n  }, {\n    key: 'moveForward',\n    value: function moveForward() {\n      return this._getUpdatedState({\n        pitch: this._viewportProps.pitch + 3\n      });\n    }\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward() {\n      return this._getUpdatedState({\n        pitch: this._viewportProps.pitch - 3\n      });\n    }\n  }, {\n    key: 'zoomIn',\n    value: function zoomIn() {\n      return this._getUpdatedState({\n        zoom: this._viewportProps.zoom + 0.2\n      });\n    }\n  }, {\n    key: 'zoomOut',\n    value: function zoomOut() {\n      return this._getUpdatedState({\n        zoom: this._viewportProps.zoom - 0.2\n      });\n    }\n    /* Private methods */\n\n  }, {\n    key: '_getUpdatedState',\n    value: function _getUpdatedState(newProps) {\n      // Update _viewportProps\n      return new MapState(Object.assign({}, this._viewportProps, this._interactiveState, newProps));\n    } // Apply any constraints (mathematical or defined by _viewportProps) to map state\n\n  }, {\n    key: '_applyConstraints',\n    value: function _applyConstraints(props) {\n      // Normalize degrees\n      props.longitude = mod(props.longitude + 180, 360) - 180;\n      props.bearing = mod(props.bearing + 180, 360) - 180; // Ensure zoom is within specified range\n\n      var maxZoom = props.maxZoom,\n          minZoom = props.minZoom,\n          zoom = props.zoom;\n      props.zoom = zoom > maxZoom ? maxZoom : zoom;\n      props.zoom = props.zoom < minZoom ? minZoom : props.zoom; // Ensure pitch is within specified range\n\n      var maxPitch = props.maxPitch,\n          minPitch = props.minPitch,\n          pitch = props.pitch;\n      props.pitch = pitch > maxPitch ? maxPitch : pitch;\n      props.pitch = props.pitch < minPitch ? minPitch : props.pitch;\n      return props;\n    }\n  }, {\n    key: '_unproject',\n    value: function _unproject(pos) {\n      var viewport = new PerspectiveMercatorViewport(this._viewportProps);\n      return pos && viewport.unproject(pos, {\n        topLeft: true\n      });\n    } // Calculate a new lnglat based on pixel dragging position\n\n  }, {\n    key: '_calculateNewLngLat',\n    value: function _calculateNewLngLat(_ref8) {\n      var startPanLngLat = _ref8.startPanLngLat,\n          pos = _ref8.pos;\n      var viewport = new PerspectiveMercatorViewport(this._viewportProps);\n      return viewport.getLocationAtPoint({\n        lngLat: startPanLngLat,\n        pos: pos\n      });\n    } // Calculates new zoom\n\n  }, {\n    key: '_calculateNewZoom',\n    value: function _calculateNewZoom(_ref9) {\n      var scale = _ref9.scale,\n          startZoom = _ref9.startZoom;\n      var _viewportProps = this._viewportProps,\n          maxZoom = _viewportProps.maxZoom,\n          minZoom = _viewportProps.minZoom;\n      var zoom = startZoom + Math.log2(scale);\n      zoom = zoom > maxZoom ? maxZoom : zoom;\n      zoom = zoom < minZoom ? minZoom : zoom;\n      return zoom;\n    } // Calculates a new pitch and bearing from a position (coming from an event)\n\n  }, {\n    key: '_calculateNewPitchAndBearing',\n    value: function _calculateNewPitchAndBearing(_ref10) {\n      var deltaScaleX = _ref10.deltaScaleX,\n          deltaScaleY = _ref10.deltaScaleY,\n          startBearing = _ref10.startBearing,\n          startPitch = _ref10.startPitch;\n      var _viewportProps2 = this._viewportProps,\n          minPitch = _viewportProps2.minPitch,\n          maxPitch = _viewportProps2.maxPitch;\n      var bearing = startBearing + 180 * deltaScaleX;\n      var pitch = startPitch;\n\n      if (deltaScaleY > 0) {\n        // Gradually increase pitch\n        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);\n      } else if (deltaScaleY < 0) {\n        // Gradually decrease pitch\n        pitch = startPitch - deltaScaleY * (minPitch - startPitch);\n      }\n\n      return {\n        pitch: pitch,\n        bearing: bearing\n      };\n    }\n  }]);\n\n  return MapState;\n}(ViewState);\n\nexport default MapState;","map":null,"metadata":{},"sourceType":"module"}