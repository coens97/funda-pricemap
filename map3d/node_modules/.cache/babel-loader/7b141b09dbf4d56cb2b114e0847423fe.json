{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n/* eslint-disable */\n// TODO - generic draw call\n// One of the good things about GL is that there are so many ways to draw things\n\n\nimport GL, { glGet } from './api';\nimport { assertWebGLContext, assertWebGL2Context } from './context';\nimport { withParameters } from './context';\nimport assert from 'assert';\n/**\n * Read pixels from a target\n *\n * Will read from the currently bound framebuffer, or the currently bound\n *  drawing buffer - if context has been created with\n *  preserveDrawingBuffers\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} opts\n * @param {Number} opts.x - leftmost coord to be read\n * @param {Number} opts.y - bottommost (or topmost if sourceHeight supplied)\n * @param {Number} opts.width=1 - width of area to be read\n * @param {Number} opts.height=1 - height of area to be read\n * @param {Number} opts.sourceHeight= - target height, implies top left coords\n * @param {Number} opts.dataOffset=0 - WebGL2 only - offset into data array\n * @param {Number} opts.format=GL.RBGA - Can be set to GL.RGB or GL.ALPHA\n *\n * @return {ArrayView} - types array, either passed in or autoallocated\n */\n\nexport function readPixels(gl, _ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      _ref$width = _ref.width,\n      width = _ref$width === undefined ? 1 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === undefined ? 1 : _ref$height,\n      data = _ref.data,\n      _ref$dataOffset = _ref.dataOffset,\n      dataOffset = _ref$dataOffset === undefined ? 0 : _ref$dataOffset,\n      _ref$type = _ref.type,\n      type = _ref$type === undefined ? GL.UNSIGNED_BYTE : _ref$type,\n      sourceHeight = _ref.sourceHeight,\n      _ref$format = _ref.format,\n      format = _ref$format === undefined ? GL.RGBA : _ref$format; // Read color in the central pixel, to be mapped with picking colors\n\n  data = data || new Uint8Array(4 * width * height); // If source height is specified, a top left coordinate system is used\n\n  y = sourceHeight ? sourceHeight - y : y;\n\n  if (dataOffset) {\n    assertWebGL2Context(gl);\n    gl.readPixels(x, y, width, height, format, type, data, dataOffset);\n  } else {\n    gl.readPixels(x, y, width, height, format, type, data);\n  }\n\n  return data;\n}\n/**\n * Read pixels directly into webgl buffer\n * NOTE: WebGL2 only\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} options\n * @return {WebGLBuffer} the passed in buffer\n */\n\nexport function readPixelsToBuffer(gl, _ref2) {\n  var x = _ref2.x,\n      y = _ref2.y,\n      _ref2$width = _ref2.width,\n      width = _ref2$width === undefined ? 1 : _ref2$width,\n      _ref2$height = _ref2.height,\n      height = _ref2$height === undefined ? 1 : _ref2$height,\n      buffer = _ref2.buffer,\n      _ref2$dataOffset = _ref2.dataOffset,\n      dataOffset = _ref2$dataOffset === undefined ? 0 : _ref2$dataOffset,\n      _ref2$type = _ref2.type,\n      type = _ref2$type === undefined ? GL.UNSIGNED_BYTE : _ref2$type,\n      sourceHeight = _ref2.sourceHeight,\n      _ref2$format = _ref2.format,\n      format = _ref2$format === undefined ? GL.RGBA : _ref2$format;\n  assertWebGL2Context(gl); // If source height is specified, a top left coordinate system is used\n\n  y = sourceHeight ? sourceHeight - y : y;\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, buffer.handle);\n  gl.readPixels(x, y, width, height, format, type, dataOffset);\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, null);\n  return buffer;\n}\n/*\n* @param {} opt.filter\n */\n\nexport function blitFramebuffer(gl, _ref3) {\n  var _ref3$source = _slicedToArray(_ref3.source, 4),\n      sourceX = _ref3$source[0],\n      sourceY = _ref3$source[1],\n      sourceWidth = _ref3$source[2],\n      sourceHeight = _ref3$source[3],\n      _ref3$dest = _slicedToArray(_ref3.dest, 4),\n      destX = _ref3$dest[0],\n      destY = _ref3$dest[1],\n      destWidth = _ref3$dest[2],\n      destHeight = _ref3$dest[3],\n      _ref3$mask = _ref3.mask,\n      mask = _ref3$mask === undefined ? GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT : _ref3$mask,\n      _ref3$filter = _ref3.filter,\n      filter = _ref3$filter === undefined ? GL.LINEAR : _ref3$filter;\n}","map":null,"metadata":{},"sourceType":"module"}