{"ast":null,"code":"function _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/* eslint-disable */\n// TODO - generic draw call\n// One of the good things about GL is that there are so many ways to draw things\n\n\nimport GL from '../constants';\nimport { withParameters } from '../webgl-context';\nimport { assertWebGLContext, assertWebGL2Context, getKey } from '../webgl-utils';\nimport assert from '../utils/assert';\n/**\n * Read pixels from a target\n *\n * Will read from the currently bound framebuffer, or the currently bound\n *  drawing buffer - if context has been created with\n *  preserveDrawingBuffers\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} opts\n * @param {Number} opts.x - leftmost coord to be read\n * @param {Number} opts.y - bottommost (or topmost if sourceHeight supplied)\n * @param {Number} opts.width=1 - width of area to be read\n * @param {Number} opts.height=1 - height of area to be read\n * @param {Number} opts.sourceHeight= - target height, implies top left coords\n * @param {Number} opts.dataOffset=0 - WebGL2 only - offset into data array\n * @param {Number} opts.format=GL.RBGA - Can be set to GL.RGB or GL.ALPHA\n *\n * @return {ArrayView} - types array, either passed in or autoallocated\n */\n\nexport function readPixels(gl, _ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      _ref$width = _ref.width,\n      width = _ref$width === void 0 ? 1 : _ref$width,\n      _ref$height = _ref.height,\n      height = _ref$height === void 0 ? 1 : _ref$height,\n      data = _ref.data,\n      _ref$dataOffset = _ref.dataOffset,\n      dataOffset = _ref$dataOffset === void 0 ? 0 : _ref$dataOffset,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? GL.UNSIGNED_BYTE : _ref$type,\n      sourceHeight = _ref.sourceHeight,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? GL.RGBA : _ref$format; // Read color in the central pixel, to be mapped with picking colors\n\n  data = data || new Uint8Array(4 * width * height); // If source height is specified, a top left coordinate system is used\n\n  y = sourceHeight ? sourceHeight - y : y;\n\n  if (dataOffset) {\n    assertWebGL2Context(gl);\n    gl.readPixels(x, y, width, height, format, type, data, dataOffset);\n  } else {\n    gl.readPixels(x, y, width, height, format, type, data);\n  }\n\n  return data;\n}\n/**\n * Read pixels directly into webgl buffer\n * NOTE: WebGL2 only\n *\n * @param {WebGLRenderingContext} gl\n * @param {Object} options\n * @return {WebGLBuffer} the passed in buffer\n */\n\nexport function readPixelsToBuffer(gl, _ref2) {\n  var x = _ref2.x,\n      y = _ref2.y,\n      _ref2$width = _ref2.width,\n      width = _ref2$width === void 0 ? 1 : _ref2$width,\n      _ref2$height = _ref2.height,\n      height = _ref2$height === void 0 ? 1 : _ref2$height,\n      buffer = _ref2.buffer,\n      _ref2$dataOffset = _ref2.dataOffset,\n      dataOffset = _ref2$dataOffset === void 0 ? 0 : _ref2$dataOffset,\n      _ref2$type = _ref2.type,\n      type = _ref2$type === void 0 ? GL.UNSIGNED_BYTE : _ref2$type,\n      sourceHeight = _ref2.sourceHeight,\n      _ref2$format = _ref2.format,\n      format = _ref2$format === void 0 ? GL.RGBA : _ref2$format;\n  assertWebGL2Context(gl); // If source height is specified, a top left coordinate system is used\n\n  y = sourceHeight ? sourceHeight - y : y;\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, buffer.handle);\n  gl.readPixels(x, y, width, height, format, type, dataOffset);\n  gl.bindBuffer(GL.PIXEL_PACK_BUFFER, null);\n  return buffer;\n}\n/*\n* @param {} opt.filter\n */\n\nexport function blitFramebuffer(gl, _ref3) {\n  var _ref3$source = _slicedToArray(_ref3.source, 4),\n      sourceX = _ref3$source[0],\n      sourceY = _ref3$source[1],\n      sourceWidth = _ref3$source[2],\n      sourceHeight = _ref3$source[3],\n      _ref3$dest = _slicedToArray(_ref3.dest, 4),\n      destX = _ref3$dest[0],\n      destY = _ref3$dest[1],\n      destWidth = _ref3$dest[2],\n      destHeight = _ref3$dest[3],\n      _ref3$mask = _ref3.mask,\n      mask = _ref3$mask === void 0 ? GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT : _ref3$mask,\n      _ref3$filter = _ref3.filter,\n      filter = _ref3$filter === void 0 ? GL.LINEAR : _ref3$filter;\n}","map":null,"metadata":{},"sourceType":"module"}