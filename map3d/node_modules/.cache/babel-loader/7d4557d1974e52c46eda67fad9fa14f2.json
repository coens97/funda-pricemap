{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { formatValue, equals as _equals, config } from './lib/common';\nimport { degrees, radians, clamp } from './lib/common';\nimport Vector3 from './vector3';\nimport vec3_length from 'gl-vec3/length';\nvar EPSILON = 0.000001;\nvar EARTH_RADIUS_METERS = 6.371e6;\n\nvar SphericalCoordinates = function () {\n  function SphericalCoordinates() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        phi = _ref.phi,\n        theta = _ref.theta,\n        radius = _ref.radius,\n        bearing = _ref.bearing,\n        pitch = _ref.pitch,\n        altitude = _ref.altitude,\n        _ref$radiusScale = _ref.radiusScale,\n        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;\n\n    _classCallCheck(this, SphericalCoordinates);\n\n    if (arguments.length === 0) {\n      this.phi = 0;\n      this.theta = 0;\n      this.radius = 1;\n    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {\n      this.phi = phi || 0;\n      this.theta = theta || 0;\n    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {\n      this.bearing = bearing || 0;\n      this.pitch = pitch || 0;\n    }\n\n    this.radius = radius || 1;\n    this.radiusScale = radiusScale || 1;\n    this.check();\n  }\n\n  _createClass(SphericalCoordinates, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.formatString(config);\n    }\n  }, {\n    key: \"formatString\",\n    value: function formatString(_ref2) {\n      var printTypes = _ref2.printTypes,\n          printDegrees = _ref2.printDegrees;\n      var f = formatValue;\n      return \"\".concat(printTypes ? 'Spherical' : '', \"[rho:\").concat(f(this.radius), \",theta:\").concat(f(this.theta), \",phi:\").concat(f(this.phi), \"]\");\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return _equals(this.radius, other.radius) && _equals(this.theta, other.theta) && _equals(this.phi, other.phi);\n    }\n  }, {\n    key: \"exactEquals\",\n    value: function exactEquals(other) {\n      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;\n    }\n  }, {\n    key: \"set\",\n    value: function set(radius, phi, theta) {\n      this.radius = radius;\n      this.phi = phi;\n      this.theta = theta;\n      return this.check();\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor().copy(this);\n    }\n  }, {\n    key: \"copy\",\n    value: function copy(other) {\n      this.radius = other.radius;\n      this.phi = other.phi;\n      this.theta = other.theta;\n      return this.check();\n    }\n  }, {\n    key: \"fromLngLatZ\",\n    value: function fromLngLatZ(_ref3) {\n      var _ref4 = _slicedToArray(_ref3, 3),\n          lng = _ref4[0],\n          lat = _ref4[1],\n          z = _ref4[2];\n\n      this.radius = 1 + z / this.radiusScale;\n      this.phi = radians(lat);\n      this.theta = radians(lng);\n    }\n  }, {\n    key: \"fromVector3\",\n    value: function fromVector3(v) {\n      this.radius = vec3_length(v);\n\n      if (this.radius === 0) {\n        this.theta = 0;\n        this.phi = 0;\n      } else {\n        this.theta = Math.atan2(v[0], v[1]);\n        this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));\n      }\n\n      return this.check();\n    }\n  }, {\n    key: \"toVector3\",\n    value: function toVector3() {\n      return new Vector3(0, 0, this.radius).rotateX({\n        radians: this.theta\n      }).rotateZ({\n        radians: this.phi\n      });\n    }\n  }, {\n    key: \"makeSafe\",\n    value: function makeSafe() {\n      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));\n    }\n  }, {\n    key: \"check\",\n    value: function check() {\n      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {\n        throw new Error('SphericalCoordinates: some fields set to invalid numbers');\n      }\n\n      return this;\n    }\n  }, {\n    key: \"bearing\",\n    get: function get() {\n      return 180 - degrees(this.phi);\n    },\n    set: function set(v) {\n      this.phi = Math.PI - radians(v);\n    }\n  }, {\n    key: \"pitch\",\n    get: function get() {\n      return degrees(this.theta);\n    },\n    set: function set(v) {\n      this.theta = radians(v);\n    }\n  }, {\n    key: \"longitude\",\n    get: function get() {\n      return degrees(this.phi);\n    }\n  }, {\n    key: \"latitude\",\n    get: function get() {\n      return degrees(this.theta);\n    }\n  }, {\n    key: \"lng\",\n    get: function get() {\n      return degrees(this.phi);\n    }\n  }, {\n    key: \"lat\",\n    get: function get() {\n      return degrees(this.theta);\n    }\n  }, {\n    key: \"z\",\n    get: function get() {\n      return (this.radius - 1) * this.radiusScale;\n    }\n  }]);\n\n  return SphericalCoordinates;\n}();\n\nexport { SphericalCoordinates as default };","map":null,"metadata":{},"sourceType":"module"}