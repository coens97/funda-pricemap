{"ast":null,"code":"var _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 Uber Technologies, Inc.\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport MapState from './map-state';\nimport assert from 'assert'; // EVENT HANDLING PARAMETERS\n\nvar ZOOM_ACCEL = 0.01;\nvar PITCH_MOUSE_THRESHOLD = 5;\nvar PITCH_ACCEL = 1.2;\nvar EVENT_TYPES = {\n  WHEEL: ['wheel'],\n  PAN: ['panstart', 'panmove', 'panend'],\n  PINCH: ['pinchstart', 'pinchmove', 'pinchend'],\n  DOUBLE_TAP: ['doubletap'],\n  KEYBOARD: ['keydown', 'keyup']\n};\n\nvar ViewportControls = function () {\n  /**\n   * @classdesc\n   * A class that handles events and updates mercator style viewport parameters\n   */\n  function ViewportControls(ViewportState) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ViewportControls);\n\n    assert(ViewportState);\n    this.ViewportState = ViewportState;\n    this.viewportState = null;\n    this.viewportStateProps = null;\n    this.eventManager = null;\n    this._events = null;\n    this._state = {\n      isDragging: false\n    };\n    this.handleEvent = this.handleEvent.bind(this);\n    this.setOptions(options);\n\n    if (this.constructor === ViewportControls) {\n      Object.seal(this);\n    }\n  }\n  /**\n   * Callback for events\n   * @param {hammer.Event} event\n   */\n\n\n  _createClass(ViewportControls, [{\n    key: 'handleEvent',\n    value: function handleEvent(event) {\n      var ViewportState = this.ViewportState;\n      this.viewportState = new ViewportState(Object.assign({}, this.viewportStateProps, this._state));\n\n      switch (event.type) {\n        case 'panstart':\n          return this._onPanStart(event);\n\n        case 'panmove':\n          return this._onPan(event);\n\n        case 'panend':\n          return this._onPanEnd(event);\n\n        case 'pinchstart':\n          return this._onPinchStart(event);\n\n        case 'pinch':\n          return this._onPinch(event);\n\n        case 'pinchend':\n          return this._onPinchEnd(event);\n\n        case 'doubletap':\n          return this._onDoubleTap(event);\n\n        case 'wheel':\n          return this._onWheel(event);\n\n        case 'keydown':\n          return this._onKeyDown(event);\n\n        case 'keyup':\n          return this._onKeyUp(event);\n\n        default:\n          return false;\n      }\n    }\n    /* Event utils */\n    // Event object: http://hammerjs.github.io/api/#event-object\n\n  }, {\n    key: 'getCenter',\n    value: function getCenter(event) {\n      var _event$offsetCenter = event.offsetCenter,\n          x = _event$offsetCenter.x,\n          y = _event$offsetCenter.y;\n      return [x, y];\n    }\n  }, {\n    key: 'isFunctionKeyPressed',\n    value: function isFunctionKeyPressed(event) {\n      var srcEvent = event.srcEvent;\n      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);\n    }\n  }, {\n    key: 'isDragging',\n    value: function isDragging() {\n      return this._state.isDragging;\n    }\n    /**\n     * Extract interactivity options\n     */\n\n  }, {\n    key: 'setOptions',\n    value: function setOptions(options) {\n      var onViewportChange = options.onViewportChange,\n          _options$onStateChang = options.onStateChange,\n          onStateChange = _options$onStateChang === undefined ? this.onStateChange : _options$onStateChang,\n          _options$eventManager = options.eventManager,\n          eventManager = _options$eventManager === undefined ? this.eventManager : _options$eventManager,\n          _options$scrollZoom = options.scrollZoom,\n          scrollZoom = _options$scrollZoom === undefined ? true : _options$scrollZoom,\n          _options$dragPan = options.dragPan,\n          dragPan = _options$dragPan === undefined ? true : _options$dragPan,\n          _options$dragRotate = options.dragRotate,\n          dragRotate = _options$dragRotate === undefined ? true : _options$dragRotate,\n          _options$doubleClickZ = options.doubleClickZoom,\n          doubleClickZoom = _options$doubleClickZ === undefined ? true : _options$doubleClickZ,\n          _options$touchZoomRot = options.touchZoomRotate,\n          touchZoomRotate = _options$touchZoomRot === undefined ? true : _options$touchZoomRot,\n          _options$keyboard = options.keyboard,\n          keyboard = _options$keyboard === undefined ? true : _options$keyboard;\n      this.onViewportChange = onViewportChange;\n      this.onStateChange = onStateChange;\n      this.viewportStateProps = options;\n\n      if (this.eventManager !== eventManager) {\n        // EventManager has changed\n        this.eventManager = eventManager;\n        this._events = {};\n      } // Register/unregister events\n\n\n      var isInteractive = Boolean(this.onViewportChange);\n      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);\n      this.toggleEvents(EVENT_TYPES.PAN, isInteractive && (dragPan || dragRotate));\n      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && touchZoomRotate);\n      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);\n      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);\n      this.scrollZoom = scrollZoom;\n      this.dragPan = dragPan;\n      this.dragRotate = dragRotate;\n      this.doubleClickZoom = doubleClickZoom;\n      this.touchZoomRotate = touchZoomRotate;\n    }\n  }, {\n    key: 'toggleEvents',\n    value: function toggleEvents(eventNames, enabled) {\n      var _this = this;\n\n      if (this.eventManager) {\n        eventNames.forEach(function (eventName) {\n          if (_this._events[eventName] !== enabled) {\n            _this._events[eventName] = enabled;\n\n            if (enabled) {\n              _this.eventManager.on(eventName, _this.handleEvent);\n            } else {\n              _this.eventManager.off(eventName, _this.handleEvent);\n            }\n          }\n        });\n      }\n    } // Private Methods\n\n  }, {\n    key: 'setState',\n    value: function setState(newState) {\n      Object.assign(this._state, newState);\n\n      if (this.onStateChange) {\n        this.onStateChange(this._state);\n      }\n    }\n    /* Callback util */\n    // formats map state and invokes callback function\n\n  }, {\n    key: 'updateViewport',\n    value: function updateViewport(newViewportState) {\n      var extraState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var oldViewport = this.viewportState.getViewportProps();\n      var newViewport = newViewportState.getViewportProps();\n\n      if (this.onViewportChange && Object.keys(newViewport).some(function (key) {\n        return oldViewport[key] !== newViewport[key];\n      })) {\n        // Viewport has changed\n        var viewport = this.viewportState.getViewport ? this.viewportState.getViewport() : null;\n        this.onViewportChange(newViewport, viewport);\n      }\n\n      this.setState(Object.assign({}, newViewportState.getInteractiveState(), extraState));\n    }\n    /* Event handlers */\n    // Default handler for the `panstart` event.\n\n  }, {\n    key: '_onPanStart',\n    value: function _onPanStart(event) {\n      var pos = this.getCenter(event);\n      var newViewportState = this.viewportState.panStart({\n        pos: pos\n      }).rotateStart({\n        pos: pos\n      });\n      return this.updateViewport(newViewportState, {\n        isDragging: true\n      });\n    } // Default handler for the `panmove` event.\n\n  }, {\n    key: '_onPan',\n    value: function _onPan(event) {\n      return this.isFunctionKeyPressed(event) ? this._onPanMove(event) : this._onPanRotate(event);\n    } // Default handler for the `panend` event.\n\n  }, {\n    key: '_onPanEnd',\n    value: function _onPanEnd(event) {\n      var newViewportState = this.viewportState.panEnd().rotateEnd();\n      return this.updateViewport(newViewportState, {\n        isDragging: false\n      });\n    } // Default handler for panning to move.\n    // Called by `_onPan` when panning without function key pressed.\n\n  }, {\n    key: '_onPanMove',\n    value: function _onPanMove(event) {\n      if (!this.dragPan) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var newViewportState = this.viewportState.pan({\n        pos: pos\n      });\n      return this.updateViewport(newViewportState);\n    } // Default handler for panning to rotate.\n    // Called by `_onPan` when panning with function key pressed.\n\n  }, {\n    key: '_onPanRotate',\n    value: function _onPanRotate(event) {\n      return this.viewportState instanceof MapState ? this._onPanRotateMap(event) : this._onPanRotateStandard(event);\n    } // Normal pan to rotate\n\n  }, {\n    key: '_onPanRotateStandard',\n    value: function _onPanRotateStandard(event) {\n      if (!this.dragRotate) {\n        return false;\n      }\n\n      var deltaX = event.deltaX,\n          deltaY = event.deltaY;\n\n      var _viewportState$getVie = this.viewportState.getViewportProps(),\n          width = _viewportState$getVie.width,\n          height = _viewportState$getVie.height;\n\n      var deltaScaleX = deltaX / width;\n      var deltaScaleY = deltaY / height;\n      var newViewportState = this.viewportState.rotate({\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY\n      });\n      return this.updateViewport(newViewportState);\n    } // Map specific pan to rotate\n    // TODO - is this mapStateSpecific?\n\n  }, {\n    key: '_onPanRotateMap',\n    value: function _onPanRotateMap(event) {\n      if (!this.dragRotate) {\n        return false;\n      }\n\n      var deltaX = event.deltaX,\n          deltaY = event.deltaY;\n\n      var _getCenter = this.getCenter(event),\n          _getCenter2 = _slicedToArray(_getCenter, 2),\n          centerY = _getCenter2[1];\n\n      var startY = centerY - deltaY;\n\n      var _viewportState$getVie2 = this.viewportState.getViewportProps(),\n          width = _viewportState$getVie2.width,\n          height = _viewportState$getVie2.height;\n\n      var deltaScaleX = deltaX / width;\n      var deltaScaleY = 0;\n\n      if (deltaY > 0) {\n        if (Math.abs(height - startY) > PITCH_MOUSE_THRESHOLD) {\n          // Move from 0 to -1 as we drag upwards\n          deltaScaleY = deltaY / (startY - height) * PITCH_ACCEL;\n        }\n      } else if (deltaY < 0) {\n        if (startY > PITCH_MOUSE_THRESHOLD) {\n          // Move from 0 to 1 as we drag upwards\n          deltaScaleY = 1 - centerY / startY;\n        }\n      }\n\n      deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));\n      var newMapState = this.viewportState.rotate({\n        deltaScaleX: deltaScaleX,\n        deltaScaleY: deltaScaleY\n      });\n      return this.updateViewport(newMapState);\n    } // Default handler for the `wheel` event.\n\n  }, {\n    key: '_onWheel',\n    value: function _onWheel(event) {\n      if (!this.scrollZoom) {\n        return false;\n      }\n\n      event.srcEvent.preventDefault();\n      var pos = this.getCenter(event);\n      var delta = event.delta; // Map wheel delta to relative scale\n\n      var scale = 2 / (1 + Math.exp(-Math.abs(delta * ZOOM_ACCEL)));\n\n      if (delta < 0 && scale !== 0) {\n        scale = 1 / scale;\n      }\n\n      var newViewportState = this.viewportState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      return this.updateViewport(newViewportState);\n    } // Default handler for the `pinchstart` event.\n\n  }, {\n    key: '_onPinchStart',\n    value: function _onPinchStart(event) {\n      var pos = this.getCenter(event);\n      var newViewportState = this.viewportState.zoomStart({\n        pos: pos\n      });\n      return this.updateViewport(newViewportState, {\n        isDragging: true\n      });\n    } // Default handler for the `pinch` event.\n\n  }, {\n    key: '_onPinch',\n    value: function _onPinch(event) {\n      if (!this.touchZoomRotate) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var scale = event.scale;\n      var newViewportState = this.viewportState.zoom({\n        pos: pos,\n        scale: scale\n      });\n      return this.updateViewport(newViewportState);\n    } // Default handler for the `pinchend` event.\n\n  }, {\n    key: '_onPinchEnd',\n    value: function _onPinchEnd(event) {\n      var newViewportState = this.viewportState.zoomEnd();\n      return this.updateViewport(newViewportState, {\n        isDragging: false\n      });\n    } // Default handler for the `doubletap` event.\n\n  }, {\n    key: '_onDoubleTap',\n    value: function _onDoubleTap(event) {\n      if (!this.doubleClickZoom) {\n        return false;\n      }\n\n      var pos = this.getCenter(event);\n      var isZoomOut = this.isFunctionKeyPressed(event);\n      var newViewportState = this.viewportState.zoom({\n        pos: pos,\n        scale: isZoomOut ? 0.5 : 2\n      });\n      return this.updateViewport(newViewportState);\n    }\n  }, {\n    key: '_onKeyDown',\n    value: function _onKeyDown(event) {\n      if (this.viewportState.isDragging) {\n        return;\n      }\n\n      var KEY_BINDINGS = {\n        w: 'moveForward',\n        W: 'moveForward',\n        ArrowUp: 'moveForward',\n        s: 'moveBackward',\n        S: 'moveBackward',\n        ArrowDown: 'moveBackward',\n        a: 'moveLeft',\n        A: 'moveLeft',\n        ArrowLeft: 'moveLeft',\n        d: 'moveRight',\n        D: 'moveRight',\n        ArrowRight: 'moveRight',\n        '=': 'zoomIn',\n        '+': 'zoomIn',\n        '-': 'zoomOut',\n        '[': 'moveDown',\n        ']': 'moveUp'\n      }; // keyCode is deprecated from web standards\n      // code is not supported by IE/Edge\n\n      var key = event.key;\n      var handler = KEY_BINDINGS[key];\n\n      if (this.viewportState[handler]) {\n        var newViewportState = this.viewportState[handler]();\n        this.updateViewport(newViewportState);\n      }\n    }\n    /* eslint-enable complexity */\n\n  }, {\n    key: '_onKeyUp',\n    value: function _onKeyUp(event) {}\n  }]);\n\n  return ViewportControls;\n}();\n\nexport default ViewportControls;","map":null,"metadata":{},"sourceType":"module"}