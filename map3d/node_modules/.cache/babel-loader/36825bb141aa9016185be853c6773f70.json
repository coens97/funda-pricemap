{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport Layer from './layer';\nimport log from '../utils/log';\nimport { flatten } from '../utils/flatten';\n\nvar CompositeLayer = function (_Layer) {\n  _inherits(CompositeLayer, _Layer);\n\n  function CompositeLayer(props) {\n    _classCallCheck(this, CompositeLayer);\n\n    return _possibleConstructorReturn(this, (CompositeLayer.__proto__ || Object.getPrototypeOf(CompositeLayer)).call(this, props));\n  }\n\n  _createClass(CompositeLayer, [{\n    key: 'getSubLayers',\n    value: function getSubLayers() {\n      return this.internalState.subLayers || [];\n    } // initializeState is usually not needed for composite layers\n    // Provide empty definition to disable check for missing definition\n\n  }, {\n    key: 'initializeState',\n    value: function initializeState() {} // called to augment the info object that is bubbled up from a sublayer\n    // override Layer.getPickingInfo() because decoding / setting uniform do\n    // not apply to a composite layer.\n    // @return null to cancel event\n\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(_ref) {\n      var info = _ref.info;\n      return info;\n    } // Implement to generate subLayers\n\n  }, {\n    key: 'renderLayers',\n    value: function renderLayers() {\n      return null;\n    } // Returns sub layer props for a specific sublayer\n\n  }, {\n    key: 'getSubLayerProps',\n    value: function getSubLayerProps(sublayerProps) {\n      var _props = this.props,\n          opacity = _props.opacity,\n          pickable = _props.pickable,\n          visible = _props.visible,\n          parameters = _props.parameters,\n          getPolygonOffset = _props.getPolygonOffset,\n          highlightedObjectIndex = _props.highlightedObjectIndex,\n          autoHighlight = _props.autoHighlight,\n          highlightColor = _props.highlightColor,\n          coordinateSystem = _props.coordinateSystem,\n          coordinateOrigin = _props.coordinateOrigin,\n          modelMatrix = _props.modelMatrix;\n      var newProps = {\n        opacity: opacity,\n        pickable: pickable,\n        visible: visible,\n        parameters: parameters,\n        getPolygonOffset: getPolygonOffset,\n        highlightedObjectIndex: highlightedObjectIndex,\n        autoHighlight: autoHighlight,\n        highlightColor: highlightColor,\n        coordinateSystem: coordinateSystem,\n        coordinateOrigin: coordinateOrigin,\n        modelMatrix: modelMatrix\n      };\n\n      if (sublayerProps) {\n        Object.assign(newProps, sublayerProps, {\n          id: this.props.id + '-' + sublayerProps.id,\n          updateTriggers: Object.assign({\n            all: this.props.updateTriggers.all\n          }, sublayerProps.updateTriggers)\n        });\n      }\n\n      return newProps;\n    } // Called by layer manager to render subLayers\n\n  }, {\n    key: '_renderLayers',\n    value: function _renderLayers() {\n      var subLayers = this.internalState.subLayers;\n\n      if (subLayers && !this.needsUpdate()) {\n        log.log(3, 'Composite layer reused subLayers ' + this, this.internalState.subLayers);\n      } else {\n        subLayers = this.renderLayers(); // Flatten the returned array, removing any null, undefined or false\n        // this allows layers to render sublayers conditionally\n        // (see CompositeLayer.renderLayers docs)\n\n        subLayers = flatten(subLayers, {\n          filter: Boolean\n        });\n        this.internalState.subLayers = subLayers;\n        log.log(2, 'Composite layer rendered new subLayers ' + this, subLayers);\n      } // populate reference to parent layer (this layer)\n      // NOTE: needs to be done even when reusing layers as the parent may have changed\n\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = subLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n          layer.parentLayer = this;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'isComposite',\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return CompositeLayer;\n}(Layer);\n\nexport default CompositeLayer;","map":null,"metadata":{},"sourceType":"module"}