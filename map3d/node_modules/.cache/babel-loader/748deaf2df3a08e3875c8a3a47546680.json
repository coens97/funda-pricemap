{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nimport GL from 'luma.gl/constants';\nimport { Buffer, Model, Framebuffer, Texture2D, FEATURES, hasFeatures, isWebGL2 } from 'luma.gl';\nimport { log } from '@deck.gl/core';\nimport assert from 'assert';\nimport { fp64 as fp64Utils } from 'luma.gl';\nimport { worldToPixels } from 'viewport-mercator-project';\nvar fp64ifyMatrix4 = fp64Utils.fp64ifyMatrix4;\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar PIXEL_SIZE = 4; // RGBA32F\n\nimport AGGREGATE_TO_GRID_VS from './aggregate-to-grid-vs.glsl';\nimport AGGREGATE_TO_GRID_VS_FP64 from './aggregate-to-grid-vs-64.glsl';\nimport AGGREGATE_TO_GRID_FS from './aggregate-to-grid-fs.glsl';\nimport AGGREGATE_ALL_VS_FP64 from './aggregate-all-vs-64.glsl';\nimport AGGREGATE_ALL_FS from './aggregate-all-fs.glsl';\nvar DEFAULT_CHANGE_FLAGS = {\n  dataChanged: true,\n  viewportChanged: true,\n  cellSizeChanged: true\n};\n\nvar GPUGridAggregator =\n/*#__PURE__*/\nfunction () {\n  _createClass(GPUGridAggregator, null, [{\n    key: \"getAggregationData\",\n    // Decode and return aggregation data of given pixel.\n    value: function getAggregationData(_ref) {\n      var countsData = _ref.countsData,\n          maxCountData = _ref.maxCountData,\n          pixelIndex = _ref.pixelIndex;\n      assert(countsData.length >= (pixelIndex + 1) * PIXEL_SIZE);\n      assert(maxCountData.length === PIXEL_SIZE);\n      var index = pixelIndex * PIXEL_SIZE;\n      var cellCount = countsData[index];\n      var cellWeight = countsData[index + 1];\n      var totalCount = maxCountData[0];\n      var totalWeight = maxCountData[1];\n      var maxCellWieght = maxCountData[3];\n      return {\n        cellCount: cellCount,\n        cellWeight: cellWeight,\n        totalCount: totalCount,\n        totalWeight: totalWeight,\n        maxCellWieght: maxCellWieght\n      };\n    } // Decodes and retuns counts and weights of all cells\n\n  }, {\n    key: \"getCellData\",\n    value: function getCellData(_ref2) {\n      var countsData = _ref2.countsData;\n      var cellWeights = [];\n      var cellCounts = [];\n\n      for (var index = 0; index < countsData.length; index += 4) {\n        cellCounts.push(countsData[index]);\n        cellWeights.push(countsData[index + 1]);\n      }\n\n      return {\n        cellCounts: cellCounts,\n        cellWeights: cellWeights\n      };\n    } // DEBUG ONLY\n    // static logData({countsBuffer, maxCountBuffer}) {\n    //   const countsData = countsBuffer.getData();\n    //   for (let index = 0; index < countsData.length; index += 4) {\n    //     if (countsData[index] > 0) {\n    //       console.log(`index: ${index} count: ${countsData[index]}`);\n    //     }\n    //   }\n    //   const maxCountData = maxCountBuffer.getData();\n    //   console.log(`totalCount: ${maxCountData[0]} totalWeight: ${maxCountData[1]} maxCellWieght: ${maxCountData[3]}`);\n    // }\n\n  }]);\n\n  function GPUGridAggregator(gl) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, GPUGridAggregator);\n\n    this.id = opts.id || 'gpu-grid-aggregator';\n    this.shaderCache = opts.shaderCache || null;\n    this.gl = gl;\n    this.state = {};\n    this._hasGPUSupport = isWebGL2(gl) && hasFeatures(this.gl, FEATURES.BLEND_EQUATION_MINMAX, FEATURES.COLOR_ATTACHMENT_RGBA32F, FEATURES.TEXTURE_FILTER_LINEAR_FLOAT);\n\n    if (this._hasGPUSupport) {\n      this._setupGPUResources();\n    }\n  } // Perform aggregation and retun the results\n\n\n  _createClass(GPUGridAggregator, [{\n    key: \"run\",\n    value: function run() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          positions = _ref3.positions,\n          positions64xyLow = _ref3.positions64xyLow,\n          weights = _ref3.weights,\n          _ref3$changeFlags = _ref3.changeFlags,\n          changeFlags = _ref3$changeFlags === void 0 ? DEFAULT_CHANGE_FLAGS : _ref3$changeFlags,\n          cellSize = _ref3.cellSize,\n          viewport = _ref3.viewport,\n          width = _ref3.width,\n          height = _ref3.height,\n          _ref3$countsBuffer = _ref3.countsBuffer,\n          countsBuffer = _ref3$countsBuffer === void 0 ? null : _ref3$countsBuffer,\n          _ref3$maxCountBuffer = _ref3.maxCountBuffer,\n          maxCountBuffer = _ref3$maxCountBuffer === void 0 ? null : _ref3$maxCountBuffer,\n          _ref3$gridTransformMa = _ref3.gridTransformMatrix,\n          gridTransformMatrix = _ref3$gridTransformMa === void 0 ? null : _ref3$gridTransformMa,\n          _ref3$projectPoints = _ref3.projectPoints,\n          projectPoints = _ref3$projectPoints === void 0 ? false : _ref3$projectPoints,\n          _ref3$useGPU = _ref3.useGPU,\n          useGPU = _ref3$useGPU === void 0 ? true : _ref3$useGPU,\n          _ref3$fp = _ref3.fp64,\n          fp64 = _ref3$fp === void 0 ? false : _ref3$fp;\n\n      if (this.state.useGPU !== useGPU) {\n        changeFlags = DEFAULT_CHANGE_FLAGS;\n      }\n\n      this._setState({\n        useGPU: useGPU\n      }); // when projectPoints is true, shader projects to NDC, use `viewportMatrix` to\n      // transform points to viewport (screen) space for aggregation.\n\n\n      var transformMatrix = (projectPoints ? viewport.viewportMatrix : gridTransformMatrix) || IDENTITY_MATRIX;\n      var aggregationParams = {\n        positions: positions,\n        positions64xyLow: positions64xyLow,\n        weights: weights,\n        changeFlags: changeFlags,\n        cellSize: cellSize,\n        viewport: viewport,\n        gridTransformMatrix: transformMatrix,\n        countsBuffer: countsBuffer,\n        maxCountBuffer: maxCountBuffer,\n        projectPoints: projectPoints,\n        fp64: fp64\n      };\n\n      this._updateGridSize({\n        viewport: viewport,\n        cellSize: cellSize,\n        width: width,\n        height: height\n      });\n\n      if (this._hasGPUSupport && useGPU) {\n        return this._runAggregationOnGPU(aggregationParams);\n      }\n\n      if (useGPU) {\n        log.warn('ScreenGridAggregator: GPU Aggregation not supported, falling back to CPU');\n      }\n\n      return this._runAggregationOnCPU(aggregationParams);\n    } // PRIVATE\n\n  }, {\n    key: \"_getAggregateData\",\n    value: function _getAggregateData(opts) {\n      var countsBuffer = opts.countsBuffer,\n          maxCountBuffer = opts.maxCountBuffer;\n      countsBuffer = this.gridAggregationFramebuffer.readPixelsToBuffer({\n        buffer: countsBuffer,\n        type: GL.FLOAT\n      });\n      maxCountBuffer = this.allAggregrationFramebuffer.readPixelsToBuffer({\n        width: 1,\n        height: 1,\n        type: GL.FLOAT,\n        buffer: maxCountBuffer\n      });\n      return {\n        countsBuffer: countsBuffer,\n        countsTexture: this.gridAggregationFramebuffer.texture,\n        maxCountBuffer: maxCountBuffer,\n        maxCountTexture: this.allAggregrationFramebuffer.texture\n      };\n    }\n  }, {\n    key: \"_getAggregationModel\",\n    value: function _getAggregationModel() {\n      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var gl = this.gl,\n          shaderCache = this.shaderCache;\n      return new Model(gl, {\n        id: 'Gird-Aggregation-Model',\n        vs: fp64 ? AGGREGATE_TO_GRID_VS_FP64 : AGGREGATE_TO_GRID_VS,\n        fs: AGGREGATE_TO_GRID_FS,\n        modules: fp64 ? ['fp64', 'project64'] : ['project32'],\n        shaderCache: shaderCache,\n        vertexCount: 0,\n        drawMode: GL.POINTS\n      });\n    }\n  }, {\n    key: \"_getAllAggregationModel\",\n    value: function _getAllAggregationModel() {\n      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var gl = this.gl,\n          shaderCache = this.shaderCache;\n      return new Model(gl, {\n        id: 'All-Aggregation-Model',\n        vs: AGGREGATE_ALL_VS_FP64,\n        fs: AGGREGATE_ALL_FS,\n        modules: ['fp64'],\n        shaderCache: shaderCache,\n        vertexCount: 1,\n        drawMode: GL.POINTS,\n        isInstanced: true,\n        instanceCount: 0,\n        attributes: {\n          position: new Buffer(gl, {\n            size: 2,\n            data: new Float32Array([0, 0])\n          })\n        }\n      });\n    }\n  }, {\n    key: \"_projectPositions\",\n    value: function _projectPositions(opts) {\n      var projectedPositions = this.state.projectedPositions;\n\n      if (!projectedPositions || opts.changeFlags.dataChanged || opts.changeFlags.viewportChanged) {\n        var positions = opts.positions,\n            viewport = opts.viewport;\n        projectedPositions = [];\n\n        for (var index = 0; index < positions.length; index += 2) {\n          var _viewport$projectFlat = viewport.projectFlat([positions[index], positions[index + 1]]),\n              _viewport$projectFlat2 = _slicedToArray(_viewport$projectFlat, 2),\n              x = _viewport$projectFlat2[0],\n              y = _viewport$projectFlat2[1];\n\n          projectedPositions.push(x, y);\n        }\n\n        this._setState({\n          projectedPositions: projectedPositions\n        });\n      }\n    }\n  }, {\n    key: \"_renderAggregateData\",\n    value: function _renderAggregateData(opts) {\n      var cellSize = opts.cellSize,\n          viewport = opts.viewport,\n          gridTransformMatrix = opts.gridTransformMatrix,\n          projectPoints = opts.projectPoints;\n      var _this$state = this.state,\n          numCol = _this$state.numCol,\n          numRow = _this$state.numRow,\n          windowSize = _this$state.windowSize;\n      var gl = this.gl,\n          gridAggregationFramebuffer = this.gridAggregationFramebuffer,\n          gridAggregationModel = this.gridAggregationModel,\n          allAggregrationFramebuffer = this.allAggregrationFramebuffer,\n          allAggregationModel = this.allAggregationModel;\n      var uProjectionMatrixFP64 = fp64ifyMatrix4(gridTransformMatrix);\n      var gridSize = [numCol, numRow];\n      gridAggregationFramebuffer.bind();\n      gl.viewport(0, 0, gridSize[0], gridSize[1]);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      gridAggregationModel.draw({\n        parameters: {\n          clearColor: [0, 0, 0, 0],\n          clearDepth: 0,\n          blend: true,\n          depthTest: false,\n          blendEquation: GL.FUNC_ADD,\n          blendFunc: [GL.ONE, GL.ONE]\n        },\n        moduleSettings: {\n          viewport: viewport\n        },\n        uniforms: {\n          windowSize: windowSize,\n          cellSize: cellSize,\n          gridSize: gridSize,\n          uProjectionMatrix: gridTransformMatrix,\n          uProjectionMatrixFP64: uProjectionMatrixFP64,\n          projectPoints: projectPoints\n        }\n      });\n      gridAggregationFramebuffer.unbind();\n      allAggregrationFramebuffer.bind();\n      gl.viewport(0, 0, gridSize[0], gridSize[1]);\n      gl.clear(gl.COLOR_BUFFER_BIT);\n      allAggregationModel.draw({\n        parameters: {\n          clearColor: [0, 0, 0, 0],\n          clearDepth: 0,\n          blend: true,\n          depthTest: false,\n          blendEquation: [GL.FUNC_ADD, GL.MAX],\n          blendFunc: [GL.ONE, GL.ONE]\n        },\n        uniforms: {\n          uSampler: gridAggregationFramebuffer.texture,\n          gridSize: gridSize\n        }\n      });\n      allAggregrationFramebuffer.unbind();\n    }\n    /* eslint-disable max-statements */\n\n  }, {\n    key: \"_runAggregationOnCPU\",\n    value: function _runAggregationOnCPU(opts) {\n      var ELEMENTCOUNT = 4;\n      var positions = opts.positions,\n          weights = opts.weights,\n          cellSize = opts.cellSize,\n          projectPoints = opts.projectPoints,\n          gridTransformMatrix = opts.gridTransformMatrix,\n          viewport = opts.viewport;\n      var countsBuffer = opts.countsBuffer,\n          maxCountBuffer = opts.maxCountBuffer;\n      var _this$state2 = this.state,\n          numCol = _this$state2.numCol,\n          numRow = _this$state2.numRow; // Each element contains 4 floats to match with GPU ouput\n\n      var counts = new Float32Array(numCol * numRow * ELEMENTCOUNT);\n      var transformMatrix = gridTransformMatrix;\n      var pos = positions;\n\n      if (projectPoints) {\n        this._projectPositions(opts);\n\n        pos = this.state.projectedPositions; // project from world space to viewport (screen) space.\n\n        transformMatrix = viewport.pixelProjectionMatrix;\n      }\n\n      counts.fill(0);\n      var maxWeight = 0;\n      var totalCount = 0;\n      var totalWeight = 0;\n\n      for (var index = 0; index < pos.length; index += 2) {\n        var gridPos = worldToPixels([pos[index], pos[index + 1], 0], transformMatrix);\n        var x = gridPos[0];\n        var y = gridPos[1];\n        var weight = weights ? weights[index / 2] : 1;\n        assert(Number.isFinite(weight));\n        var colId = Math.floor(x / cellSize[0]);\n        var rowId = Math.floor(y / cellSize[1]);\n\n        if (colId >= 0 && colId < numCol && rowId >= 0 && rowId < numRow) {\n          var i = (colId + rowId * numCol) * ELEMENTCOUNT;\n          counts[i]++;\n          counts[i + 1] += weight;\n          totalCount += 1;\n          totalWeight += weight;\n\n          if (counts[i + 1] > maxWeight) {\n            maxWeight = counts[i + 1];\n          }\n        }\n      }\n\n      var maxCountBufferData = new Float32Array(ELEMENTCOUNT); // Store total count value in Red/X channel\n\n      maxCountBufferData[0] = totalCount; // Store total weight value in Green/Y channel\n\n      maxCountBufferData[1] = totalWeight; // Store max weight value in alpha/W channel.\n\n      maxCountBufferData[3] = maxWeight; // Load data to WebGL buffer.\n\n      if (countsBuffer) {\n        countsBuffer.subData({\n          data: counts\n        });\n      } else {\n        countsBuffer = new Buffer(this.gl, {\n          data: counts\n        });\n      }\n\n      if (maxCountBuffer) {\n        maxCountBuffer.subData({\n          data: maxCountBufferData\n        });\n      } else {\n        maxCountBuffer = new Buffer(this.gl, {\n          data: maxCountBufferData\n        });\n      }\n\n      return {\n        // Buffer objects\n        countsBuffer: countsBuffer,\n        maxCountBuffer: maxCountBuffer,\n        // ArrayView objects\n        countsData: counts,\n        maxCountData: maxCountBufferData,\n        // Return total aggregaton values to avoid UBO setup for WebGL1 cases\n        totalCount: totalCount,\n        totalWeight: totalWeight,\n        maxWeight: maxWeight\n      };\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: \"_runAggregationOnGPU\",\n    value: function _runAggregationOnGPU(opts) {\n      this._updateModels(opts);\n\n      this._renderAggregateData(opts);\n\n      return this._getAggregateData(opts);\n    } // Update priveate state\n\n  }, {\n    key: \"_setState\",\n    value: function _setState(updateObject) {\n      Object.assign(this.state, updateObject);\n    }\n  }, {\n    key: \"_setupGPUResources\",\n    value: function _setupGPUResources() {\n      var gl = this.gl;\n      this.gridAggregationFramebuffer = setupFramebuffer(gl, {\n        id: 'GridAggregation'\n      });\n      this.allAggregrationFramebuffer = setupFramebuffer(gl, {\n        id: 'AllAggregation'\n      });\n    }\n  }, {\n    key: \"_setupModels\",\n    value: function _setupModels() {\n      var fp64 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.gridAggregationModel) {\n        this.gridAggregationModel.delete();\n      }\n\n      this.gridAggregationModel = this._getAggregationModel(fp64);\n\n      if (this.allAggregationModel) {\n        this.allAggregationModel.delete();\n      }\n\n      this.allAggregationModel = this._getAllAggregationModel(fp64);\n    }\n    /* eslint-disable max-statements */\n\n  }, {\n    key: \"_updateModels\",\n    value: function _updateModels(opts) {\n      var gl = this.gl;\n      var positions = opts.positions,\n          positions64xyLow = opts.positions64xyLow,\n          weights = opts.weights,\n          changeFlags = opts.changeFlags;\n      var _this$state3 = this.state,\n          numCol = _this$state3.numCol,\n          numRow = _this$state3.numRow;\n      var _this$state4 = this.state,\n          positionsBuffer = _this$state4.positionsBuffer,\n          positions64xyLowBuffer = _this$state4.positions64xyLowBuffer,\n          weightsBuffer = _this$state4.weightsBuffer;\n      var aggregationModelAttributes = {};\n      var createPos64xyLow = false;\n\n      if (opts.fp64 !== this.state.fp64) {\n        this._setupModels(opts.fp64);\n\n        this._setState({\n          fp64: opts.fp64\n        });\n\n        if (opts.fp64) {\n          createPos64xyLow = true;\n        }\n      }\n\n      if (changeFlags.dataChanged || !positionsBuffer) {\n        if (positionsBuffer) {\n          positionsBuffer.delete();\n        }\n\n        if (weightsBuffer) {\n          weightsBuffer.delete();\n        }\n\n        positionsBuffer = new Buffer(gl, {\n          size: 2,\n          data: new Float32Array(positions)\n        });\n        weightsBuffer = new Buffer(gl, {\n          size: 1,\n          data: new Float32Array(weights)\n        });\n        createPos64xyLow = opts.fp64;\n        Object.assign(aggregationModelAttributes, {\n          positions: positionsBuffer,\n          weights: weightsBuffer\n        });\n        this.gridAggregationModel.setVertexCount(positions.length / 2);\n\n        this._setState({\n          positionsBuffer: positionsBuffer,\n          weightsBuffer: weightsBuffer\n        });\n      }\n\n      if (createPos64xyLow) {\n        assert(positions64xyLow);\n\n        if (positions64xyLowBuffer) {\n          positions64xyLowBuffer.delete();\n        }\n\n        positions64xyLowBuffer = new Buffer(gl, {\n          size: 2,\n          data: new Float32Array(positions64xyLow)\n        });\n        Object.assign(aggregationModelAttributes, {\n          positions64xyLow: positions64xyLowBuffer\n        });\n\n        this._setState({\n          positions64xyLowBuffer: positions64xyLowBuffer\n        });\n      }\n\n      this.gridAggregationModel.setAttributes(aggregationModelAttributes);\n\n      if (changeFlags.cellSizeChanged || changeFlags.viewportChanged) {\n        this.allAggregationModel.setInstanceCount(numCol * numRow);\n        var framebufferSize = {\n          width: numCol,\n          height: numRow\n        };\n        this.gridAggregationFramebuffer.resize(framebufferSize);\n        this.allAggregrationFramebuffer.resize(framebufferSize);\n      }\n    }\n    /* eslint-enable max-statements */\n\n  }, {\n    key: \"_updateGridSize\",\n    value: function _updateGridSize(opts) {\n      var viewport = opts.viewport,\n          cellSize = opts.cellSize;\n      var width = opts.width || viewport.width;\n      var height = opts.height || viewport.height;\n      var numCol = Math.ceil(width / cellSize[0]);\n      var numRow = Math.ceil(height / cellSize[1]);\n\n      this._setState({\n        numCol: numCol,\n        numRow: numRow,\n        windowSize: [width, height]\n      });\n    }\n  }]);\n\n  return GPUGridAggregator;\n}(); // Helper methods.\n\n\nexport { GPUGridAggregator as default };\n\nfunction setupFramebuffer(gl, opts) {\n  var _parameters;\n\n  var id = opts.id;\n  var texture = new Texture2D(gl, {\n    data: null,\n    format: GL.RGBA32F,\n    type: GL.FLOAT,\n    border: 0,\n    mipmaps: false,\n    parameters: (_parameters = {}, _defineProperty(_parameters, GL.TEXTURE_MAG_FILTER, GL.NEAREST), _defineProperty(_parameters, GL.TEXTURE_MIN_FILTER, GL.NEAREST), _parameters),\n    dataFormat: GL.RGBA\n  });\n  var fb = new Framebuffer(gl, {\n    id: id,\n    attachments: _defineProperty({}, GL.COLOR_ATTACHMENT0, texture)\n  });\n  return fb;\n}","map":null,"metadata":{},"sourceType":"module"}