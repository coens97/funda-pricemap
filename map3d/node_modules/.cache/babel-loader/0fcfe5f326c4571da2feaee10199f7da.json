{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport assert from 'assert';\nimport { Framebuffer, ShaderCache } from 'luma.gl';\nimport seer from 'seer';\nimport Layer from './layer';\nimport { drawLayers as _drawLayers } from './draw-layers';\nimport { pickObject as _pickObject, pickVisibleObjects } from './pick-layers';\nimport { LIFECYCLE } from './constants';\nimport Viewport from '../viewports/viewport'; // TODO - remove, just for dummy initialization\n\nimport WebMercatorViewport from '../viewports/web-mercator-viewport';\nimport log from '../utils/log';\nimport { flatten } from '../utils/flatten';\nimport { setPropOverrides, layerEditListener, seerInitListener, initLayerInSeer, updateLayerInSeer } from './seer-integration';\nvar LOG_PRIORITY_LIFECYCLE = 2;\nvar LOG_PRIORITY_LIFECYCLE_MINOR = 4;\nvar initialContext = {\n  uniforms: {},\n  viewports: [],\n  viewport: null,\n  layerFilter: null,\n  viewportChanged: true,\n  pickingFBO: null,\n  useDevicePixels: true,\n  lastPickedInfo: {\n    index: -1,\n    layerId: null\n  }\n};\n\nvar layerName = function layerName(layer) {\n  return layer instanceof Layer ? '' + layer : !layer ? 'null' : 'invalid';\n};\n\nvar LayerManager = function () {\n  // eslint-disable-next-line\n  function LayerManager(gl) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        eventManager = _ref.eventManager;\n\n    _classCallCheck(this, LayerManager); // Currently deck.gl expects the DeckGL.layers array to be different\n    // whenever React rerenders. If the same layers array is used, the\n    // LayerManager's diffing algorithm will generate a fatal error and\n    // break the rendering.\n    // `this.lastRenderedLayers` stores the UNFILTERED layers sent\n    // down to LayerManager, so that `layers` reference can be compared.\n    // If it's the same across two React render calls, the diffing logic\n    // will be skipped.\n\n\n    this.lastRenderedLayers = [];\n    this.prevLayers = [];\n    this.layers = [];\n    this.oldContext = {};\n    this.context = Object.assign({}, initialContext, {\n      gl: gl,\n      // Enabling luma.gl Program caching using private API (_cachePrograms)\n      shaderCache: new ShaderCache({\n        gl: gl,\n        _cachePrograms: true\n      })\n    }); // List of view descriptors, gets re-evaluated when width/height changes\n\n    this.width = 100;\n    this.height = 100;\n    this.viewDescriptors = [];\n    this.viewDescriptorsChanged = true;\n    this.viewports = []; // Generated viewports\n\n    this._needsRedraw = 'Initial render'; // Event handling\n\n    this._pickingRadius = 0;\n    this._eventManager = null;\n    this._onLayerClick = null;\n    this._onLayerHover = null;\n    this._onClick = this._onClick.bind(this);\n    this._onPointerMove = this._onPointerMove.bind(this);\n    this._onPointerLeave = this._onPointerLeave.bind(this);\n    this._pickAndCallback = this._pickAndCallback.bind(this); // Seer integration\n\n    this._initSeer = this._initSeer.bind(this);\n    this._editSeer = this._editSeer.bind(this);\n    seerInitListener(this._initSeer);\n    layerEditListener(this._editSeer);\n    Object.seal(this);\n\n    if (eventManager) {\n      this._initEventHandling(eventManager);\n    } // Init with dummy viewport\n\n\n    this.setViewports([new WebMercatorViewport({\n      width: 1,\n      height: 1,\n      latitude: 0,\n      longitude: 0,\n      zoom: 1\n    })]);\n  }\n  /**\n   * Method to call when the layer manager is not needed anymore.\n   *\n   * Currently used in the <DeckGL> componentWillUnmount lifecycle to unbind Seer listeners.\n   */\n\n\n  _createClass(LayerManager, [{\n    key: 'finalize',\n    value: function finalize() {\n      seer.removeListener(this._initSeer);\n      seer.removeListener(this._editSeer);\n    }\n  }, {\n    key: 'needsRedraw',\n    value: function needsRedraw() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$clearRedrawFlag = _ref2.clearRedrawFlags,\n          clearRedrawFlags = _ref2$clearRedrawFlag === undefined ? true : _ref2$clearRedrawFlag;\n\n      return this._checkIfNeedsRedraw(clearRedrawFlags);\n    } // Normally not called by app\n\n  }, {\n    key: 'setNeedsRedraw',\n    value: function setNeedsRedraw(reason) {\n      this._needsRedraw = this._needsRedraw || reason;\n    } // Gets an (optionally) filtered list of layers\n\n  }, {\n    key: 'getLayers',\n    value: function getLayers() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref3$layerIds = _ref3.layerIds,\n          layerIds = _ref3$layerIds === undefined ? null : _ref3$layerIds; // Filtering by layerId compares beginning of strings, so that sublayers will be included\n      // Dependes on the convention of adding suffixes to the parent's layer name\n\n\n      return layerIds ? this.layers.filter(function (layer) {\n        return layerIds.find(function (layerId) {\n          return layer.id.indexOf(layerId) === 0;\n        });\n      }) : this.layers;\n    } // Get a set of viewports for a given width and height\n    // TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props\n\n  }, {\n    key: 'getViewports',\n    value: function getViewports() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          width = _ref4.width,\n          height = _ref4.height;\n\n      if (width !== this.width || height !== this.height || this.viewDescriptorsChanged) {\n        this._rebuildViewportsFromViews({\n          viewDescriptors: this.viewDescriptors,\n          width: width,\n          height: height\n        });\n\n        this.width = width;\n        this.height = height;\n      }\n\n      return this.viewports;\n    }\n    /**\n     * Set parameters needed for layer rendering and picking.\n     * Parameters are to be passed as a single object, with the following values:\n     * @param {Boolean} useDevicePixels\n     */\n\n  }, {\n    key: 'setParameters',\n    value: function setParameters(parameters) {\n      if ('eventManager' in parameters) {\n        this._initEventHandling(parameters.eventManager);\n      }\n\n      if ('pickingRadius' in parameters || 'onLayerClick' in parameters || 'onLayerHover' in parameters) {\n        this._setEventHandlingParameters(parameters);\n      } // TODO - For now we set layers before viewports to preservenchangeFlags\n\n\n      if ('layers' in parameters) {\n        this.setLayers(parameters.layers);\n      }\n\n      if ('viewports' in parameters) {\n        this.setViewports(parameters.viewports);\n      }\n\n      if ('layerFilter' in parameters) {\n        this.context.layerFilter = parameters.layerFilter;\n\n        if (this.context.layerFilter !== parameters.layerFilter) {\n          this.setNeedsRedraw('layerFilter changed');\n        }\n      }\n\n      if ('drawPickingColors' in parameters) {\n        if (this.context.drawPickingColors !== parameters.drawPickingColors) {\n          this.setNeedsRedraw('drawPickingColors changed');\n        }\n      }\n\n      Object.assign(this.context, parameters);\n    } // Update the view descriptor list and set change flag if needed\n\n  }, {\n    key: 'setViewports',\n    value: function setViewports(viewports) {\n      // Ensure viewports are wrapped in descriptors\n      var viewDescriptors = flatten(viewports, {\n        filter: Boolean\n      }).map(function (viewport) {\n        return viewport instanceof Viewport ? {\n          viewport: viewport\n        } : viewport;\n      });\n      this.viewDescriptorsChanged = this.viewDescriptorsChanged || this._diffViews(viewDescriptors, this.viewDescriptors); // Try to not actually rebuild the viewports until `getViewports` is called\n\n      if (this.viewDescriptorsChanged) {\n        this.viewDescriptors = viewDescriptors;\n\n        this._rebuildViewportsFromViews({\n          viewDescriptors: this.viewDescriptors\n        });\n\n        this.viewDescriptorsChanged = false;\n      }\n    } // Supply a new layer list, initiating sublayer generation and layer matching\n\n  }, {\n    key: 'setLayers',\n    value: function setLayers(newLayers) {\n      assert(this.context.viewport, 'LayerManager.updateLayers: viewport not set'); // TODO - something is generating state updates that cause rerender of the same\n\n      if (newLayers === this.lastRenderedLayers) {\n        log.log(3, 'Ignoring layer update due to layer array not changed');\n        return this;\n      }\n\n      this.lastRenderedLayers = newLayers;\n      newLayers = flatten(newLayers, {\n        filter: Boolean\n      });\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = newLayers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var layer = _step.value;\n          layer.context = this.context;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.prevLayers = this.layers;\n\n      var _updateLayers2 = this._updateLayers({\n        oldLayers: this.prevLayers,\n        newLayers: newLayers\n      }),\n          error = _updateLayers2.error,\n          generatedLayers = _updateLayers2.generatedLayers;\n\n      this.layers = generatedLayers; // Throw first error found, if any\n\n      if (error) {\n        throw error;\n      }\n\n      return this;\n    }\n  }, {\n    key: 'drawLayers',\n    value: function drawLayers() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref5$pass = _ref5.pass,\n          pass = _ref5$pass === undefined ? 'render to screen' : _ref5$pass,\n          _ref5$redrawReason = _ref5.redrawReason,\n          redrawReason = _ref5$redrawReason === undefined ? 'unknown reason' : _ref5$redrawReason;\n\n      var _context = this.context,\n          gl = _context.gl,\n          useDevicePixels = _context.useDevicePixels,\n          drawPickingColors = _context.drawPickingColors; // render this viewport\n\n      _drawLayers(gl, {\n        layers: this.layers,\n        viewports: this.getViewports(),\n        onViewportActive: this._activateViewport.bind(this),\n        useDevicePixels: useDevicePixels,\n        drawPickingColors: drawPickingColors,\n        pass: pass,\n        layerFilter: this.context.layerFilter,\n        redrawReason: redrawReason\n      });\n    } // Pick the closest info at given coordinate\n\n  }, {\n    key: 'pickObject',\n    value: function pickObject(_ref6) {\n      var x = _ref6.x,\n          y = _ref6.y,\n          mode = _ref6.mode,\n          _ref6$radius = _ref6.radius,\n          radius = _ref6$radius === undefined ? 0 : _ref6$radius,\n          layerIds = _ref6.layerIds,\n          layerFilter = _ref6.layerFilter;\n      var _context2 = this.context,\n          gl = _context2.gl,\n          useDevicePixels = _context2.useDevicePixels;\n      var layers = this.getLayers({\n        layerIds: layerIds\n      });\n      return _pickObject(gl, {\n        // User params\n        x: x,\n        y: y,\n        radius: radius,\n        layers: layers,\n        mode: mode,\n        layerFilter: layerFilter,\n        // Injected params\n        viewports: this.getViewports(),\n        onViewportActive: this._activateViewport.bind(this),\n        pickingFBO: this._getPickingBuffer(),\n        lastPickedInfo: this.context.lastPickedInfo,\n        useDevicePixels: useDevicePixels\n      });\n    } // Get all unique infos within a bounding box\n\n  }, {\n    key: 'pickObjects',\n    value: function pickObjects(_ref7) {\n      var x = _ref7.x,\n          y = _ref7.y,\n          width = _ref7.width,\n          height = _ref7.height,\n          layerIds = _ref7.layerIds,\n          layerFilter = _ref7.layerFilter;\n      var _context3 = this.context,\n          gl = _context3.gl,\n          useDevicePixels = _context3.useDevicePixels;\n      var layers = this.getLayers({\n        layerIds: layerIds\n      });\n      return pickVisibleObjects(gl, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        layers: layers,\n        layerFilter: layerFilter,\n        mode: 'pickObjects',\n        // TODO - how does this interact with multiple viewports?\n        viewport: this.context.viewport,\n        viewports: this.getViewports(),\n        onViewportActive: this._activateViewport.bind(this),\n        pickingFBO: this._getPickingBuffer(),\n        useDevicePixels: useDevicePixels\n      });\n    } //\n    // DEPRECATED METHODS in V5\n    //\n\n  }, {\n    key: 'updateLayers',\n    value: function updateLayers(_ref8) {\n      var newLayers = _ref8.newLayers;\n      log.deprecated('updateLayers', 'setLayers');\n      this.setLayers(newLayers);\n    }\n  }, {\n    key: 'setViewport',\n    value: function setViewport(viewport) {\n      log.deprecated('setViewport', 'setViewports');\n      this.setViewports([viewport]);\n      return this;\n    } //\n    // PRIVATE METHODS\n    //\n\n  }, {\n    key: '_checkIfNeedsRedraw',\n    value: function _checkIfNeedsRedraw(clearRedrawFlags) {\n      var redraw = this._needsRedraw;\n\n      if (clearRedrawFlags) {\n        this._needsRedraw = false;\n      } // This layers list doesn't include sublayers, relying on composite layers\n\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.layers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var layer = _step2.value; // Call every layer to clear their flags\n\n          var layerNeedsRedraw = layer.getNeedsRedraw({\n            clearRedrawFlags: clearRedrawFlags\n          });\n          redraw = redraw || layerNeedsRedraw;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return redraw;\n    } // Rebuilds viewports from descriptors towards a certain window size\n\n  }, {\n    key: '_rebuildViewportsFromViews',\n    value: function _rebuildViewportsFromViews(_ref9) {\n      var _this = this;\n\n      var viewDescriptors = _ref9.viewDescriptors,\n          width = _ref9.width,\n          height = _ref9.height;\n      var newViewports = viewDescriptors.map(function (viewDescriptor) {\n        return (// If a `Viewport` instance was supplied, use it, otherwise build it\n          viewDescriptor.viewport instanceof Viewport ? viewDescriptor.viewport : _this._makeViewportFromViewDescriptor({\n            viewDescriptor: viewDescriptor,\n            width: width,\n            height: height\n          })\n        );\n      });\n      this.setNeedsRedraw('Viewport(s) changed'); // Ensure one viewport is activated, layers may expect it\n      // TODO - handle empty viewport list (using dummy viewport), or assert\n      // const oldViewports = this.context.viewports;\n      // if (viewportsChanged) {\n\n      var viewport = newViewports[0];\n      assert(viewport instanceof Viewport, 'Invalid viewport');\n      this.context.viewports = newViewports;\n\n      this._activateViewport(viewport); // }\n      // We've just rebuilt the viewports to match the descriptors, so clear the flag\n\n\n      this.viewports = newViewports;\n      this.viewDescriptorsChanged = false;\n    } // Build a `Viewport` from a view descriptor\n    // TODO - add support for autosizing viewports using width and height\n\n  }, {\n    key: '_makeViewportFromViewDescriptor',\n    value: function _makeViewportFromViewDescriptor(_ref10) {\n      var viewDescriptor = _ref10.viewDescriptor,\n          width = _ref10.width,\n          height = _ref10.height; // Get the type of the viewport\n      // TODO - default to WebMercator?\n\n      var ViewportType = viewDescriptor.type,\n          viewState = viewDescriptor.viewState; // Resolve relative viewport dimensions\n      // TODO - we need to have width and height available\n\n      var viewportDimensions = this._getViewDimensions({\n        viewDescriptor: viewDescriptor\n      }); // Create the viewport, giving preference to view state in `viewState`\n\n\n      return new ViewportType(Object.assign({}, viewDescriptor, viewportDimensions, viewState // Object.assign handles undefined\n      ));\n    } // Check if viewport array has changed, returns true if any change\n    // Note that descriptors can be the same\n\n  }, {\n    key: '_diffViews',\n    value: function _diffViews(newViews, oldViews) {\n      var _this2 = this;\n\n      if (newViews.length !== oldViews.length) {\n        return true;\n      }\n\n      return newViews.some(function (_, i) {\n        return _this2._diffView(newViews[i], oldViews[i]);\n      });\n    }\n  }, {\n    key: '_diffView',\n    value: function _diffView(newView, oldView) {\n      // `View` hiearchy supports an `equals` method\n      if (newView.viewport) {\n        return !oldView.viewport || !newView.viewport.equals(oldView.viewport);\n      } // TODO - implement deep equal on view descriptors\n\n\n      return newView !== oldView;\n    } // Support for relative viewport dimensions (e.g {y: '50%', height: '50%'})\n\n  }, {\n    key: '_getViewDimensions',\n    value: function _getViewDimensions(_ref11) {\n      var viewDescriptor = _ref11.viewDescriptor,\n          width = _ref11.width,\n          height = _ref11.height;\n\n      var parsePercent = function parsePercent(value, max) {\n        return value;\n      }; // TODO - enable to support percent size specifiers\n      // const parsePercent = (value, max) => value ?\n      //   Math.round(parseFloat(value) / 100 * max) :\n      //   (value === null ? max : value);\n\n\n      return {\n        x: parsePercent(viewDescriptor.x, width),\n        y: parsePercent(viewDescriptor.y, height),\n        width: parsePercent(viewDescriptor.width, width),\n        height: parsePercent(viewDescriptor.height, height)\n      };\n    }\n    /**\n     * @param {Object} eventManager   A source of DOM input events\n     */\n\n  }, {\n    key: '_initEventHandling',\n    value: function _initEventHandling(eventManager) {\n      this._eventManager = eventManager; // TODO: add/remove handlers on demand at runtime, not all at once on init.\n      // Consider both top-level handlers like onLayerClick/Hover\n      // and per-layer handlers attached to individual layers.\n      // https://github.com/uber/deck.gl/issues/634\n\n      this._eventManager.on({\n        click: this._onClick,\n        pointermove: this._onPointerMove,\n        pointerleave: this._onPointerLeave\n      });\n    } // Set parameters for input event handling.\n\n  }, {\n    key: '_setEventHandlingParameters',\n    value: function _setEventHandlingParameters(_ref12) {\n      var pickingRadius = _ref12.pickingRadius,\n          onLayerClick = _ref12.onLayerClick,\n          onLayerHover = _ref12.onLayerHover;\n\n      if (!isNaN(pickingRadius)) {\n        this._pickingRadius = pickingRadius;\n      }\n\n      if (typeof onLayerClick !== 'undefined') {\n        this._onLayerClick = onLayerClick;\n      }\n\n      if (typeof onLayerHover !== 'undefined') {\n        this._onLayerHover = onLayerHover;\n      }\n\n      this._validateEventHandling();\n    } // Make a viewport \"current\" in layer context, primed for draw\n\n  }, {\n    key: '_activateViewport',\n    value: function _activateViewport(viewport) {\n      // TODO - viewport change detection breaks METER_OFFSETS mode\n      // const oldViewport = this.context.viewport;\n      // const viewportChanged = !oldViewport || !viewport.equals(oldViewport);\n      var viewportChanged = true;\n\n      if (viewportChanged) {\n        Object.assign(this.oldContext, this.context);\n        this.context.viewport = viewport;\n        this.context.viewportChanged = true;\n        this.context.uniforms = {};\n        log(4, viewport); // Update layers states\n        // Let screen space layers update their state based on viewport\n        // TODO - reimplement viewport change detection (single viewport optimization)\n        // TODO - don't set viewportChanged during setViewports?\n\n        if (this.context.viewportChanged) {\n          var _iteratorNormalCompletion3 = true;\n          var _didIteratorError3 = false;\n          var _iteratorError3 = undefined;\n\n          try {\n            for (var _iterator3 = this.layers[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n              var layer = _step3.value;\n              layer.setChangeFlags({\n                viewportChanged: 'Viewport changed'\n              });\n\n              this._updateLayer(layer);\n            }\n          } catch (err) {\n            _didIteratorError3 = true;\n            _iteratorError3 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n              }\n            } finally {\n              if (_didIteratorError3) {\n                throw _iteratorError3;\n              }\n            }\n          }\n        }\n      }\n\n      assert(this.context.viewport, 'LayerManager: viewport not set');\n      return this;\n    }\n  }, {\n    key: '_getPickingBuffer',\n    value: function _getPickingBuffer() {\n      var gl = this.context.gl; // Create a frame buffer if not already available\n\n      this.context.pickingFBO = this.context.pickingFBO || new Framebuffer(gl); // Resize it to current canvas size (this is a noop if size hasn't changed)\n\n      this.context.pickingFBO.resize({\n        width: gl.canvas.width,\n        height: gl.canvas.height\n      });\n      return this.context.pickingFBO;\n    } // Match all layers, checking for caught errors\n    // To avoid having an exception in one layer disrupt other layers\n    // TODO - mark layers with exceptions as bad and remove from rendering cycle?\n\n  }, {\n    key: '_updateLayers',\n    value: function _updateLayers(_ref13) {\n      var oldLayers = _ref13.oldLayers,\n          newLayers = _ref13.newLayers; // Create old layer map\n\n      var oldLayerMap = {};\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = oldLayers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var oldLayer = _step4.value;\n\n          if (oldLayerMap[oldLayer.id]) {\n            log.warn('Multiple old layers with same id ' + layerName(oldLayer));\n          } else {\n            oldLayerMap[oldLayer.id] = oldLayer;\n          }\n        } // Allocate array for generated layers\n\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      var generatedLayers = []; // Match sublayers\n\n      var error = this._updateSublayersRecursively({\n        newLayers: newLayers,\n        oldLayerMap: oldLayerMap,\n        generatedLayers: generatedLayers\n      }); // Finalize unmatched layers\n\n\n      var error2 = this._finalizeOldLayers(oldLayerMap);\n\n      var firstError = error || error2;\n      return {\n        error: firstError,\n        generatedLayers: generatedLayers\n      };\n    } // Note: adds generated layers to `generatedLayers` array parameter\n\n  }, {\n    key: '_updateSublayersRecursively',\n    value: function _updateSublayersRecursively(_ref14) {\n      var newLayers = _ref14.newLayers,\n          oldLayerMap = _ref14.oldLayerMap,\n          generatedLayers = _ref14.generatedLayers;\n      var error = null;\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = newLayers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var newLayer = _step5.value;\n          newLayer.context = this.context; // Given a new coming layer, find its matching old layer (if any)\n\n          var oldLayer = oldLayerMap[newLayer.id];\n\n          if (oldLayer === null) {\n            // null, rather than undefined, means this id was originally there\n            log.warn('Multiple new layers with same id ' + layerName(newLayer));\n          } // Remove the old layer from candidates, as it has been matched with this layer\n\n\n          oldLayerMap[newLayer.id] = null;\n          var sublayers = null; // We must not generate exceptions until after layer matching is complete\n\n          try {\n            if (!oldLayer) {\n              this._initializeLayer(newLayer);\n\n              initLayerInSeer(newLayer); // Initializes layer in seer chrome extension (if connected)\n            } else {\n              this._transferLayerState(oldLayer, newLayer);\n\n              this._updateLayer(newLayer);\n\n              updateLayerInSeer(newLayer); // Updates layer in seer chrome extension (if connected)\n            }\n\n            generatedLayers.push(newLayer); // Call layer lifecycle method: render sublayers\n\n            sublayers = newLayer.isComposite && newLayer.getSubLayers(); // End layer lifecycle method: render sublayers\n          } catch (err) {\n            log.warn('error during matching of ' + layerName(newLayer), err);\n            error = error || err; // Record first exception\n          }\n\n          if (sublayers) {\n            this._updateSublayersRecursively({\n              newLayers: sublayers,\n              oldLayerMap: oldLayerMap,\n              generatedLayers: generatedLayers\n            });\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return error;\n    } // Finalize any old layers that were not matched\n\n  }, {\n    key: '_finalizeOldLayers',\n    value: function _finalizeOldLayers(oldLayerMap) {\n      var error = null;\n\n      for (var layerId in oldLayerMap) {\n        var layer = oldLayerMap[layerId];\n\n        if (layer) {\n          error = error || this._finalizeLayer(layer);\n        }\n      }\n\n      return error;\n    } // Initializes a single layer, calling layer methods\n\n  }, {\n    key: '_initializeLayer',\n    value: function _initializeLayer(layer) {\n      assert(!layer.state);\n      log(LOG_PRIORITY_LIFECYCLE, 'initializing ' + layerName(layer));\n      var error = null;\n\n      try {\n        layer._initialize();\n\n        layer.lifecycle = LIFECYCLE.INITIALIZED;\n      } catch (err) {\n        log.warn('error while initializing ' + layerName(layer) + '\\n', err);\n        error = error || err; // TODO - what should the lifecycle state be here? LIFECYCLE.INITIALIZATION_FAILED?\n      }\n\n      assert(layer.state); // Set back pointer (used in picking)\n\n      layer.state.layer = layer; // Save layer on model for picking purposes\n      // store on model.userData rather than directly on model\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = layer.getModels()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var model = _step6.value;\n          model.userData.layer = layer;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return error;\n    }\n  }, {\n    key: '_transferLayerState',\n    value: function _transferLayerState(oldLayer, newLayer) {\n      if (newLayer !== oldLayer) {\n        log(LOG_PRIORITY_LIFECYCLE_MINOR, 'matched ' + layerName(newLayer), oldLayer, '->', newLayer);\n        newLayer.lifecycle = LIFECYCLE.MATCHED;\n        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;\n\n        newLayer._transferState(oldLayer);\n      } else {\n        log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'Matching layer is unchanged ' + newLayer.id);\n        newLayer.lifecycle = LIFECYCLE.MATCHED;\n        newLayer.oldProps = newLayer.props;\n      }\n    } // Updates a single layer, cleaning all flags\n\n  }, {\n    key: '_updateLayer',\n    value: function _updateLayer(layer) {\n      log.log(LOG_PRIORITY_LIFECYCLE_MINOR, 'updating ' + layer + ' because: ' + layer.printChangeFlags());\n      var error = null;\n\n      try {\n        layer._update();\n      } catch (err) {\n        log.warn('error during update of ' + layerName(layer), err); // Save first error\n\n        error = err;\n      }\n\n      return error;\n    } // Finalizes a single layer\n\n  }, {\n    key: '_finalizeLayer',\n    value: function _finalizeLayer(layer) {\n      assert(layer.state);\n      assert(layer.lifecycle !== LIFECYCLE.AWAITING_FINALIZATION);\n      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;\n      var error = null;\n      this.setNeedsRedraw('finalized ' + layerName(layer));\n\n      try {\n        layer._finalize();\n      } catch (err) {\n        log.warn('error during finalization of ' + layerName(layer), err);\n        error = err;\n      }\n\n      layer.lifecycle = LIFECYCLE.FINALIZED;\n      log(LOG_PRIORITY_LIFECYCLE, 'finalizing ' + layerName(layer));\n      return error;\n    }\n    /**\n     * Warn if a deck-level mouse event has been specified,\n     * but no layers are `pickable`.\n     */\n\n  }, {\n    key: '_validateEventHandling',\n    value: function _validateEventHandling() {\n      if (this.onLayerClick || this.onLayerHover) {\n        if (this.layers.length && !this.layers.some(function (layer) {\n          return layer.props.pickable;\n        })) {\n          log.warn('You have supplied a top-level input event handler (e.g. `onLayerClick`), ' + 'but none of your layers have set the `pickable` flag.');\n        }\n      }\n    }\n    /**\n     * Route click events to layers.\n     * `pickLayer` will call the `onClick` prop of any picked layer,\n     * and `onLayerClick` is called directly from here\n     * with any picking info generated by `pickLayer`.\n     * @param {Object} event  An object encapsulating an input event,\n     *                        with the following shape:\n     *                        {Object: {x, y}} offsetCenter: center of the event\n     *                        {Object} srcEvent:             native JS Event object\n     */\n\n  }, {\n    key: '_onClick',\n    value: function _onClick(event) {\n      if (!event.offsetCenter) {\n        // Do not trigger onHover callbacks when click position is invalid.\n        return;\n      }\n\n      this._pickAndCallback({\n        callback: this._onLayerClick,\n        event: event,\n        mode: 'click'\n      });\n    }\n    /**\n     * Route click events to layers.\n     * `pickLayer` will call the `onHover` prop of any picked layer,\n     * and `onLayerHover` is called directly from here\n     * with any picking info generated by `pickLayer`.\n     * @param {Object} event  An object encapsulating an input event,\n     *                        with the following shape:\n     *                        {Object: {x, y}} offsetCenter: center of the event\n     *                        {Object} srcEvent:             native JS Event object\n     */\n\n  }, {\n    key: '_onPointerMove',\n    value: function _onPointerMove(event) {\n      if (event.isDown) {\n        // Do not trigger onHover callbacks if mouse button is down.\n        return;\n      }\n\n      this._pickAndCallback({\n        callback: this._onLayerHover,\n        event: event,\n        mode: 'hover'\n      });\n    }\n  }, {\n    key: '_onPointerLeave',\n    value: function _onPointerLeave(event) {\n      this.pickObject({\n        x: -1,\n        y: -1,\n        radius: this._pickingRadius,\n        mode: 'hover'\n      });\n    }\n  }, {\n    key: '_pickAndCallback',\n    value: function _pickAndCallback(options) {\n      var pos = options.event.offsetCenter;\n      var radius = this._pickingRadius;\n      var selectedInfos = this.pickObject({\n        x: pos.x,\n        y: pos.y,\n        radius: radius,\n        mode: options.mode\n      });\n\n      if (options.callback) {\n        var firstInfo = selectedInfos.find(function (info) {\n          return info.index >= 0;\n        }) || null; // As per documentation, send null value when no valid object is picked.\n\n        options.callback(firstInfo, selectedInfos, options.event.srcEvent);\n      }\n    } // SEER INTEGRATION\n\n    /**\n     * Called upon Seer initialization, manually sends layers data.\n     */\n\n  }, {\n    key: '_initSeer',\n    value: function _initSeer() {\n      this.layers.forEach(function (layer) {\n        initLayerInSeer(layer);\n        updateLayerInSeer(layer);\n      });\n    }\n    /**\n     * On Seer property edition, set override and update layers.\n     */\n\n  }, {\n    key: '_editSeer',\n    value: function _editSeer(payload) {\n      if (payload.type !== 'edit' || payload.valuePath[0] !== 'props') {\n        return;\n      }\n\n      setPropOverrides(payload.itemKey, payload.valuePath.slice(1), payload.value);\n      var newLayers = this.layers.map(function (layer) {\n        return new layer.constructor(layer.props);\n      });\n      this.updateLayers({\n        newLayers: newLayers\n      });\n    }\n  }]);\n\n  return LayerManager;\n}();\n\nexport default LayerManager;","map":null,"metadata":{},"sourceType":"module"}