{"ast":null,"code":"function _instanceof(left, right) {\n  if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n    return right[Symbol.hasInstance](left);\n  } else {\n    return left instanceof right;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nimport GL from '../constants';\nimport Texture from './texture';\nimport assert from '../utils/assert';\nvar FACES = [GL.TEXTURE_CUBE_MAP_POSITIVE_X, GL.TEXTURE_CUBE_MAP_NEGATIVE_X, GL.TEXTURE_CUBE_MAP_POSITIVE_Y, GL.TEXTURE_CUBE_MAP_NEGATIVE_Y, GL.TEXTURE_CUBE_MAP_POSITIVE_Z, GL.TEXTURE_CUBE_MAP_NEGATIVE_Z];\n\nvar TextureCube =\n/*#__PURE__*/\nfunction (_Texture) {\n  _inherits(TextureCube, _Texture);\n\n  function TextureCube(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TextureCube);\n\n    _this = _possibleConstructorReturn(this, (TextureCube.__proto__ || Object.getPrototypeOf(TextureCube)).call(this, gl, Object.assign({}, opts, {\n      target: GL.TEXTURE_CUBE_MAP\n    })));\n\n    _this.initialize(opts);\n\n    Object.seal(_assertThisInitialized(_this));\n    return _this;\n  }\n  /* eslint-disable max-len, max-statements */\n\n\n  _createClass(TextureCube, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$format = opts.format,\n          format = _opts$format === void 0 ? GL.RGBA : _opts$format,\n          _opts$mipmaps = opts.mipmaps,\n          mipmaps = _opts$mipmaps === void 0 ? true : _opts$mipmaps;\n      var _opts$width = opts.width,\n          width = _opts$width === void 0 ? 1 : _opts$width,\n          _opts$height = opts.height,\n          height = _opts$height === void 0 ? 1 : _opts$height,\n          _opts$type = opts.type,\n          type = _opts$type === void 0 ? GL.UNSIGNED_BYTE : _opts$type,\n          dataFormat = opts.dataFormat; // Deduce width and height based on one of the faces\n\n      var _deduceParameters = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat\n      });\n\n      type = _deduceParameters.type;\n      dataFormat = _deduceParameters.dataFormat;\n\n      var _deduceImageSize = this._deduceImageSize({\n        data: opts[GL.TEXTURE_CUBE_MAP_POSITIVE_X],\n        width: width,\n        height: height\n      });\n\n      width = _deduceImageSize.width;\n      height = _deduceImageSize.height; // Enforce cube\n\n      assert(width === height); // Temporarily apply any pixel store paramaters and build textures\n      // withParameters(this.gl, opts, () => {\n      //   for (const face of CUBE_MAP_FACES) {\n      //     this.setImageData({\n      //       target: face,\n      //       data: opts[face],\n      //       width, height, format, type, dataFormat, border, mipmaps\n      //     });\n      //   }\n      // });\n\n      this.setCubeMapImageData(opts); // Called here so that GL.\n      // TODO - should genMipmap() be called on the cubemap or on the faces?\n\n      if (mipmaps) {\n        this.generateMipmap(opts);\n      } // Store opts for accessors\n\n\n      this.opts = opts;\n    }\n  }, {\n    key: \"subImage\",\n    value: function subImage(_ref) {\n      var face = _ref.face,\n          data = _ref.data,\n          _ref$x = _ref.x,\n          x = _ref$x === void 0 ? 0 : _ref$x,\n          _ref$y = _ref.y,\n          y = _ref$y === void 0 ? 0 : _ref$y,\n          _ref$mipmapLevel = _ref.mipmapLevel,\n          mipmapLevel = _ref$mipmapLevel === void 0 ? 0 : _ref$mipmapLevel;\n      return this._subImage({\n        target: face,\n        data: data,\n        x: x,\n        y: y,\n        mipmapLevel: mipmapLevel\n      });\n    }\n    /* eslint-disable max-statements, max-len */\n\n  }, {\n    key: \"setCubeMapImageData\",\n    value: function setCubeMapImageData(_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height,\n          pixels = _ref2.pixels,\n          data = _ref2.data,\n          _ref2$border = _ref2.border,\n          border = _ref2$border === void 0 ? 0 : _ref2$border,\n          _ref2$format = _ref2.format,\n          format = _ref2$format === void 0 ? GL.RGBA : _ref2$format,\n          _ref2$type = _ref2.type,\n          type = _ref2$type === void 0 ? GL.UNSIGNED_BYTE : _ref2$type,\n          _ref2$generateMipmap = _ref2.generateMipmap,\n          generateMipmap = _ref2$generateMipmap === void 0 ? false : _ref2$generateMipmap;\n      var gl = this.gl;\n      pixels = pixels || data;\n      this.bind();\n\n      if (this.width || this.height) {\n        for (var _i = 0; _i < FACES.length; _i++) {\n          var face = FACES[_i];\n          gl.texImage2D(face, 0, format, width, height, border, format, type, pixels[face]);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < FACES.length; _i2++) {\n          var _face = FACES[_i2];\n          gl.texImage2D(_face, 0, format, format, type, pixels[_face]);\n        }\n      }\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          index = _ref3.index;\n\n      if (index !== undefined) {\n        this.gl.activeTexture(GL.TEXTURE0 + index);\n      }\n\n      this.gl.bindTexture(GL.TEXTURE_CUBE_MAP, this.handle);\n      return index;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.gl.bindTexture(GL.TEXTURE_CUBE_MAP, null);\n      return this;\n    }\n  }]);\n\n  return TextureCube;\n}(Texture);\n\nexport { TextureCube as default };\nTextureCube.FACES = FACES;","map":null,"metadata":{},"sourceType":"module"}