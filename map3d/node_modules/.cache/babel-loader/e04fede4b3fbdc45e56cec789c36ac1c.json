{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport 'luma.gl/debug';\nimport { createGLContext, Model, Texture2D, _MultiPassRenderer as MultiPassRenderer, _ClearPass as ClearPass, _CopyPass as CopyPass, _TexturePass as TexturePass } from 'luma.gl';\nimport ShaderModulePass from './shader-module-pass';\n/* global document */\n\nvar DEFAULT_VS = \"attribute vec2 vertex;\\nattribute vec2 _texCoord;\\nvarying vec2 texCoord;\\nvoid main() {\\n  texCoord = _texCoord;\\n  gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);\\n}\\n\";\n\nvar Canvas =\n/*#__PURE__*/\nfunction () {\n  function Canvas() {\n    _classCallCheck(this, Canvas);\n\n    this.canvas = document.createElement('canvas');\n    this.width = this.canvas.clientWidth;\n    this.height = this.canvas.clientHeight;\n    this.gl = createGLContext({\n      canvas: this.canvas,\n      opts: {\n        premultipliedAlpha: false\n      }\n    });\n\n    if (!this.gl) {\n      throw new Error('This browser does not support WebGL');\n    }\n\n    this.texture = null;\n    this.spareTexture = null;\n    this.flippedModel = null;\n  }\n\n  _createClass(Canvas, [{\n    key: \"installFiltersAsMethods\",\n    value: function installFiltersAsMethods(filters) {\n      var _this = this;\n\n      var _loop = function _loop(key) {\n        if (key !== 'canvas') {\n          _this[key] = function (props) {\n            return _this.filter(filters[key], props).bind(_this);\n          };\n        }\n      }; // // Filter methods\n\n\n      for (var key in filters) {\n        _loop(key);\n      }\n    }\n  }, {\n    key: \"setTexture\",\n    value: function setTexture(element) {\n      this.texture = new Texture2D(this.gl, {\n        pixels: element\n      });\n      this.resize(this.gl, this.texture.width, this.texture.height);\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(gl, width, height) {\n      var realToCSSPixels = 1; // window.devicePixelRatio || 1;\n      // Check if the canvas is not the same size.\n\n      if (gl.canvas.width !== width || gl.canvas.height !== height) {\n        // Make the canvas the same size\n        gl.canvas.width = width;\n        gl.canvas.height = height; // Lookup the size the browser is displaying the canvas in CSS pixels\n        // and compute a size needed to make our drawingbuffer match it in\n        // device pixels.\n\n        var displayWidth = Math.floor(width / realToCSSPixels);\n        var displayHeight = Math.floor(height / realToCSSPixels);\n        gl.canvas.style.width = \"\".concat(displayWidth, \"px\");\n        gl.canvas.style.height = \"\".concat(displayHeight, \"px\");\n        gl.viewport(0, 0, width, height);\n        this.width = displayWidth;\n        this.height = displayHeight;\n      }\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(node) {\n      node.parentNode.insertBefore(this.canvas, node);\n      node.parentNode.removeChild(node);\n      return this;\n    } // Draw a texture to the canvas, with an optional width and height to scale to.\n    // If no width and height are given then the original texture width and height\n    // are used.\n\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      this.multiPassRenderer = new MultiPassRenderer(this.gl, [new ClearPass(this.gl), new TexturePass(this.gl, {\n        texture: this.texture\n      }), new CopyPass(this.gl, {\n        screen: true\n      })]);\n      this.multiPassRenderer.render();\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.multiPassRenderer.render({});\n      return this;\n    }\n  }, {\n    key: \"filter\",\n    value: function filter(shaderModule, props) {\n      this.multiPassRenderer = new MultiPassRenderer(this.gl, [new ClearPass(this.gl), new TexturePass(this.gl, {\n        texture: this.texture\n      }), new ShaderModulePass(this.gl, shaderModule, props), new CopyPass(this.gl, {\n        screen: true\n      })]);\n      this.multiPassRenderer.render();\n      return this;\n    }\n    /*\n    contents() {\n      // const gl = this.gl;\n      // const texture = new Texture2D(this.gl, {\n      //   width: this.texture.width,\n      //   height: this.texture.height,\n      //   format: gl.RGBA,\n      //   type: gl.UNSIGNED_BYTE\n      // });\n      // this.texture.use();\n      // texture.drawTo(() => this.getDefaultModel(this.gl).drawRect());\n      // return wrapTexture(texture);\n    }\n    */\n    // Get a Uint8 array of pixel values: [r, g, b, a, r, g, b, a, ...]\n    // Length of the array will be width * height * 4.\n\n  }, {\n    key: \"getPixelArray\",\n    value: function getPixelArray() {\n      var gl = this.gl;\n      var w = this.texture.width;\n      var h = this.texture.height;\n      var array = new Uint8Array(w * h * 4);\n      this.texture.drawTo(function () {\n        return gl.readPixels(0, 0, w, h, 6408, 5121, array);\n      });\n      return array;\n    }\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(width, height) {\n      var gl = this.gl;\n      var type = 5121; // Go for floating point buffer textures if we can, it'll make the bokeh\n      // filter look a lot better. Note that on Windows, ANGLE does not let you\n      // render to a floating-point texture when linear filtering is enabled.\n      // See http://crbug.com/172278 for more information.\n\n      if (this.gl.getExtension('OES_texture_float') && gl.getExtension('OES_texture_float_linear')) {\n        var testTexture = new Texture2D(this.gl, {\n          width: 100,\n          height: 100,\n          format: 6408,\n          type: 5126\n        });\n\n        try {\n          // Only use gl.FLOAT if we can render to it\n          testTexture.drawTo(function () {\n            type = 5126;\n          });\n        } catch (error) {// ignore\n        }\n\n        testTexture.destroy();\n      }\n\n      if (this.spareTexture) {\n        this.spareTexture.destroy();\n      }\n\n      this.width = width;\n      this.height = height;\n      this.texture = new Texture2D(this.gl, {\n        width: width,\n        height: height,\n        format: 6408,\n        type: type\n      });\n      this.spareTexture = new Texture2D(this.gl, {\n        width: width,\n        height: height,\n        format: 6408,\n        type: type\n      });\n      this.extraTexture = this.extraTexture || new Texture2D(this.gl, {\n        width: 0,\n        height: 0,\n        format: 6408,\n        type: type\n      });\n      this.flippedModel = this.flippedModel || new Model(this.gl, {\n        vs: DEFAULT_VS,\n        fs: \"uniform sampler2D texture;\\nvarying vec2 texCoord;\\nvoid main() {\\n  gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));\\n}\\n\"\n      });\n      this.isInitialized = true;\n    }\n  }]);\n\n  return Canvas;\n}();\n\nexport { Canvas as default };","map":null,"metadata":{},"sourceType":"module"}