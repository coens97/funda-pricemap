{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\n/* eslint-disable no-inline-comments */\n\nimport Resource from './resource';\nimport Texture from './texture';\nimport Framebuffer from './framebuffer';\nimport { parseUniformName, getUniformSetter } from './uniforms';\nimport { VertexShader, FragmentShader } from './shader';\nimport ProgramConfiguration from './program-configuration';\nimport { withParameters } from '../webgl-context/context-state';\nimport { checkUniformValues, areUniformsEqual } from '../webgl/uniforms';\nimport { assertWebGL2Context, isWebGL2 } from '../webgl-utils';\nimport { getPrimitiveDrawMode } from '../webgl-utils/attribute-utils';\nimport { getKey } from '../webgl-utils/constants-to-keys';\nimport { log, uid } from '../utils';\nimport assert from '../utils/assert';\nvar LOG_PROGRAM_PERF_PRIORITY = 4; // const GL_INTERLEAVED_ATTRIBS = 0x8C8C;\n\nvar GL_SEPARATE_ATTRIBS = 0x8C8D;\n\nvar Program =\n/*#__PURE__*/\nfunction (_Resource) {\n  _inherits(Program, _Resource);\n\n  function Program(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Program);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Program).call(this, gl, opts));\n\n    _this.stubRemovedMethods('Program', 'v6.0', ['setVertexArray', 'setAttributes', 'setBuffers', 'unsetBuffers', 'use', 'getUniformCount', 'getUniformInfo', 'getUniformLocation', 'getUniformValue', 'getVarying', 'getFragDataLocation', 'getAttachedShaders', 'getAttributeCount', 'getAttributeLocation', 'getAttributeInfo']); // Experimental flag to avoid deleting Program object while it is cached\n\n\n    _this._isCached = false;\n\n    _this.initialize(opts);\n\n    Object.seal(_assertThisInitialized(_assertThisInitialized(_this)));\n\n    _this._setId(opts.id);\n\n    return _this;\n  }\n\n  _createClass(Program, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var vs = props.vs,\n          fs = props.fs,\n          varyings = props.varyings,\n          _props$bufferMode = props.bufferMode,\n          bufferMode = _props$bufferMode === void 0 ? GL_SEPARATE_ATTRIBS : _props$bufferMode; // Create shaders if needed\n\n      this.vs = typeof vs === 'string' ? new VertexShader(this.gl, {\n        id: \"\".concat(props.id, \"-vs\"),\n        source: vs\n      }) : vs;\n      this.fs = typeof fs === 'string' ? new FragmentShader(this.gl, {\n        id: \"\".concat(props.id, \"-fs\"),\n        source: fs\n      }) : fs;\n      assert(this.vs instanceof VertexShader);\n      assert(this.fs instanceof FragmentShader); // uniforms\n\n      this.uniforms = {};\n      this.samplers = {}; // Setup varyings if supplied\n\n      if (varyings) {\n        assertWebGL2Context(this.gl);\n        this.varyings = varyings;\n        this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);\n      }\n\n      this._compileAndLink();\n\n      this._readUniformLocationsFromLinkedProgram();\n\n      this.configuration = new ProgramConfiguration(this);\n      return this.setProps(props);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this._isCached) {\n        // This object is cached, do not delete\n        return this;\n      }\n\n      return _get(_getPrototypeOf(Program.prototype), \"delete\", this).call(this, opts);\n    }\n  }, {\n    key: \"setProps\",\n    value: function setProps(props) {\n      if ('uniforms' in props) {\n        this.setUniforms(props.uniforms, props.samplers);\n      }\n\n      return this;\n    } // Another thing about the WebGL API is that there are so many ways to draw things.\n    // This function unifies those ways into a single call using common parameters with sane defaults\n\n  }, {\n    key: \"draw\",\n    value: function draw(_ref) {\n      var _this2 = this;\n\n      var logPriority = _ref.logPriority,\n          _ref$drawMode = _ref.drawMode,\n          drawMode = _ref$drawMode === void 0 ? 4 : _ref$drawMode,\n          vertexCount = _ref.vertexCount,\n          _ref$offset = _ref.offset,\n          offset = _ref$offset === void 0 ? 0 : _ref$offset,\n          start = _ref.start,\n          end = _ref.end,\n          _ref$isIndexed = _ref.isIndexed,\n          isIndexed = _ref$isIndexed === void 0 ? false : _ref$isIndexed,\n          _ref$indexType = _ref.indexType,\n          indexType = _ref$indexType === void 0 ? 5123 : _ref$indexType,\n          _ref$isInstanced = _ref.isInstanced,\n          isInstanced = _ref$isInstanced === void 0 ? false : _ref$isInstanced,\n          _ref$instanceCount = _ref.instanceCount,\n          instanceCount = _ref$instanceCount === void 0 ? 0 : _ref$instanceCount,\n          _ref$vertexArray = _ref.vertexArray,\n          vertexArray = _ref$vertexArray === void 0 ? null : _ref$vertexArray,\n          transformFeedback = _ref.transformFeedback,\n          framebuffer = _ref.framebuffer,\n          _ref$parameters = _ref.parameters,\n          parameters = _ref$parameters === void 0 ? {} : _ref$parameters,\n          _ref$uniforms = _ref.uniforms,\n          uniforms = _ref$uniforms === void 0 ? {} : _ref$uniforms,\n          _ref$samplers = _ref.samplers,\n          samplers = _ref$samplers === void 0 ? {} : _ref$samplers;\n\n      if (logPriority !== undefined) {\n        var fb = framebuffer ? framebuffer.id : 'default';\n        var message = \"mode=\".concat(getKey(this.gl, drawMode), \" verts=\").concat(vertexCount, \" \") + \"instances=\".concat(instanceCount, \" indexType=\").concat(getKey(this.gl, indexType), \" \") + \"isInstanced=\".concat(isInstanced, \" isIndexed=\").concat(isIndexed, \" \") + \"Framebuffer=\".concat(fb);\n        log.log(logPriority, message)();\n      }\n\n      this.gl.useProgram(this.handle); // TODO - move vertex array binding and transform feedback binding to withParameters?\n\n      assert(vertexArray);\n      vertexArray.bindForDraw(vertexCount, instanceCount, function () {\n        if (uniforms) {\n          log.deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)');\n\n          _this2.setUniforms(uniforms, samplers);\n        }\n\n        if (framebuffer !== undefined) {\n          parameters = Object.assign({}, parameters, {\n            framebuffer: framebuffer\n          });\n        }\n\n        if (transformFeedback) {\n          var primitiveMode = getPrimitiveDrawMode(drawMode);\n          transformFeedback.begin(primitiveMode);\n        }\n\n        withParameters(_this2.gl, parameters, function () {\n          // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension\n          if (isIndexed && isInstanced) {\n            _this2.gl.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);\n          } else if (isIndexed && isWebGL2(_this2.gl) && !isNaN(start) && !isNaN(end)) {\n            _this2.gl.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);\n          } else if (isIndexed) {\n            _this2.gl.drawElements(drawMode, vertexCount, indexType, offset);\n          } else if (isInstanced) {\n            _this2.gl.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);\n          } else {\n            _this2.gl.drawArrays(drawMode, offset, vertexCount);\n          }\n        });\n\n        if (transformFeedback) {\n          transformFeedback.end();\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"setSamplers\",\n    value: function setSamplers(samplers) {\n      Object.assign(this.samplers, samplers);\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms() {\n      var uniforms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var samplers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var _onChangeCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {}; // Simple change detection - if all uniforms are unchanged, do nothing\n      // TODO - Disabled since it interferes with textures\n      // we must still rebind texture units to current program's textures before drawing\n      // If modifying, test with `picking` example on website\n\n\n      var somethingChanged = false;\n\n      for (var key in uniforms) {\n        if (!areUniformsEqual(this.uniforms[key], uniforms[key])) {\n          somethingChanged = true;\n          break;\n        }\n      }\n\n      if (somethingChanged) {\n        _onChangeCallback();\n\n        checkUniformValues(uniforms, this.id, this._uniformSetters);\n        Object.assign(this.uniforms, uniforms);\n        Object.assign(this.samplers, samplers);\n      } // TODO - should only set updated uniforms\n\n\n      this._setUniforms(this.uniforms, this.samplers);\n\n      return this;\n    } // PRIVATE METHODS\n    // Apply a set of uniform values to a program\n    // Only uniforms actually present in the linked program will be updated.\n\n    /* eslint-disable max-depth */\n\n  }, {\n    key: \"_setUniforms\",\n    value: function _setUniforms(uniforms) {\n      var samplers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.gl.useProgram(this.handle);\n\n      for (var uniformName in uniforms) {\n        var uniform = uniforms[uniformName];\n        var uniformSetter = this._uniformSetters[uniformName];\n        var sampler = samplers[uniformName];\n\n        if (uniformSetter) {\n          if (uniform instanceof Framebuffer) {\n            uniform = uniform.texture;\n          }\n\n          if (uniform instanceof Texture) {\n            if (uniformSetter.textureIndex === undefined) {\n              uniformSetter.textureIndex = this._textureIndexCounter++;\n            } // Bind texture to index\n\n\n            var texture = uniform;\n            var textureIndex = uniformSetter.textureIndex; // TODO - this should be separated out from uniform setting, since it needs to be done\n            // before every draw even if uniforms have not changed\n\n            texture.bind(textureIndex); // Bind a sampler (if supplied) to index\n\n            if (sampler) {\n              sampler.bind(textureIndex);\n            } // Set the uniform sampler to the texture index\n\n\n            uniformSetter(textureIndex);\n          } else {\n            // Just set the value\n            uniformSetter(uniform);\n          }\n        }\n      }\n\n      return this;\n    } // RESOURCE METHODS\n\n  }, {\n    key: \"_createHandle\",\n    value: function _createHandle() {\n      return this.gl.createProgram();\n    }\n  }, {\n    key: \"_deleteHandle\",\n    value: function _deleteHandle() {\n      this.gl.deleteProgram(this.handle);\n    } // Extract opts needed to initialize a `Program` from an independently created WebGLProgram handle\n\n  }, {\n    key: \"_getOptionsFromHandle\",\n    value: function _getOptionsFromHandle(handle) {\n      var shaderHandles = this.gl.getAttachedShaders(handle);\n      var opts = {};\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = shaderHandles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var shaderHandle = _step.value;\n          var type = this.gl.getShaderParameter(this.handle, 35663);\n\n          switch (type) {\n            case 35633:\n              opts.vs = new VertexShader({\n                handle: shaderHandle\n              });\n              break;\n\n            case 35632:\n              opts.fs = new FragmentShader({\n                handle: shaderHandle\n              });\n              break;\n\n            default:\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return opts;\n    }\n  }, {\n    key: \"_getParameter\",\n    value: function _getParameter(pname) {\n      return this.gl.getProgramParameter(this.handle, pname);\n    } // If program is not named, name it after shader names\n    // TODO - this.id will already have been initialized\n\n  }, {\n    key: \"_setId\",\n    value: function _setId(id) {\n      if (!id) {\n        var programName = this._getName();\n\n        this.id = uid(programName);\n      }\n    } // Generate a default name for the program based on names of the shaders\n\n  }, {\n    key: \"_getName\",\n    value: function _getName() {\n      var programName = this.vs.getName() || this.fs.getName();\n      programName = programName.replace(/shader/i, '');\n      programName = programName ? \"\".concat(programName, \"-program\") : 'program';\n      return programName;\n    }\n  }, {\n    key: \"_compileAndLink\",\n    value: function _compileAndLink() {\n      var gl = this.gl;\n      gl.attachShader(this.handle, this.vs.handle);\n      gl.attachShader(this.handle, this.fs.handle);\n      log.time(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))();\n      gl.linkProgram(this.handle);\n      log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, \"linkProgram for \".concat(this._getName()))(); // Avoid checking program linking error in production\n\n      if (gl.debug || log.priority > 0) {\n        gl.validateProgram(this.handle);\n        var linked = gl.getProgramParameter(this.handle, 35714);\n\n        if (!linked) {\n          throw new Error(\"Error linking: \".concat(gl.getProgramInfoLog(this.handle)));\n        }\n      }\n    } // query uniform locations and build name to setter map.\n\n  }, {\n    key: \"_readUniformLocationsFromLinkedProgram\",\n    value: function _readUniformLocationsFromLinkedProgram() {\n      var gl = this.gl;\n      this._uniformSetters = {};\n      this._uniformCount = this._getParameter(35718);\n\n      for (var i = 0; i < this._uniformCount; i++) {\n        var info = this.gl.getActiveUniform(this.handle, i);\n\n        var _parseUniformName = parseUniformName(info.name),\n            name = _parseUniformName.name,\n            isArray = _parseUniformName.isArray;\n\n        var location = gl.getUniformLocation(this.handle, name);\n        this._uniformSetters[name] = getUniformSetter(gl, location, info, isArray);\n      }\n\n      this._textureIndexCounter = 0;\n    } // stub for shader chache, should reset uniforms to default valiues\n\n  }, {\n    key: \"reset\",\n    value: function reset() {} // TO BE REMOVED in v7?\n    // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)\n    // https://\n    // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms\n\n  }, {\n    key: \"getActiveUniforms\",\n    value: function getActiveUniforms(uniformIndices, pname) {\n      return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);\n    } // Retrieves the index of a uniform block\n\n  }, {\n    key: \"getUniformBlockIndex\",\n    value: function getUniformBlockIndex(blockName) {\n      return this.gl.getUniformBlockIndex(this.handle, blockName);\n    } // Retrieves information about an active uniform block (`blockIndex`)\n    // https://\n    // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter\n\n  }, {\n    key: \"getActiveUniformBlockParameter\",\n    value: function getActiveUniformBlockParameter(blockIndex, pname) {\n      return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);\n    } // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)\n\n  }, {\n    key: \"uniformBlockBinding\",\n    value: function uniformBlockBinding(blockIndex, blockBinding) {\n      this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);\n    }\n  }]);\n\n  return Program;\n}(Resource);\n\nexport { Program as default };","map":null,"metadata":{},"sourceType":"module"}