{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n\nimport Layer from './layer';\nimport { log } from './utils';\n\nvar CompositeLayer = function (_Layer) {\n  _inherits(CompositeLayer, _Layer);\n\n  function CompositeLayer(props) {\n    _classCallCheck(this, CompositeLayer);\n\n    return _possibleConstructorReturn(this, (CompositeLayer.__proto__ || Object.getPrototypeOf(CompositeLayer)).call(this, props));\n  }\n\n  _createClass(CompositeLayer, [{\n    key: 'initializeState',\n    // initializeState is usually not needed for composite layers\n    // Provide empty definition to disable check for missing definition\n    value: function initializeState() {} // No-op for the invalidateAttribute function as the composite\n    // layer has no AttributeManager\n\n  }, {\n    key: 'invalidateAttribute',\n    value: function invalidateAttribute() {} // called to augment the info object that is bubbled up from a sublayer\n    // override Layer.getPickingInfo() because decoding / setting uniform do\n    // not apply to a composite layer.\n    // @return null to cancel event\n\n  }, {\n    key: 'getPickingInfo',\n    value: function getPickingInfo(_ref) {\n      var info = _ref.info;\n      return info;\n    } // Implement to generate sublayers\n\n  }, {\n    key: 'renderLayers',\n    value: function renderLayers() {\n      return null;\n    } // Returns props that should be forwarded to children\n    // TODO - implement autoforwarding?\n\n  }, {\n    key: 'getForwardProps',\n    value: function getForwardProps() {\n      var _props = this.props,\n          opacity = _props.opacity,\n          pickable = _props.pickable,\n          visible = _props.visible,\n          parameters = _props.parameters,\n          getPolygonOffset = _props.getPolygonOffset,\n          highlightedObjectIndex = _props.highlightedObjectIndex,\n          autoHighlight = _props.autoHighlight,\n          highlightColor = _props.highlightColor,\n          coordinateSystem = _props.coordinateSystem,\n          coordinateOrigin = _props.coordinateOrigin,\n          modelMatrix = _props.modelMatrix;\n      return {\n        // Forward layer props\n        opacity: opacity,\n        pickable: pickable,\n        visible: visible,\n        parameters: parameters,\n        getPolygonOffset: getPolygonOffset,\n        highlightedObjectIndex: highlightedObjectIndex,\n        autoHighlight: autoHighlight,\n        highlightColor: highlightColor,\n        coordinateSystem: coordinateSystem,\n        coordinateOrigin: coordinateOrigin,\n        modelMatrix: modelMatrix\n      };\n    }\n  }, {\n    key: '_renderLayers',\n    value: function _renderLayers(updateParams) {\n      if (!this.shouldUpdateState(updateParams)) {\n        log.log(2, 'Composite layer reusing sublayers', this.state.oldSubLayers);\n        return this.state.oldSubLayers;\n      }\n\n      var subLayers = this.renderLayers();\n      this.state.oldSubLayers = subLayers;\n      log.log(2, 'Composite layer saving sublayers', this.state.oldSubLayers);\n      return subLayers;\n    }\n  }, {\n    key: 'isComposite',\n    get: function get() {\n      return true;\n    }\n  }]);\n\n  return CompositeLayer;\n}(Layer);\n\nexport default CompositeLayer;","map":null,"metadata":{},"sourceType":"module"}