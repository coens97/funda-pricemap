{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport Texture from './texture';\nimport assert from '../utils/assert';\nvar FACES = [34069, 34070, 34071, 34072, 34073, 34074];\n\nvar TextureCube =\n/*#__PURE__*/\nfunction (_Texture) {\n  _inherits(TextureCube, _Texture);\n\n  function TextureCube(gl) {\n    var _this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, TextureCube);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextureCube).call(this, gl, Object.assign({}, opts, {\n      target: 34067\n    })));\n\n    _this.initialize(opts);\n\n    Object.seal(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /* eslint-disable max-len, max-statements */\n\n\n  _createClass(TextureCube, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _opts$format = opts.format,\n          format = _opts$format === void 0 ? 6408 : _opts$format,\n          _opts$mipmaps = opts.mipmaps,\n          mipmaps = _opts$mipmaps === void 0 ? true : _opts$mipmaps;\n      var _opts$width = opts.width,\n          width = _opts$width === void 0 ? 1 : _opts$width,\n          _opts$height = opts.height,\n          height = _opts$height === void 0 ? 1 : _opts$height,\n          _opts$type = opts.type,\n          type = _opts$type === void 0 ? 5121 : _opts$type,\n          dataFormat = opts.dataFormat; // Deduce width and height based on one of the faces\n\n      var _this$_deduceParamete = this._deduceParameters({\n        format: format,\n        type: type,\n        dataFormat: dataFormat\n      });\n\n      type = _this$_deduceParamete.type;\n      dataFormat = _this$_deduceParamete.dataFormat;\n\n      var _this$_deduceImageSiz = this._deduceImageSize({\n        data: opts[34069],\n        width: width,\n        height: height\n      });\n\n      width = _this$_deduceImageSiz.width;\n      height = _this$_deduceImageSiz.height; // Enforce cube\n\n      assert(width === height); // Temporarily apply any pixel store paramaters and build textures\n      // withParameters(this.gl, opts, () => {\n      //   for (const face of CUBE_MAP_FACES) {\n      //     this.setImageData({\n      //       target: face,\n      //       data: opts[face],\n      //       width, height, format, type, dataFormat, border, mipmaps\n      //     });\n      //   }\n      // });\n\n      this.setCubeMapImageData(opts); // Called here so that GL.\n      // TODO - should genMipmap() be called on the cubemap or on the faces?\n\n      if (mipmaps) {\n        this.generateMipmap(opts);\n      } // Store opts for accessors\n\n\n      this.opts = opts;\n    }\n  }, {\n    key: \"subImage\",\n    value: function subImage(_ref) {\n      var face = _ref.face,\n          data = _ref.data,\n          _ref$x = _ref.x,\n          x = _ref$x === void 0 ? 0 : _ref$x,\n          _ref$y = _ref.y,\n          y = _ref$y === void 0 ? 0 : _ref$y,\n          _ref$mipmapLevel = _ref.mipmapLevel,\n          mipmapLevel = _ref$mipmapLevel === void 0 ? 0 : _ref$mipmapLevel;\n      return this._subImage({\n        target: face,\n        data: data,\n        x: x,\n        y: y,\n        mipmapLevel: mipmapLevel\n      });\n    }\n    /* eslint-disable max-statements, max-len */\n\n  }, {\n    key: \"setCubeMapImageData\",\n    value: function setCubeMapImageData(_ref2) {\n      var width = _ref2.width,\n          height = _ref2.height,\n          pixels = _ref2.pixels,\n          data = _ref2.data,\n          _ref2$border = _ref2.border,\n          border = _ref2$border === void 0 ? 0 : _ref2$border,\n          _ref2$format = _ref2.format,\n          format = _ref2$format === void 0 ? 6408 : _ref2$format,\n          _ref2$type = _ref2.type,\n          type = _ref2$type === void 0 ? 5121 : _ref2$type,\n          _ref2$generateMipmap = _ref2.generateMipmap,\n          generateMipmap = _ref2$generateMipmap === void 0 ? false : _ref2$generateMipmap;\n      var gl = this.gl;\n      pixels = pixels || data;\n      this.bind();\n\n      if (this.width || this.height) {\n        for (var _i = 0; _i < FACES.length; _i++) {\n          var face = FACES[_i];\n          gl.texImage2D(face, 0, format, width, height, border, format, type, pixels[face]);\n        }\n      } else {\n        for (var _i2 = 0; _i2 < FACES.length; _i2++) {\n          var _face = FACES[_i2];\n          gl.texImage2D(_face, 0, format, format, type, pixels[_face]);\n        }\n      }\n    }\n  }, {\n    key: \"bind\",\n    value: function bind() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          index = _ref3.index;\n\n      if (index !== undefined) {\n        this.gl.activeTexture(33984 + index);\n      }\n\n      this.gl.bindTexture(34067, this.handle);\n      return index;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind() {\n      this.gl.bindTexture(34067, null);\n      return this;\n    }\n  }]);\n\n  return TextureCube;\n}(Texture);\n\nexport { TextureCube as default };\nTextureCube.FACES = FACES;","map":null,"metadata":{},"sourceType":"module"}