{"ast":null,"code":"function _instanceof(left, right) {\n  return null != right && \"undefined\" != typeof Symbol && right[Symbol.hasInstance] ? right[Symbol.hasInstance](left) : left instanceof right;\n}\n\nfunction _typeof(obj) {\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!_instanceof(instance, Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  return call && (\"object\" === _typeof(call) || \"function\" == typeof call) ? call : _assertThisInitialized(self);\n}\n\nfunction _defineProperties(target, props) {\n  for (var descriptor, i = 0; i < props.length; i++) {\n    descriptor = props[i], descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, \"value\" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (\"function\" != typeof superClass && null !== superClass) throw new TypeError(\"Super expression must either be null or a function\");\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: !0,\n      configurable: !0\n    }\n  }), superClass && _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  return _setPrototypeOf = Object.setPrototypeOf || function (o, p) {\n    return o.__proto__ = p, o;\n  }, _setPrototypeOf(o, p);\n}\n\nfunction _assertThisInitialized(self) {\n  if (void 0 === self) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return self;\n}\n\nimport { PureComponent, createElement } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { setDiffStyle } from \"../utils/style-utils\";\nimport isImmutableMap from \"../utils/is-immutable-map\";\nimport WebMercatorViewport from \"viewport-mercator-project\";\nimport Mapbox from \"../mapbox/mapbox\";\nimport isBrowser from \"../utils/is-browser\";\nimport { checkVisibilityConstraints } from \"../utils/map-constraints\";\nvar mapboxgl = isBrowser ? require(\"mapbox-gl\") : null,\n    TOKEN_DOC_URL = \"https://uber.github.io/react-map-gl/#/Documentation/getting-started/about-mapbox-tokens\",\n    NO_TOKEN_WARNING = \"A valid API access token is required to use Mapbox data\";\n\nfunction noop() {}\n\nvar UNAUTHORIZED_ERROR_CODE = 401,\n    propTypes = Object.assign({}, Mapbox.propTypes, {\n  mapStyle: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),\n  preventStyleDiffing: PropTypes.bool,\n  disableTokenWarning: PropTypes.bool,\n  visible: PropTypes.bool,\n  visibilityConstraints: PropTypes.object\n}),\n    defaultProps = Object.assign({}, Mapbox.defaultProps, {\n  mapStyle: \"mapbox://styles/mapbox/light-v8\",\n  preventStyleDiffing: !1,\n  visible: !0\n}),\n    childContextTypes = {\n  viewport: PropTypes.instanceOf(WebMercatorViewport)\n},\n    StaticMap = function (_PureComponent) {\n  function StaticMap(props) {\n    var _this;\n\n    return _classCallCheck(this, StaticMap), _this = _possibleConstructorReturn(this, (StaticMap.__proto__ || Object.getPrototypeOf(StaticMap)).call(this, props)), _this._queryParams = {}, StaticMap.supported() || (_this.componentDidMount = noop, _this.componentWillReceiveProps = noop, _this.componentDidUpdate = noop, _this.componentWillUnmount = noop), _this.state = {\n      accessTokenInvalid: !1\n    }, _this.getMap = _this.getMap.bind(_assertThisInitialized(_this)), _this.queryRenderedFeatures = _this.queryRenderedFeatures.bind(_assertThisInitialized(_this)), _this._updateMapSize = _this._updateMapSize.bind(_assertThisInitialized(_this)), _this._updateMapStyle = _this._updateMapStyle.bind(_assertThisInitialized(_this)), _this._mapboxMapLoaded = _this._mapboxMapLoaded.bind(_assertThisInitialized(_this)), _this._mapboxMapError = _this._mapboxMapError.bind(_assertThisInitialized(_this)), _this._renderNoTokenWarning = _this._renderNoTokenWarning.bind(_assertThisInitialized(_this)), _this;\n  }\n\n  return _inherits(StaticMap, _PureComponent), _createClass(StaticMap, null, [{\n    key: \"supported\",\n    value: function supported() {\n      return mapboxgl && mapboxgl.supported();\n    }\n  }]), _createClass(StaticMap, [{\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      return {\n        viewport: new WebMercatorViewport(this.props)\n      };\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var mapStyle = this.props.mapStyle;\n      this._mapbox = new Mapbox(Object.assign({}, this.props, {\n        mapboxgl: mapboxgl,\n        container: this._mapboxMap,\n        onError: this._mapboxMapError,\n        mapStyle: isImmutableMap(mapStyle) ? mapStyle.toJS() : mapStyle\n      })), this._map = this._mapbox.getMap();\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(newProps) {\n      this._mapbox.setProps(newProps), this._updateMapStyle(this.props, newProps), this.setState({\n        width: this.props.width,\n        height: this.props.height\n      });\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this._updateMapSize(this.state, this.props);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._mapbox.finalize(), this._mapbox = null, this._map = null;\n    }\n  }, {\n    key: \"getMap\",\n    value: function getMap() {\n      return this._map;\n    }\n  }, {\n    key: \"queryRenderedFeatures\",\n    value: function queryRenderedFeatures(geometry) {\n      var options = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {};\n      return this._map.queryRenderedFeatures(geometry, options);\n    }\n  }, {\n    key: \"_updateMapSize\",\n    value: function _updateMapSize(oldProps, newProps) {\n      var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;\n      sizeChanged && this._map.resize();\n    }\n  }, {\n    key: \"_updateMapStyle\",\n    value: function _updateMapStyle(oldProps, newProps) {\n      var mapStyle = newProps.mapStyle,\n          oldMapStyle = oldProps.mapStyle;\n      mapStyle !== oldMapStyle && (isImmutableMap(mapStyle) ? this.props.preventStyleDiffing ? this._map.setStyle(mapStyle.toJS()) : setDiffStyle(oldMapStyle, mapStyle, this._map) : this._map.setStyle(mapStyle));\n    }\n  }, {\n    key: \"_mapboxMapLoaded\",\n    value: function _mapboxMapLoaded(ref) {\n      this._mapboxMap = ref;\n    }\n  }, {\n    key: \"_mapboxMapError\",\n    value: function _mapboxMapError(evt) {\n      var statusCode = evt.error && evt.error.status || evt.status;\n      statusCode !== UNAUTHORIZED_ERROR_CODE || this.state.accessTokenInvalid || (console.error(NO_TOKEN_WARNING), this.setState({\n        accessTokenInvalid: !0\n      }));\n    }\n  }, {\n    key: \"_renderNoTokenWarning\",\n    value: function _renderNoTokenWarning() {\n      if (this.state.accessTokenInvalid && !this.props.disableTokenWarning) {\n        return createElement(\"div\", {\n          key: \"warning\",\n          id: \"no-token-warning\",\n          style: {\n            position: \"absolute\",\n            left: 0,\n            top: 0\n          }\n        }, [createElement(\"h3\", {\n          key: \"header\"\n        }, NO_TOKEN_WARNING), createElement(\"div\", {\n          key: \"text\"\n        }, \"For information on setting up your basemap, read\"), createElement(\"a\", {\n          key: \"link\",\n          href: TOKEN_DOC_URL\n        }, \"Note on Map Tokens\")]);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          className = _this$props.className,\n          width = _this$props.width,\n          height = _this$props.height,\n          style = _this$props.style,\n          visibilityConstraints = _this$props.visibilityConstraints,\n          mapContainerStyle = Object.assign({}, style, {\n        width: width,\n        height: height,\n        position: \"relative\"\n      }),\n          visible = this.props.visible && checkVisibilityConstraints(this.props.viewState || this.props, visibilityConstraints),\n          mapStyle = Object.assign({}, style, {\n        width: width,\n        height: height,\n        visibility: visible ? \"visible\" : \"hidden\"\n      });\n      return createElement(\"div\", {\n        key: \"map-container\",\n        style: mapContainerStyle,\n        children: [createElement(\"div\", {\n          key: \"map-mapbox\",\n          ref: this._mapboxMapLoaded,\n          style: mapStyle,\n          className: className\n        }), createElement(\"div\", {\n          key: \"map-overlays\",\n          className: \"overlays\",\n          style: {\n            position: \"absolute\",\n            left: 0,\n            top: 0,\n            width: width,\n            height: height,\n            overflow: \"hidden\"\n          },\n          children: this.props.children\n        }), this._renderNoTokenWarning()]\n      });\n    }\n  }]), StaticMap;\n}(PureComponent);\n\nexport { StaticMap as default };\nStaticMap.displayName = \"StaticMap\", StaticMap.propTypes = propTypes, StaticMap.defaultProps = defaultProps, StaticMap.childContextTypes = childContextTypes;","map":null,"metadata":{},"sourceType":"module"}