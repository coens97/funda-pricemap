{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n}; // Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/**\n * Access properties of nested containers using dot-path notation\n * - Supports plain objects and arrays, as well as classes with `get` methods\n *   such as ES6 Maps, Immutable.js objects etc\n * - Returns undefined if any container is not valid, instead of throwing\n *\n * @param {Object} container - container that supports get\n * @param {String|*} compositeKey - key to access, can be '.'-separated string\n * @return {*} - value in the final key of the nested container\n */\n\n\nexport function get(container, compositeKey) {\n  // Split the key into subkeys\n  var keyList = getKeys(compositeKey); // Recursively get the value of each key;\n\n  var value = container;\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = keyList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value; // If any intermediate subfield is not a container, return undefined\n\n      if (!isObject(value)) {\n        return undefined;\n      } // Get the `getter` for this container\n\n\n      var getter = getGetter(value); // Use the getter to get the value for the key\n\n      value = getter(value, key);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return value;\n}\n/**\n * Checks if argument is an indexable object (not a primitive value, nor null)\n * @param {*} value - JavaScript value to be tested\n * @return {Boolean} - true if argument is a JavaScript object\n */\n\nfunction isObject(value) {\n  return value !== null && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object';\n} // Default getter is container indexing\n\n\nvar squareBracketGetter = function squareBracketGetter(container, key) {\n  return container[key];\n};\n\nvar getMethodGetter = function getMethodGetter(obj, key) {\n  return obj.get(key);\n}; // Cache key to key arrays for speed\n\n\nvar keyMap = {}; // Looks for a `get` function on the prototype\n// TODO - follow prototype chain?\n// @private\n// @return {Function} - get function: (container, key) => value\n\nfunction getGetter(container) {\n  // Check if container has a special get method\n  var prototype = Object.getPrototypeOf(container);\n  return prototype.get ? getMethodGetter : squareBracketGetter;\n} // Takes a string of '.' separated keys and returns an array of keys\n// E.g. 'feature.geometry.type' => 'feature', 'geometry', 'type'\n// @private\n\n\nfunction getKeys(compositeKey) {\n  if (typeof compositeKey === 'string') {\n    // else assume string and split around dots\n    var keyList = keyMap[compositeKey];\n\n    if (!keyList) {\n      keyList = compositeKey.split('.');\n      keyMap[compositeKey] = keyList;\n    }\n\n    return keyList;\n  } // Wrap in array if needed\n\n\n  return Array.isArray(compositeKey) ? compositeKey : [compositeKey];\n}","map":null,"metadata":{},"sourceType":"module"}