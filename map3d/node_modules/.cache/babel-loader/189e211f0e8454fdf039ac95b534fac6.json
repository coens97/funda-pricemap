{"ast":null,"code":"// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport mat4_multiply from 'gl-mat4/multiply';\nimport vec4_transformMat4 from 'gl-vec4/transformMat4';\nimport { COORDINATE_SYSTEM } from '../../lib/constants';\nimport memoize from '../../utils/memoize';\nimport log from '../../utils/log';\nimport assert from '../../utils/assert';\nimport { PROJECT_COORDINATE_SYSTEM } from './constants'; // To quickly set a vector to zero\n\nvar ZERO_VECTOR = [0, 0, 0, 0]; // 4x4 matrix that drops 4th component of vector\n\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nvar IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];\nvar DEFAULT_COORDINATE_ORIGIN = [0, 0, 0]; // Based on viewport-mercator-project/test/fp32-limits.js\n\nexport var LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD = 12;\nvar getMemoizedViewportUniforms = memoize(calculateViewportUniforms);\n\nfunction getShaderCoordinateSystem(coordinateSystem) {\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n    case COORDINATE_SYSTEM.LNGLAT_EXPERIMENTAL:\n    default:\n      return PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET;\n\n    case COORDINATE_SYSTEM.LNGLAT_DEPRECATED:\n      return PROJECT_COORDINATE_SYSTEM.LNG_LAT;\n\n    case COORDINATE_SYSTEM.METER_OFFSETS:\n    case COORDINATE_SYSTEM.METERS:\n      return PROJECT_COORDINATE_SYSTEM.METER_OFFSETS;\n\n    case COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      return PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS;\n\n    case COORDINATE_SYSTEM.IDENTITY:\n      return PROJECT_COORDINATE_SYSTEM.IDENTITY;\n  }\n} // The code that utilizes Matrix4 does the same calculation as their mat4 counterparts,\n// has lower performance but provides error checking.\n// Uncomment when debugging\n\n\nfunction calculateMatrixAndOffset(_ref) {\n  var viewport = _ref.viewport,\n      coordinateSystem = _ref.coordinateSystem,\n      coordinateOrigin = _ref.coordinateOrigin,\n      coordinateZoom = _ref.coordinateZoom;\n  var viewMatrixUncentered = viewport.viewMatrixUncentered;\n  var viewMatrix = viewport.viewMatrix;\n  var projectionMatrix = viewport.projectionMatrix;\n  var viewProjectionMatrix = viewport.viewProjectionMatrix;\n  var projectionCenter;\n  var shaderCoordinateSystem = getShaderCoordinateSystem(coordinateSystem);\n  var shaderCoordinateOrigin = coordinateOrigin;\n\n  if (shaderCoordinateSystem === PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET) {\n    if (coordinateZoom < LNGLAT_AUTO_OFFSET_ZOOM_THRESHOLD) {\n      // Use LNG_LAT projection if not zooming\n      shaderCoordinateSystem = PROJECT_COORDINATE_SYSTEM.LNG_LAT;\n    } else {\n      // Use LNGLAT_AUTO_OFFSET\n      var lng = Math.fround(viewport.longitude);\n      var lat = Math.fround(viewport.latitude);\n      shaderCoordinateOrigin = [lng, lat];\n    }\n  }\n\n  switch (shaderCoordinateSystem) {\n    case PROJECT_COORDINATE_SYSTEM.IDENTITY:\n    case PROJECT_COORDINATE_SYSTEM.LNG_LAT:\n      projectionCenter = ZERO_VECTOR;\n      break;\n    // TODO: make lighting work for meter offset mode\n\n    case PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n    case PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:\n    case PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:\n      // Calculate transformed projectionCenter (using 64 bit precision JS)\n      // This is the key to offset mode precision\n      // (avoids doing this addition in 32 bit precision in GLSL)\n      var positionPixels = viewport.projectFlat(shaderCoordinateOrigin, Math.pow(2, coordinateZoom)); // projectionCenter = new Matrix4(viewProjectionMatrix)\n      //   .transformVector([positionPixels[0], positionPixels[1], 0.0, 1.0]);\n\n      projectionCenter = vec4_transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix); // Always apply uncentered projection matrix if available (shader adds center)\n\n      viewMatrix = viewMatrixUncentered || viewMatrix; // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n      // viewMatrix = new Matrix4(viewMatrixUncentered || viewMatrix)\n      //   .multiplyRight(VECTOR_TO_POINT_MATRIX);\n\n      viewProjectionMatrix = mat4_multiply([], projectionMatrix, viewMatrix);\n      viewProjectionMatrix = mat4_multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n      break;\n\n    default:\n      throw new Error('Unknown projection mode');\n  }\n\n  return {\n    viewMatrix: viewMatrix,\n    viewProjectionMatrix: viewProjectionMatrix,\n    projectionCenter: projectionCenter,\n    cameraPos: viewport.cameraPosition,\n    shaderCoordinateSystem: shaderCoordinateSystem,\n    shaderCoordinateOrigin: shaderCoordinateOrigin\n  };\n}\n/**\n * Returns uniforms for shaders based on current projection\n * includes: projection matrix suitable for shaders\n *\n * TODO - Ensure this works with any viewport, not just WebMercatorViewports\n *\n * @param {WebMercatorViewport} viewport -\n * @return {Float32Array} - 4x4 projection matrix that can be used in shaders\n */\n\n\nexport function getUniformsFromViewport() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      viewport = _ref2.viewport,\n      _ref2$devicePixelRati = _ref2.devicePixelRatio,\n      devicePixelRatio = _ref2$devicePixelRati === void 0 ? 1 : _ref2$devicePixelRati,\n      _ref2$modelMatrix = _ref2.modelMatrix,\n      modelMatrix = _ref2$modelMatrix === void 0 ? null : _ref2$modelMatrix,\n      _ref2$coordinateSyste = _ref2.coordinateSystem,\n      coordinateSystem = _ref2$coordinateSyste === void 0 ? COORDINATE_SYSTEM.LNGLAT : _ref2$coordinateSyste,\n      _ref2$coordinateOrigi = _ref2.coordinateOrigin,\n      coordinateOrigin = _ref2$coordinateOrigi === void 0 ? DEFAULT_COORDINATE_ORIGIN : _ref2$coordinateOrigi,\n      _ref2$wrapLongitude = _ref2.wrapLongitude,\n      wrapLongitude = _ref2$wrapLongitude === void 0 ? false : _ref2$wrapLongitude,\n      projectionMode = _ref2.projectionMode,\n      positionOrigin = _ref2.positionOrigin;\n\n  assert(viewport);\n\n  if (projectionMode !== undefined) {\n    log.removed('projectionMode', 'coordinateSystem');\n  }\n\n  if (positionOrigin !== undefined) {\n    log.removed('positionOrigin', 'coordinateOrigin');\n  }\n\n  return Object.assign({\n    project_uModelMatrix: modelMatrix || IDENTITY_MATRIX\n  }, getMemoizedViewportUniforms({\n    viewport: viewport,\n    devicePixelRatio: devicePixelRatio,\n    coordinateSystem: coordinateSystem,\n    coordinateOrigin: coordinateOrigin,\n    wrapLongitude: wrapLongitude\n  }));\n}\n\nfunction calculateViewportUniforms(_ref3) {\n  var viewport = _ref3.viewport,\n      devicePixelRatio = _ref3.devicePixelRatio,\n      coordinateSystem = _ref3.coordinateSystem,\n      coordinateOrigin = _ref3.coordinateOrigin,\n      wrapLongitude = _ref3.wrapLongitude;\n  var coordinateZoom = viewport.zoom;\n  assert(coordinateZoom >= 0);\n\n  var _calculateMatrixAndOf = calculateMatrixAndOffset({\n    coordinateSystem: coordinateSystem,\n    coordinateOrigin: coordinateOrigin,\n    coordinateZoom: coordinateZoom,\n    viewport: viewport\n  }),\n      projectionCenter = _calculateMatrixAndOf.projectionCenter,\n      viewProjectionMatrix = _calculateMatrixAndOf.viewProjectionMatrix,\n      cameraPos = _calculateMatrixAndOf.cameraPos,\n      shaderCoordinateSystem = _calculateMatrixAndOf.shaderCoordinateSystem,\n      shaderCoordinateOrigin = _calculateMatrixAndOf.shaderCoordinateOrigin;\n\n  assert(viewProjectionMatrix, 'Viewport missing modelViewProjectionMatrix'); // Calculate projection pixels per unit\n\n  var distanceScales = viewport.getDistanceScales();\n  var viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];\n  var uniforms = {\n    // Projection mode values\n    project_uCoordinateSystem: shaderCoordinateSystem,\n    project_uCenter: projectionCenter,\n    project_uWrapLongitude: wrapLongitude,\n    project_uAntimeridian: (viewport.longitude || 0) - 180,\n    // Screen size\n    project_uViewportSize: viewportSize,\n    project_uDevicePixelRatio: devicePixelRatio,\n    // Distance at which screen pixels are projected\n    project_uFocalDistance: viewport.focalDistance || 1,\n    project_uPixelsPerMeter: distanceScales.pixelsPerMeter,\n    project_uPixelsPerDegree: distanceScales.pixelsPerDegree,\n    project_uPixelsPerUnit: distanceScales.pixelsPerMeter,\n    project_uPixelsPerUnit2: DEFAULT_PIXELS_PER_UNIT2,\n    project_uScale: viewport.scale,\n    // This is the mercator scale (2 ** zoom)\n    project_uViewProjectionMatrix: viewProjectionMatrix,\n    // This is for lighting calculations\n    project_uCameraPosition: cameraPos\n  };\n  var distanceScalesAtOrigin = viewport.getDistanceScales(shaderCoordinateOrigin);\n\n  switch (shaderCoordinateSystem) {\n    case PROJECT_COORDINATE_SYSTEM.METER_OFFSETS:\n      uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerMeter;\n      uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerMeter2;\n      break;\n\n    case PROJECT_COORDINATE_SYSTEM.LNGLAT_AUTO_OFFSET:\n      uniforms.project_coordinate_origin = shaderCoordinateOrigin;\n    // eslint-disable-line no-fallthrough\n\n    case PROJECT_COORDINATE_SYSTEM.LNGLAT_OFFSETS:\n      uniforms.project_uPixelsPerUnit = distanceScalesAtOrigin.pixelsPerDegree;\n      uniforms.project_uPixelsPerUnit2 = distanceScalesAtOrigin.pixelsPerDegree2;\n      break;\n\n    default:\n      break;\n  }\n\n  return uniforms;\n}","map":null,"metadata":{},"sourceType":"module"}