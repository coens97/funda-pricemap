{"ast":null,"code":"function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Khronos Debug support module\n\n\nimport WebGLDebug from 'webgl-debug';\nimport { log } from '../utils';\nimport { installParameterDefinitions } from './api/debug-parameters';\ninstallParameterDefinitions(); // Helper to get shared context data\n\nfunction getContextData(gl) {\n  gl.luma = gl.luma || {};\n  return gl.luma;\n} // Enable or disable debug checks in debug contexts\n// Non-debug contexts do not have checks (to ensure performance)\n// Turning off debug for debug contexts removes most of the performance penalty\n\n\nexport function enableDebug(debug) {\n  log.debug = debug;\n} // Returns (a potentially new) context with debug instrumentation turned off or on.\n// Note that this actually returns a new context\n\nexport function makeDebugContext(gl) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      debug = _ref.debug;\n\n  if (gl === null) {\n    // Return to ensure we don't create a context in this case.\n    return null;\n  }\n\n  return debug ? getDebugContext(gl) : getRealContext(gl);\n} // Returns the real context from either of the real/debug contexts\n\nexport function getRealContext(gl) {\n  if (gl === null) {\n    // Return to ensure we don't create a context in this case.\n    return null;\n  }\n\n  var data = getContextData(gl); // If the context has a realContext member, it is a debug context so return the realContext\n\n  return data.realContext ? data.realContext : gl;\n} // Returns the debug context from either of the real/debug contexts\n\nexport function getDebugContext(gl) {\n  if (gl === null) {\n    // Return to ensure we don't create a context in this case.\n    return null;\n  }\n\n  var data = getContextData(gl); // If this *is* a debug context, return itself\n\n  if (data.realContext) {\n    return gl;\n  } // If this already has a debug context, return it.\n\n\n  if (data.debugContext) {\n    return data.debugContext;\n  } // Create a new debug context\n\n\n  var WebGLDebugContext =\n  /*#__PURE__*/\n  function WebGLDebugContext() {\n    _classCallCheck(this, WebGLDebugContext);\n  };\n\n  var debugContext = WebGLDebug.makeDebugContext(gl, throwOnError, validateArgsAndLog);\n  Object.assign(WebGLDebugContext.prototype, debugContext); // Store the debug context\n\n  data.debugContext = debugContext;\n  debugContext.debug = true; // Return it\n\n  return debugContext;\n} // DEBUG TRACING\n\nfunction getFunctionString(functionName, functionArgs) {\n  var args = WebGLDebug.glFunctionArgsToString(functionName, functionArgs);\n  args = '' + args.slice(0, 100) + (args.length > 100 ? '...' : '');\n  return 'gl.' + functionName + '(' + args + ')';\n}\n\nfunction throwOnError(err, functionName, args) {\n  if (!log.nothrow) {\n    var errorMessage = WebGLDebug.glEnumToString(err);\n    var functionArgs = WebGLDebug.glFunctionArgsToString(functionName, args);\n    throw new Error(errorMessage + ' in gl.' + functionName + '(' + functionArgs + ')');\n  }\n} // Don't generate function string until it is needed\n\n\nfunction validateArgsAndLog(functionName, functionArgs) {\n  if (!log.debug) {\n    return;\n  }\n\n  var functionString = void 0;\n\n  if (log.priority >= 4) {\n    functionString = getFunctionString(functionName, functionArgs);\n    log.info(4, '' + functionString);\n  }\n\n  if (log.break) {\n    functionString = functionString || getFunctionString(functionName, functionArgs);\n    var isBreakpoint = log.break && log.break.every(function (breakOn) {\n      return functionString.indexOf(breakOn) !== -1;\n    });\n\n    if (isBreakpoint) {\n      /* eslint-disable no-debugger */\n      debugger;\n      /* eslint-enable no-debugger */\n    }\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = functionArgs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var arg = _step.value;\n\n      if (arg === undefined) {\n        functionString = functionString || getFunctionString(functionName, functionArgs);\n        throw new Error('Undefined argument: ' + functionString);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}